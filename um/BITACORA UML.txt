20190722

BAJE EL .CONFIG DE 
https://uml.devloop.org.uk/kernels.html
Y UN FS ROOT DEBIAN
http://fs.devloop.org.uk/

hice 
make menuconfig 
seleccione algunas cosas diferentes

luego para compilar 
make ARCH=um mrproper
make ARCH=um defconfig
make ARCH=um menuconfig
make ARCH=um

Deja el ejecutable en /usr/src/linux archivo "linux"

http://user-mode-linux.sourceforge.net/
http://uml.devloop.org.uk/index.html
http://fs.devloop.org.uk/ FILESYSTEMS 
http://uml.devloop.org.uk/kernels.html

BITACORA UML EN DVS 

cd /usr/src/dvs/vos/uml 
mount /dev/sdc8 uml1
entonces en  /1 
copio el "linux"
y el filesystem Debian

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NO PUDE USAR NI LOS KERNELS NI LOS ROOTFS DE LAS PAGINAS DE UML 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

TUVE MUCHOS INCONVENIENTES PERO PUDE BOOTEAR CON (tanto de CONSOLA HOST como desde SSH ) 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6   mem=1024M 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
En mi caso, /dev/sdc5, /dev/sdc6 y /dev/sdc7 es un Debian pristino instalado directamente desde la red

root@node0:/# mount /dev/sdc5 /mnt
root@node0:/# ls /mnt
bin   DC0ROOT.txt  etc   lib    mnt  proc  run   srv  tmp  var
boot  dev          home  media  opt  root  sbin  sys  usr
root@node0:/# umount  /mnt
root@node0:/# mount /dev/sdc6 /mnt
root@node0:/# ls /mnt
bin   DC1ROOT.txt  etc   lib    mnt  proc  run   srv  tmp  var
boot  dev          home  media  opt  root  sbin  sys  usr
root@node0:/# umount  /mnt
root@node0:/# mount /dev/sdc7 /mnt
root@node0:/# ls /mnt
bin   DC2ROOT.txt  etc   lib         media  opt   root  sbin  sys  usr
boot  dev          home  lost+found  mnt    proc  run   srv   tmp  var
root@node0:/# umount  /mnt

root@node0:/usr/src/dvs/vos/uml/uml1# fdisk -l /dev/sdc
Disco /dev/sdc: 20 GiB, 21474836480 bytes, 41943040 sectores
Unidades: sectores de 1 * 512 = 512 bytes
TamaÃ±o de sector (lÃ³gico/fÃ­sico): 512 bytes / 512 bytes
TamaÃ±o de E/S (mÃ­nimo/Ã³ptimo): 512 bytes / 512 bytes
Tipo de etiqueta de disco: dos
Identificador del disco: 0x79c16f1c

Disposit.  Inicio Comienzo    Final Sectores TamaÃ±o Id Tipo
/dev/sdc1             2048 41943039 41940992    20G  5 Extendida
/dev/sdc5             4096  2101247  2097152     1G 83 Linux  <<<< DEBIAN 
/dev/sdc6          2103296  4200447  2097152     1G 83 Linux <<<< DEBIAN 
/dev/sdc7          4202496  6299647  2097152     1G 83 Linux <<<< DEBIAN 
/dev/sdc8          6301696 41943039 35641344    17G 83 Linux <<<< El actual directorio de UML 

root@node0:/usr/src/dvs/vos/uml/uml1# mount | grep uml
/dev/sdc8 on /usr/src/dvs/vos/uml/uml1 type ext3 (rw,relatime,data=ordered)
ATENCION: No montar esto en forma permanente para que no quede en las imagenes BOOTCD 
MONTAR A MANO
root@node0:/# cd /usr/src/dvs/vos/uml/uml1/
root@node0:/usr/src/dvs/vos/uml# mount /dev/sdc8 uml1 


Si hay problemas con la password de root hacer:
root@node0:/# mount /dev/sdc5 /mnt
root@node0:/# cd /mnt
root@node0:/mnt# chroot .
root@node0:/mnt# passwd 
root@node0:/mnt# exit 
root@node0:/# umount  /mnt

Si fuese un archivo de imagen 
root@node0:/# mount -o loop  <archivo de imagen> /mnt
root@node0:/# cd /mnt
root@node0:/mnt# chroot .
root@node0:/mnt# passwd      <<<<<<<< AQUI CAMBIA LA PASSWORD 
root@node0:/mnt# exit 
root@node0:/# umount  /mnt

Cambiandole la password a la imagen de DEBIAN JESSIE pude bootear incluso desde SSH 
	* kernel32-4.3.5
	 * Debian-Jessie-x86-root_fs
root@node0:~# cd /usr/src/dvs/vos/uml/uml1/
root@node0:/usr/src/dvs/vos/uml/uml1# ./kernel32-4.3.5 con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=Debian-Jessie-x86-root_fs  mem=1024M 
Locating the bottom of the address space ... 0x0
Locating the top of the address space ... 0xc0000000
Core dump limits :
        soft - 0
        hard - NONE
Checking that ptrace can change system call numbers...OK
Checking syscall emulation patch for ptrace...OK
Checking advanced syscall emulation patch for ptrace...OK
Checking environment variables for a tempdir...none found
Checking if /dev/shm is on tmpfs...OK
Checking PROT_EXEC mmap in /dev/shm...OK
Adding 16322560 bytes to physical memory to account for exec-shield gap
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Initializing cgroup subsys cpuacct
[    0.000000] Linux version 4.3.5 (root@virtual.nagafix.co.uk) (gcc version 4.9.3 (Gentoo 4.9.3 p1.2, pie-0.6.3) ) #4 Mon Feb 1 00:26:30 Local time zone must be set--see zic manua
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 264049
[    0.000000] Kernel command line: con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=Debian-Jessie-x86-root_fs mem=1024M root=98:0
[    0.000000] PID hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Dentry cache hash table entries: 262144 (order: 8, 1048576 bytes)
[    0.000000] Inode-cache hash table entries: 131072 (order: 7, 524288 bytes)
[    0.000000] Memory: 1029596K/1064516K available (5556K kernel code, 345K rwdata, 2648K rodata, 139K init, 332K bss, 34920K reserved, 0K cma-reserved)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] NR_IRQS:15
[    0.000000] clocksource: itimer: mask: 0xffffffffffffffff max_cycles: 0x1d854df40, max_idle_ns: 3526361616960 ns
[    0.040000] Calibrating delay loop... 1469.64 BogoMIPS (lpj=7348224)
[    0.040000] pid_max: default: 32768 minimum: 301
[    0.040000] Security Framework initialized
[    0.040000] SELinux:  Initializing.
[    0.040000] AppArmor: AppArmor disabled by boot time parameter
[    0.040000] Mount-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.040000] Mountpoint-cache hash table entries: 4096 (order: 2, 16384 bytes)
[    0.040000] Initializing cgroup subsys io
[    0.040000] Initializing cgroup subsys devices
[    0.040000] Initializing cgroup subsys freezer
[    0.040000] Initializing cgroup subsys net_cls
[    0.040000] Checking for host processor cmov support...Yes
[    0.040000] Checking that host ptys support output SIGIO...Yes
[    0.040000] Checking that host ptys support SIGIO on close...No, enabling workaround
[    0.040000] devtmpfs: initialized
[    0.040000] Using 2.6 host AIO
[    0.040000] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
[    0.040000] xor: measuring software checksum speed
[    0.140000]    8regs     :  3063.600 MB/sec
[    0.240000]    8regs_prefetch:  3154.400 MB/sec
[    0.340000]    32regs    :  2340.400 MB/sec
[    0.440000]    32regs_prefetch:  1859.200 MB/sec
[    0.440000] xor: using function: 8regs_prefetch (3154.400 MB/sec)
[    0.440000] NET: Registered protocol family 16
[    0.610000] raid6: int32x1  gen()   717 MB/s
[    0.780000] raid6: int32x1  xor()   488 MB/s
[    0.950000] raid6: int32x2  gen()   847 MB/s
[    1.120000] raid6: int32x2  xor()   519 MB/s
[    1.290000] raid6: int32x4  gen()   825 MB/s
[    1.460000] raid6: int32x4  xor()   539 MB/s
[    1.630000] raid6: int32x8  gen()   746 MB/s
[    1.800000] raid6: int32x8  xor()   475 MB/s
[    1.800000] raid6: using algorithm int32x2 gen() 847 MB/s
[    1.800000] raid6: .... xor() 519 MB/s, rmw enabled
[    1.800000] raid6: using intx1 recovery algorithm
[    1.800000] NetLabel: Initializing
[    1.800000] NetLabel:  domain hash size = 128
[    1.800000] NetLabel:  protocols = UNLABELED CIPSOv4
[    1.800000] NetLabel:  unlabeled traffic allowed by default
[    1.800000] clocksource: Switched to clocksource itimer
[    1.800000] FS-Cache: Loaded
[    1.800000] CacheFiles: Loaded
[    1.800000] NET: Registered protocol family 2
[    1.800000] TCP established hash table entries: 16384 (order: 4, 65536 bytes)
[    1.800000] TCP bind hash table entries: 16384 (order: 4, 65536 bytes)
[    1.800000] TCP: Hash tables configured (established 16384 bind 16384)
[    1.800000] UDP hash table entries: 1024 (order: 2, 16384 bytes)
[    1.800000] UDP-Lite hash table entries: 1024 (order: 2, 16384 bytes)
[    1.800000] NET: Registered protocol family 1
[    1.800000] RPC: Registered named UNIX socket transport module.
[    1.800000] RPC: Registered udp transport module.
[    1.800000] RPC: Registered tcp transport module.
[    1.800000] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    1.800000] console [stderr0] disabled
[    1.800000] mconsole (version 2) initialized on /root/.uml/oNgXFf/mconsole
[    1.800000] Checking host MADV_REMOVE support...OK
[    1.800000] UML Watchdog Timer
[    1.800000] Host TLS support detected
[    1.800000] Detected host type: i386 (GDT indexes 6 to 9)
[    1.800000] futex hash table entries: 256 (order: -1, 3072 bytes)
[    1.800000] audit: initializing netlink subsys (disabled)
[    1.800000] audit: type=2000 audit(1556486507.255:1): initialized
[    1.800000] Initialise system trusted keyring
[    1.800000] VFS: Disk quotas dquot_6.6.0
[    1.800000] VFS: Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
[    1.800000] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    1.800000] FS-Cache: Netfs 'nfs' registered for caching
[    1.800000] NFS: Registering the id_resolver key type
[    1.800000] Key type id_resolver registered
[    1.800000] Key type id_legacy registered
[    1.800000] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    1.800000] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...
[    1.800000] Installing knfsd (copyright (C) 1996 okir@monad.swb.de).
[    1.800000] FS-Cache: Netfs 'cifs' registered for caching
[    1.800000] Key type cifs.spnego registered
[    1.800000] Key type cifs.idmap registered
[    1.800000] ntfs: driver 2.1.32 [Flags: R/W].
[    1.800000] fuse init (API version 7.23)
[    1.800000] NILFS version 2 loaded
[    1.800000] gfs2: GFS2 installed
[    1.800000] Key type big_key registered
[    2.070000] alg: rsa: test failed on vector 4, err=-74
[    2.070000] alg: No test for 842 (842-generic)
[    2.070000] jitterentropy: Initialization failed with host not compliant with requirements: 2
[    2.070000] NET: Registered protocol family 38
[    2.070000] Key type asymmetric registered
[    2.070000] Asymmetric key parser 'x509' registered
[    2.070000] Key type pkcs7_test registered
[    2.070000] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 253)
[    2.070000] io scheduler noop registered
[    2.070000] io scheduler deadline registered
[    2.070000] io scheduler cfq registered (default)
[    2.070000] xz_dec_test: module loaded
[    2.070000] xz_dec_test: Create a device node with 'mknod xz_dec_test c 252 0' and write .xz files to it.
[    2.110000] brd: module loaded
[    2.110000] loop: module loaded
[    2.110000] nbd: registered device at major 43
[    2.110000] drbd: failed to initialize debugfs -- will not be available
[    2.110000] drbd: initialized. Version: 8.4.5 (api:1/proto:86-101)
[    2.110000] drbd: built-in
[    2.110000] drbd: registered as block device major 147
[    2.110000] PPP generic driver version 2.4.2
[    2.110000] PPP BSD Compression module registered
[    2.110000] PPP Deflate Compression module registered
[    2.110000] PPP MPPE Compression module registered
[    2.110000] NET: Registered protocol family 24
[    2.110000] SLIP: version 0.8.4-NET3.019-NEWTTY (dynamic channels, max=256) (6 bit encapsulation enabled).
[    2.110000] CSLIP: code copyright 1989 Regents of the University of California.
[    2.110000] SLIP linefill/keepalive option.
[    2.110000] watchdog: Software Watchdog: cannot register miscdev on minor=130 (err=-16).
[    2.110000] watchdog: Software Watchdog: a legacy watchdog module is probably present.
[    2.110000] softdog: Software Watchdog Timer: 0.08 initialized. soft_noboot=0 soft_margin=60 sec soft_panic=0 (nowayout=0)
[    2.110000] Netfilter messages via NETLINK v0.30.
[    2.110000] nfnl_acct: registering with nfnetlink.
[    2.110000] nf_conntrack version 0.5.0 (16087 buckets, 64348 max)
[    2.110000] nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>
[    2.110000] nf_tables_compat: (c) 2012 Pablo Neira Ayuso <pablo@netfilter.org>
[    2.110000] xt_time: kernel timezone is -0000
[    2.110000] ip_set: protocol 6
[    2.110000] ip_tables: (C) 2000-2006 Netfilter Core Team
[    2.110000] ipt_CLUSTERIP: ClusterIP Version 0.8 loaded successfully
[    2.110000] arp_tables: (C) 2002 David S. Miller
[    2.110000] NET: Registered protocol family 10
[    2.110000] mip6: Mobile IPv6
[    2.110000] ip6_tables: (C) 2000-2006 Netfilter Core Team
[    2.110000] sit: IPv6 over IPv4 tunneling driver
[    2.200000] ip6_gre: GRE over IPv6 tunneling driver
[    2.200000] NET: Registered protocol family 17
[    2.200000] bridge: automatic filtering via arp/ip/ip6tables has been deprecated. Update your scripts to load br_netfilter if you need this.
[    2.200000] Bridge firewalling registered
[    2.200000] Ebtables v2.0 registered
[    2.200000] Key type dns_resolver registered
[    2.200000] Initialized stdio console driver
[    2.200000] Console initialized on /dev/tty0
[    2.200000] console [tty0] enabled
[    2.200000] Initializing software serial port version 1
[    2.200000] console [mc-1] enabled
[    2.200000] Loading compiled-in X.509 certificates
[    2.200000] Btrfs loaded
[    2.200000] Key type encrypted registered
[    2.200000] EXT2-fs (ubda): error: couldn't mount because of unsupported optional features (240)
[    2.200000] EXT4-fs (ubda): couldn't mount as ext3 due to feature incompatibilities
[    2.200000] EXT4-fs (ubda): mounted filesystem with ordered data mode. Opts: (null)
[    2.200000] VFS: Mounted root (ext4 filesystem) readonly on device 98:0.
[    2.200000] random: systemd urandom read with 15 bits of entropy available
[    2.200000] systemd[1]: systemd 215 running in system mode. (+PAM +AUDIT +SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP +GCRYPT +ACL +XZ -SECCOMP -APPARMOR)
[    2.200000] systemd[1]: Detected virtualization 'vmware'.
[    2.200000] systemd[1]: Detected architecture 'x86'.

Welcome to Debian GNU/Linux 8 (jessie)!

[    2.200000] systemd[1]: No hostname configured.
[    2.200000] systemd[1]: Set hostname to <localhost>.
[    2.200000] systemd[1]: Failed to enable kbrequest handling: Inappropriate ioctl for device
[    2.680000] systemd[1]: Cannot add dependency job for unit dbus.socket, ignoring: Unit dbus.socket failed to load: No such file or directory.
[    2.680000] systemd[1]: Cannot add dependency job for unit display-manager.service, ignoring: Unit display-manager.service failed to load: No such file or directory.
[    2.680000] systemd[1]: Starting Forward Password Requests to Wall Directory Watch.
[    2.680000] systemd[1]: Started Forward Password Requests to Wall Directory Watch.
[    2.680000] systemd[1]: Starting Remote File Systems (Pre).
[  OK  ] Reached target Remote File Systems (Pre).
[    2.680000] systemd[1]: Reached target Remote File Systems (Pre).
[    2.680000] systemd[1]: Starting Arbitrary Executable File Formats File System Automount Point.
[  OK  ] Set up automount Arbitrary Executable File Formats F...utomount Point.
[    2.680000] systemd[1]: Set up automount Arbitrary Executable File Formats File System Automount Point.
[    2.680000] systemd[1]: Starting Encrypted Volumes.
[  OK  ] Reached target Encrypted Volumes.
[    2.680000] systemd[1]: Reached target Encrypted Volumes.
[    2.680000] systemd[1]: Starting Dispatch Password Requests to Console Directory Watch.
[    2.680000] systemd[1]: Started Dispatch Password Requests to Console Directory Watch.
[    2.680000] systemd[1]: Starting Paths.
[  OK  ] Reached target Paths.
[    2.680000] systemd[1]: Reached target Paths.
[    2.680000] systemd[1]: Starting Swap.
[  OK  ] Reached target Swap.
[    2.680000] systemd[1]: Reached target Swap.
[    2.680000] systemd[1]: Starting Root Slice.
[  OK  ] Created slice Root Slice.
[    2.680000] systemd[1]: Created slice Root Slice.
[    2.680000] systemd[1]: Starting User and Session Slice.
[  OK  ] Created slice User and Session Slice.
[    2.680000] systemd[1]: Created slice User and Session Slice.
[    2.680000] systemd[1]: Starting /dev/initctl Compatibility Named Pipe.
[  OK  ] Listening on /dev/initctl Compatibility Named Pipe.
[    2.680000] systemd[1]: Listening on /dev/initctl Compatibility Named Pipe.
[    2.680000] systemd[1]: Starting Delayed Shutdown Socket.
[  OK  ] Listening on Delayed Shutdown Socket.
[    2.680000] systemd[1]: Listening on Delayed Shutdown Socket.
[    2.680000] systemd[1]: Starting Journal Socket (/dev/log).
[  OK  ] Listening on Journal Socket (/dev/log).
[    2.680000] systemd[1]: Listening on Journal Socket (/dev/log).
[    2.680000] systemd[1]: Starting udev Control Socket.
[  OK  ] Listening on udev Control Socket.
[    2.680000] systemd[1]: Listening on udev Control Socket.
[    2.680000] systemd[1]: Starting udev Kernel Socket.
[  OK  ] Listening on udev Kernel Socket.
[    2.680000] systemd[1]: Listening on udev Kernel Socket.
[    2.680000] systemd[1]: Starting Journal Socket.
[  OK  ] Listening on Journal Socket.
[    2.680000] systemd[1]: Listening on Journal Socket.
[    2.680000] systemd[1]: Starting System Slice.
[  OK  ] Created slice System Slice.
[    2.680000] systemd[1]: Created slice System Slice.
[    2.680000] systemd[1]: Starting File System Check on Root Device...
         Starting File System Check on Root Device...
[    2.680000] systemd[1]: Starting system-getty.slice.
[  OK  ] Created slice system-getty.slice.
[    2.830000] systemd[1]: Created slice system-getty.slice.
[    2.830000] systemd[1]: Starting Increase datagram queue length...
         Starting Increase datagram queue length...
[    2.830000] systemd[1]: Mounted Huge Pages File System.
[    2.890000] systemd[1]: Started Set Up Additional Binary Formats.
[    2.890000] systemd[1]: Starting Load Kernel Modules...
         Starting Load Kernel Modules...
[    2.890000] systemd[1]: Mounted Debug File System.
[    2.890000] systemd[1]: Starting udev Coldplug all Devices...
         Starting udev Coldplug all Devices...
[    2.890000] systemd[1]: Mounting POSIX Message Queue File System...
         Mounting POSIX Message Queue File System...
[    2.890000] systemd[1]: Started Create list of required static device nodes for the current kernel.
[    2.890000] systemd[1]: Starting Create Static Device Nodes in /dev...
         Starting Create Static Device Nodes in /dev...
[    2.890000] systemd[1]: Starting Slices.
[  OK  ] Reached target Slices.
[    2.890000] systemd[1]: Reached target Slices.
[  OK  ] Started Increase datagram queue length.
[    3.050000] systemd[1]: Started Increase datagram queue length.
[  OK  ] Started Load Kernel Modules.
[    3.050000] systemd[1]: Started Load Kernel Modules.
[  OK  ] Mounted POSIX Message Queue File System.
[    3.050000] systemd[1]: Mounted POSIX Message Queue File System.
[  OK  ] Started Create Static Device Nodes in /dev.
[    3.330000] systemd[1]: Started Create Static Device Nodes in /dev.
[  OK  ] Started File System Check on Root Device.
[    3.350000] systemd[1]: Started File System Check on Root Device.
[    3.510000] systemd[1]: Starting Remount Root and Kernel File Systems...
         Starting Remount Root and Kernel File Systems...
[    3.510000] systemd[1]: Starting udev Kernel Device Manager...
         Starting udev Kernel Device Manager...
[    3.510000] systemd[1]: Mounting Configuration File System...
         Mounting Configuration File System...
[    3.510000] systemd[1]: Starting Apply Kernel Variables...
         Starting Apply Kernel Variables...
[    3.510000] systemd[1]: Mounting FUSE Control File System...
         Mounting FUSE Control File System...
[    3.510000] systemd[1]: Starting Syslog Socket.
[  OK  ] Listening on Syslog Socket.
[    3.510000] systemd[1]: Listening on Syslog Socket.
[    3.510000] systemd[1]: Starting Sockets.
[  OK  ] Reached target Sockets.
[    3.510000] systemd[1]: Reached target Sockets.
[    3.510000] systemd[1]: Starting Journal Service...
         Starting Journal Service...
[  OK  ] Started Journal Service.
[    3.510000] systemd[1]: Started Journal Service.
[  OK  ] Mounted FUSE Control File System.
[  OK  ] Started Apply Kernel Variables.
[    3.900000] systemd-udevd[1187]: starting version 215
[    4.020000] EXT4-fs (ubda): re-mounted. Opts: (null)
[  OK  ] Mounted Configuration File System.
[  OK  ] Started udev Kernel Device Manager.
[  OK  ] Started Remount Root and Kernel File Systems.
[  OK  ] Started udev Coldplug all Devices.
[    4.384178] systemd-fsck[1110]: ROOT: clean, 16163/65536 files, 88947/262144 blocks
         Starting Load/Save Random Seed...
[  OK  ] Reached target Local File Systems (Pre).
         Mounting /tmp...
         Starting Copy rules generated while the root was ro...
[  OK  ] Mounted /tmp.
[  OK  ] Started Load/Save Random Seed.
[  OK  ] Started Copy rules generated while the root was ro.
[  OK  ] Reached target Local File Systems.
[  OK  ] Reached target Remote File Systems.
         Starting Trigger Flushing of Journal to Persistent Storage...
         Starting Create Volatile Files and Directories...
         Starting LSB: Raise network interfaces....
[  OK  ] Started Create Volatile Files and Directories.
         Starting Update UTMP about System Boot/Shutdown...
[    5.500000] systemd-journald[1191]: Received request to flush runtime journal from PID 1
[  OK  ] Started Trigger Flushing of Journal to Persistent Storage.
[  OK  ] Started Update UTMP about System Boot/Shutdown.
[  OK  ] Started LSB: Raise network interfaces..
[  OK  ] Reached target Network.
[  OK  ] Reached target System Initialization.
[  OK  ] Reached target Timers.
[  OK  ] Reached target Basic System.
         Starting Regular background program processing daemon...
[  OK  ] Started Regular background program processing daemon.
         Starting /etc/rc.local Compatibility...
         Starting System Logging Service...
         Starting Permit User Sessions...
[  OK  ] Started System Logging Service.
[  OK  ] Started /etc/rc.local Compatibility.
[  OK  ] Started Permit User Sessions.
         Starting Getty on tty1...
[  OK  ] Started Getty on tty1.
[  OK  ] Reached target Login Prompts.
[  OK  ] Reached target Multi-User System.
[  OK  ] Reached target Graphical Interface.
         Starting Update UTMP about System Runlevel Changes...
[  OK  ] Started Update UTMP about System Runlevel Changes.

Debian GNU/Linux 8 localhost tty1

localhost login: root[   10.060000] random: nonblocking pool is initialized

Password: 
Last login: Sun Apr 28 21:20:33 UTC 2019 on tty1
Linux localhost 4.3.5 #4 Mon Feb 1 00:26:30 Local time zone must be set--see zic manua i686

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@localhost:~#

==============================================================================================
20190429:
		Se incluyo el driver uml_dvk.c muy basico en  linux/arch/um/drivers
		y se modifico el Makefile para compilarlo.
		
		Al bootear 
		root@node0:/usr/src/dvs/vos/uml/uml1#  ./linux-dvk-uml con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdc6   mem=1024M 
		uno de los mensajes es:
			UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
			DEBUG 1:uml_dvk_init_module:132: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)

		Se verifican los simbolos definidos 
			root@node0:~# grep dvk /proc/kallsyms                                                         
			0804aefd t uml_dvk_init_module
			0805f02c t set_dvk
			0805f063 t uml_dvk_release
			0805f09d t uml_dvk_open
			0805f13f t uml_dvk_ioctl
			080d5e9e t dvk_vm_rw_core
			080d60ab t dvk_vm_rw
			080df992 T dvk_rw_check_kvector
			081d8e04 T dvk_check_iovect
		
TODO: 	
		Se modifico el Kconfig de linux/arch/x86 
		
		root@node0:/usr/src/linux# grep DVK test.config 
			CONFIG_DVS_DVK=y

		Se modifico /usr/src/linux/arch/um/drivers/Kconfig.char 	
		#
		# UML Character Devices
		#
		CONFIG_UML_DVK=y
		
		
 .config - User Mode Linux/x86 4.9.88 Kernel Configuration
 qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
  lqqqqqqqqqqqqqqqq User Mode Linux/x86 4.9.88 Kernel Configuration qqqqqqqqqqqqqqqqk
  x  Arrow keys navigate the menu.  <Enter> selects submenus ---> (or empty         x
  x  submenus ----).  Highlighted letters are hotkeys.  Pressing <Y> includes, <N>  x
  x  excludes, <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help,   x
  x  </> for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < > module    x
  x lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk x
  x x        UML-specific options  --->                                           x x
  x x        General setup  --->                                                  x x
  x x    [*] Enable loadable module support  --->                                 x x
  x x    -*- Enable the block layer  --->                                         x x
  x x        UML Character Devices  --->    !!!!!!!!!!! AQUI                      x x
  x x        Device Drivers  --->                                                 x x
  x x    [*] Networking support  --->                                             x x
  x x        UML Network Devices  --->                                            x x
  x x        File systems  --->                                                   x x
  x x        Security options  --->                                               x x
  x x    -*- Cryptographic API  --->                                              x x
  x x        Library routines  --->                                               x x
  x mqqqqv(+)qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj x
  tqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqu
  x            <Select>    < Exit >    < Help >    < Save >    < Load >             x
  mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj


   UML Character Devices qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
  lqqqqqqqqqqqqqqqqqqqqqqqqqqqqq UML Character Devices qqqqqqqqqqqqqqqqqqqqqqqqqqqqqk
  x  Arrow keys navigate the menu.  <Enter> selects submenus ---> (or empty         x
  x  submenus ----).  Highlighted letters are hotkeys.  Pressing <Y> includes, <N>  x
  x  excludes, <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help,   x
  x  </> for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < > module    x
  x lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk x
  x x    [*] UML Distributed Virtualization Kernel (DVK) pseudo character device  x x <<<<<<<<<<<<<<<<
  x x    [*] stderr console                                                       x x
  x x    [*] Virtual serial line                                                  x x
  x x    [*] null channel support                                                 x x
  x x    [*] port channel support                                                 x x
  x x    [*] pty channel support                                                  x x
  x x    [*] tty channel support                                                  x x
  x x    [*] xterm channel support                                                x x
  x x    (fd:0,fd:1) Default main console channel initialization                  x x
  x x    (pts) Default console channel initialization                             x x
  x x    (pts) Default serial line channel initialization                         x x
  x x    <*> Sound support                                                        x x
  x mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj x
  tqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqu
  x            <Select>    < Exit >    < Help >    < Save >    < Load >             x
  mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj

  Probe a ver si se ve el driver
  
  SIN ARRANCAR EL DVS EN EL HOST 
root@uml-sdc6:~# mknod /dev/dvk c 33 0
root@uml-sdc6:~# echo hola > /dev/dvk
DEBUG 674:uml_dvk_open:81: dvk_dev=/dev/dvk
DEBUG 674:uml_dvk_open:89: rcode=-2
-bash: /dev/dvk: No such file or directory
root@uml-sdc6:~# ls -l /dev/dvk
crw-r--r-- 1 root root 33, 0 Apr 29 23:40 /dev/dvk

  ARRANCANDO EL DVS EN EL HOST 
 root@uml-sdc6:~# echo hola > /dev/dvk                                                         
DEBUG 674:uml_dvk_open:81: dvk_dev=/dev/dvk
DEBUG 674:uml_dvk_open:89: rcode=19
-bash: echo: write error: Invalid argument
DEBUG 674:uml_dvk_release:102: dvk_dev=/dev/dvk

DMESG EN UML 
root@uml-sdc6:~# dmesg | grep DEBUG
[    0.120000] DEBUG 1:uml_dvk_init_module:132: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
[ 3275.080000] DEBUG 674:uml_dvk_open:81: dvk_dev=/dev/dvk
[ 3275.080000] DEBUG 674:uml_dvk_open:89: rcode=-2
[ 3423.180000] DEBUG 674:uml_dvk_open:81: dvk_dev=/dev/dvk
[ 3423.180000] DEBUG 674:uml_dvk_open:89: rcode=19
[ 3423.180000] DEBUG 674:uml_dvk_release:102: dvk_dev=/dev/dvk

DMESG EN HOST 
[ 9035.934351] DEBUG 3754:dvk_open:167: 
		
==============================================================================================
20190430 :
				
		EJECUCION DE UML DENTRO DEL NAMESPACE 
			En HOST
			cd /usr/src/dvs/dvk-tests
			./tests.sh 0 0
			cd /dev/shm
			. ./DC0.sh 
			cd /usr/src/dvs/vos/uml/uml1
			nsenter -p -t$DC0 ./linux-dvk-uml con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdc6 mem=1024M 		

			EN UML 	
			root@node0:/usr/src/dvs/dvk-tests# mknod /dev/dvk c 33 0

			TRATO DE EJECUTAR UN SERVIDOR DENTRO DEL UML 
			root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 10
			DEBUG 647:dvk_open:47: Open dvk device file /dev/dvk
			DEBUG 647:uml_dvk_open:83: dvk_dev=/dev/dvk
			DEBUG 647:uml_dvk_open:91: rcode=23
			DEBUG 647:dvk_getdvsinfo:120: 
			DEBUG 647:uml_dvk_ioctl:62: cmd=8004E31B arg=BF998B68
			DEBUG 647:uml_dvk_ioctl:70: rcode=0
			DEBUG 647:dvk_getdvsinfo:122: ioctl ret=0
			 copy_server.c:main:47:local_nodeid=0
			 copy_server.c:main:48:d_nr_dcs=0 d_nr_nodes=0 d_nr_procs=0 d_nr_tasks=0 d_nr_sysprocs=0 
			DEBUG 647:dvk_getdcinfo:170: dcid=0
			DEBUG 647:uml_dvk_ioctl:62: cmd=8004E30E arg=BF998B24
			DEBUG 647:uml_dvk_ioctl:70: rcode=0
			DEBUG 647:dvk_getdcinfo:174: ioctl ret=0 errno=0
			 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
			 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
			svr_ep must be > 0 and < 0
			DEBUG 647:uml_dvk_release:104: dvk_dev=/dev/dvk
					
			DMESG EN HOST 
			[ 3593.456788] DEBUG 6811:dvk_open:167: 
			[ 3593.458626] DEBUG 6811:dvk_ioctl:204: cmd=8004E31B arg=BF998B68
			[ 3593.458629] DEBUG 6811:dvk_ioctl:224: DVK_CALL=27 (getdvsinfo) 
			[ 3593.458732] DEBUG 6811:io_getdvsinfo:288: 
			[ 3593.458736] DEBUG 6811:new_getdvsinfo:1784: local_nodeid=0 
			[ 3593.463375] DEBUG 6811:dvk_ioctl:204: cmd=8004E30E arg=BF998B24
			[ 3593.463379] DEBUG 6811:dvk_ioctl:224: DVK_CALL=14 (getdcinfo) 
			[ 3593.463380] DEBUG 6811:io_getdcinfo:153: 
			[ 3593.463383] DEBUG 6811:new_getdcinfo:1813: dcid=0 
			[ 3593.463386] DEBUG 6811:check_caller:536: caller_pid=6811 caller_tgid=6811
			[ 3593.463387] ERROR: 6811:check_caller:570: rcode=-310
			[ 3593.463389] DEBUG 6811:new_getdcinfo:1831: RLOCK_DC dc=0 count=0
			[ 3593.463391] DEBUG 6811:new_getdcinfo:1833: RUNLOCK_DC dc=0 count=0
			[ 3593.464124] DVK: exit_unbind local_nodeid:0		
					
			DMESG UML
			[  242.870000] DEBUG 647:uml_dvk_open:83: dvk_dev=/dev/dvk
			[  242.880000] DEBUG 647:uml_dvk_open:91: rcode=23
			[  242.880000] DEBUG 647:uml_dvk_ioctl:62: cmd=8004E31B arg=BF998B68
			[  242.880000] DEBUG 647:uml_dvk_ioctl:70: rcode=0
			[  242.880000] DEBUG 647:uml_dvk_ioctl:62: cmd=8004E30E arg=BF998B24
			[  242.880000] DEBUG 647:uml_dvk_ioctl:70: rcode=0
			[  242.880000] DEBUG 647:uml_dvk_release:104: dvk_dev=/dev/dvk 

PROBLEMA:
			EL PARAMETRO DE ADDRESS QUE PASA EL PROCESO DENTRO DE UML NO ES EL VERDADERO
			POR LO TANTO LA COPIA DESDE EL DVK HACIA EL PROCESO DENTRO DE UML NO ESCRIBE EN EL LUGAR CORRECTO
			
PRUEBA:		HACER UN PROGRAMA QUE HAGA BIND Y LUEGO GETEP 

root@node0:/usr/src/dvs/dvk-tests# ./test_bind 0 10
DEBUG 651:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 651:uml_dvk_open:83: dvk_dev=/dev/dvk
DEBUG 651:uml_dvk_open:91: rcode=23
PARENT dvk_bind Binding process 651 to DC0 with p_nr=10
DEBUG 651:dvk_bind_X:607: cmd=0 dcid=0 pid=-1 endpoint=10 nodeid=-1
DEBUG 651:uml_dvk_ioctl:62: cmd=4004E309 arg=BFF31CD8
DEBUG 651:uml_dvk_ioctl:70: rcode=-7
DEBUG 651:dvk_bind_X:616: ioctl ret=-1 errno=7
DEBUG 651:dvk_getep:109: pid=651
DEBUG 651:uml_dvk_ioctl:62: cmd=8004E31A arg=28B
DEBUG 651:uml_dvk_ioctl:70: rcode=-310
DEBUG 651:dvk_getep:111: ioctl ret=-1 errno=310
ERROR: 651:dvk_getep:112: rcode=-310
PARENT ep=-1 dvk_getep=-310
PARENT dvk_lclbind 652 to DC0 with p_nr+index=11
DEBUG 651:dvk_bind_X:607: cmd=1 dcid=0 pid=652 endpoint=11 nodeid=-1
DEBUG 651:uml_dvk_ioctl:62: cmd=4004E309 arg=BFF31CD8
DEBUG 651:uml_dvk_ioctl:70: rcode=-7
DEBUG 651:dvk_bind_X:616: ioctl ret=-1 errno=7
DEBUG 651:dvk_getep:109: pid=652
CHILD[1] dvk_lclbind
DEBUG 651:uml_dvk_ioctl:62: cmd=8004E31A arg=28C
DEBUG 651:uml_dvk_ioctl:70: rcode=-310
DEBUG 651:dvk_getep:111: ioctl ret=-1 errno=310
ERROR: 651:dvk_getep:112: rcode=-310
PARENT ep=-1 dvk_getep=-310
CHILD[2] dvk_replbind Binding process 653 to DC0 with p_nr=12
DEBUG 653:dvk_bind_X:607: cmd=4 dcid=0 pid=653 endpoint=12 nodeid=-1
DEBUG 653:uml_dvk_ioctl:62: cmd=4004E309 arg=BFF31CD8
DEBUG 653:uml_dvk_ioctl:70: rcode=-7
DEBUG 653:dvk_bind_X:616: ioctl ret=-1 errno=7
DEBUG 653:dvk_getep:109: pid=653
PARENT waiting child index=2
DEBUG 653:uml_dvk_ioctl:62: cmd=8004E31A arg=28D
DEBUG 653:uml_dvk_ioctl:70: rcode=-310
DEBUG 653:dvk_getep:111: ioctl ret=-1 errno=310
ERROR: 653:dvk_getep:112: rcode=-310
CHILD[2] ep=-1 dvk_getep=-310
DEBUG 652:dvk_getep:109: pid=652
DEBUG 652:uml_dvk_ioctl:62: cmd=8004E31A arg=28C
DEBUG 652:uml_dvk_ioctl:70: rcode=-310
DEBUG 652:dvk_getep:111: ioctl ret=-1 errno=310
ERROR: 652:dvk_getep:112: rcode=-310
CHILD[1] dvk_getep=-310

EN HOST 
[ 3914.739362] DEBUG 6811:dvk_open:167: 
[ 3914.741520] DEBUG 6811:dvk_ioctl:204: cmd=4004E309 arg=BFF31CD8
[ 3914.741523] DEBUG 6811:dvk_ioctl:224: DVK_CALL=9 (bind) 
[ 3914.741524] DEBUG 6811:io_bind:97: 
[ 3914.741531] ERROR: 6811:io_bind:99: rcode=-7
[ 3914.741533] ERROR: 6811:dvk_ioctl:228: rcode=-7
[ 3914.742277] DEBUG 6811:dvk_ioctl:204: cmd=8004E31A arg=28B
[ 3914.742279] DEBUG 6811:dvk_ioctl:224: DVK_CALL=26 (getep) 
[ 3914.742347] DEBUG 6811:io_getep:279: 
[ 3914.742349] DEBUG 6811:new_getep:1966: pid=651
[ 3914.742352] DEBUG 6811:check_caller:536: caller_pid=6811 caller_tgid=6811
[ 3914.742353] ERROR: 6811:check_caller:570: rcode=-310
[ 3914.742355] ERROR: 6811:dvk_ioctl:228: rcode=-310
[ 3914.771912] DEBUG 6811:dvk_ioctl:204: cmd=4004E309 arg=BFF31CD8
[ 3914.771916] DEBUG 6811:dvk_ioctl:224: DVK_CALL=9 (bind) 
[ 3914.771917] DEBUG 6811:io_bind:97: 
[ 3914.771924] ERROR: 6811:io_bind:99: rcode=-7
[ 3914.771926] ERROR: 6811:dvk_ioctl:228: rcode=-7
[ 3914.797432] DEBUG 6811:dvk_ioctl:204: cmd=8004E31A arg=28C
[ 3914.797436] DEBUG 6811:dvk_ioctl:224: DVK_CALL=26 (getep) 
[ 3914.797437] DEBUG 6811:io_getep:279: 
[ 3914.797439] DEBUG 6811:new_getep:1966: pid=652
[ 3914.797442] DEBUG 6811:check_caller:536: caller_pid=6811 caller_tgid=6811
[ 3914.797444] ERROR: 6811:check_caller:570: rcode=-310
[ 3914.797445] ERROR: 6811:dvk_ioctl:228: rcode=-310
[ 3914.811079] DEBUG 6811:dvk_ioctl:204: cmd=4004E309 arg=BFF31CD8
[ 3914.811082] DEBUG 6811:dvk_ioctl:224: DVK_CALL=9 (bind) 
[ 3914.811084] DEBUG 6811:io_bind:97: 
[ 3914.811089] ERROR: 6811:io_bind:99: rcode=-7
[ 3914.811091] ERROR: 6811:dvk_ioctl:228: rcode=-7
[ 3914.832395] DEBUG 6811:dvk_ioctl:204: cmd=8004E31A arg=28D
[ 3914.832401] DEBUG 6811:dvk_ioctl:224: DVK_CALL=26 (getep) 
[ 3914.832402] DEBUG 6811:io_getep:279: 
[ 3914.832404] DEBUG 6811:new_getep:1966: pid=653
[ 3914.832408] DEBUG 6811:check_caller:536: caller_pid=6811 caller_tgid=6811
[ 3914.832409] ERROR: 6811:check_caller:570: rcode=-310
[ 3914.832411] ERROR: 6811:dvk_ioctl:228: rcode=-310
[ 3919.787014] DEBUG 6811:dvk_ioctl:204: cmd=8004E31A arg=28C
[ 3919.787018] DEBUG 6811:dvk_ioctl:224: DVK_CALL=26 (getep) 
[ 3919.787019] DEBUG 6811:io_getep:279: 
[ 3919.787021] DEBUG 6811:new_getep:1966: pid=652
[ 3919.787024] DEBUG 6811:check_caller:536: caller_pid=6811 caller_tgid=6811
[ 3919.787025] ERROR: 6811:check_caller:570: rcode=-310
[ 3919.787026] ERROR: 6811:dvk_ioctl:228: rcode=-310
[ 3954.156308] DVK: exit_unbind local_nodeid:0


==============================================================================================
20190430.  EL PROBLEMA SON LAS DIRECCIONES EN MODO USUARIO. 

Se modifico temporalemente um_dvk.c funcion uml_dvk_ioctl()
Se distingue cuando es el pedido de GETDVSINFO del resto.
Para GETDVSINFO se copia en forma local la estructura de datos y luego se la transfiere a 
modo usuario. De esta forma funciona

DEBUG 643:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
	
	
Se pueden decodificar los IOCTL con 
/* used to decode ioctl numbers.. */
#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)


TODOS LOS PROCESOS DE USUARIO UML SE EJECUTAN CON EL MISMO PID !!! 	
es PORQUE es EL PID DEL UML-KERNEL 

[ 5779.817420] DEBUG 5834:dvk_open:167:
[ 5841.790515] DEBUG 5834:dvk_open:167: 
[ 5875.286673] DEBUG 5834:dvk_open:167: 

DEBUG 1:uml_dvk_init_module:149: UML-kernel PID=292  UML-kernel TID=292 <<<< ESTOS SON LO VPID Y VTID 

root@node0:/usr/src/dvs/dvk-proxies/test# more /proc/cpuinfo
processor       : 0
vendor_id       : User Mode Linux
model name      : UML
mode            : skas <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
host            : Linux node0 4.9.88 #13 SMP Sat Apr 13 02:07:32 -03 2019 i686
bogomips        : 1810.43


DEBUG EN HOST 
[29326.449835] DEBUG 9443:dvk_open:167: 
[29326.450513] DEBUG 9443:dvk_ioctl:204: cmd=8004E31B arg=491F6680
[29326.450515] DEBUG 9443:dvk_ioctl:224: DVK_CALL=27 (getdvsinfo) 
[29326.450517] DEBUG 9443:io_getdvsinfo:288: 
[29326.450519] DEBUG 9443:new_getdvsinfo:1784: local_nodeid=0 
[29326.453381] DEBUG 9443:dvk_ioctl:204: cmd=8004E30E arg=BFBA2B24
[29326.453385] DEBUG 9443:dvk_ioctl:224: DVK_CALL=14 (getdcinfo) 
[29326.453387] DEBUG 9443:io_getdcinfo:153: 
[29326.453398] DEBUG 9443:new_getdcinfo:1813: dcid=0 
[29326.453401] DEBUG 9443:check_caller:536: caller_pid=9443 caller_tgid=9443
[29326.453403] ERROR: 9443:check_caller:570: rcode=-310
[29326.453405] DEBUG 9443:new_getdcinfo:1831: RLOCK_DC dc=0 count=0
[29326.453407] DEBUG 9443:new_getdcinfo:1833: RUNLOCK_DC dc=0 count=0
[29326.470500] DVK: exit_unbind local_nodeid:0

DEBUG EN UMLoot@node0:/usr/src/dvs/dvk-proxies/test# dmesg -c                                                    
[  401.060000] DEBUG 657:uml_dvk_open:95: dvk_dev=/dev/dvk
[  401.060000] DEBUG 657:uml_dvk_open:103: rcode=23
[  401.060000] DEBUG 657:uml_dvk_ioctl:65: cmd=8004E31B arg=BFBA2B68
[  401.060000] DEBUG 657:uml_dvk_ioctl:82: rcode=0
[  401.060000] DEBUG 657:uml_dvk_ioctl:65: cmd=8004E30E arg=BFBA2B24
[  401.060000] DEBUG 657:uml_dvk_ioctl:82: rcode=0
[  401.080000] DEBUG 657:uml_dvk_release:116: dvk_dev=/dev/dv


DEBUG EN CLIENT UML 
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 10
DEBUG 657:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 657:uml_dvk_open:95: dvk_dev=/dev/dvk
DEBUG 657:uml_dvk_open:103: rcode=23
DEBUG 657:dvk_getdvsinfo:120: 
DEBUG 657:uml_dvk_ioctl:65: cmd=8004E31B arg=BFBA2B68
DEBUG 657:uml_dvk_ioctl:82: rcode=0
DEBUG 657:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
DEBUG 657:dvk_getdcinfo:170: dcid=0
DEBUG 657:uml_dvk_ioctl:65: cmd=8004E30E arg=BFBA2B24
DEBUG 657:uml_dvk_ioctl:82: rcode=0
DEBUG 657:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 657:uml_dvk_release:116: dvk_dev=/dev/dvk

------------------- SIN ARRANCAR EL NAMESPACE ----------------------
root@node0:/usr/src/dvs/vos/uml/uml1# ./linux-dvk-uml con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/
sdb6   mem=1024M clear

DEBUG 1:uml_dvk_init_module:144: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
DEBUG 1:uml_dvk_init_module:149: UML-kernel PID=10018  UML-kernel TID=10018

DEBUG DEL PROCESO 
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 10                             
DEBUG 647:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 647:uml_dvk_open:95: dvk_dev=/dev/dvk
DEBUG 647:uml_dvk_open:103: rcode=19
DEBUG 647:dvk_getdvsinfo:120: 
DEBUG 647:uml_dvk_ioctl:65: cmd=8004E31B arg=BF9E8B68
DEBUG 647:uml_dvk_ioctl:82: rcode=0
DEBUG 647:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
DEBUG 647:dvk_getdcinfo:170: dcid=0
DEBUG 647:uml_dvk_ioctl:65: cmd=8004E30E arg=BF9E8B24
DEBUG 647:uml_dvk_ioctl:82: rcode=0
DEBUG 647:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 647:uml_dvk_release:116: dvk_dev=/dev/dvk


DEBUG DE UML#
[  121.950000] DEBUG 647:uml_dvk_open:95: dvk_dev=/dev/dvk
[  121.950000] DEBUG 647:uml_dvk_open:103: rcode=19
[  121.950000] DEBUG 647:uml_dvk_ioctl:65: cmd=8004E31B arg=BF9E8B68
[  121.950000] DEBUG 647:uml_dvk_ioctl:82: rcode=0
[  121.950000] DEBUG 647:uml_dvk_ioctl:65: cmd=8004E30E arg=BF9E8B24
[  121.950000] DEBUG 647:uml_dvk_ioctl:82: rcode=0
[  121.950000] DEBUG 647:uml_dvk_release:116: dvk_dev=/dev/dvk

DEBUG EN EL HOST 
[29697.762381] DEBUG 10018:dvk_open:167: 
[29697.763292] DEBUG 10018:dvk_ioctl:204: cmd=8004E31B arg=4920DAC0
[29697.763294] DEBUG 10018:dvk_ioctl:224: DVK_CALL=27 (getdvsinfo) 
[29697.763296] DEBUG 10018:io_getdvsinfo:288: 
[29697.763298] DEBUG 10018:new_getdvsinfo:1784: local_nodeid=0 
[29697.766098] DEBUG 10018:dvk_ioctl:204: cmd=8004E30E arg=BF9E8B24
[29697.766101] DEBUG 10018:dvk_ioctl:224: DVK_CALL=14 (getdcinfo) 
[29697.766102] DEBUG 10018:io_getdcinfo:153: 
[29697.766123] DEBUG 10018:new_getdcinfo:1813: dcid=0 
[29697.766126] DEBUG 10018:check_caller:536: caller_pid=10018 caller_tgid=10018
[29697.766128] ERROR: 10018:check_caller:570: rcode=-310
[29697.766130] DEBUG 10018:new_getdcinfo:1831: RLOCK_DC dc=0 count=0
[29697.766140] DEBUG 10018:new_getdcinfo:1833: RUNLOCK_DC dc=0 count=0
[29697.767270] DVK: exit_unbind local_nodeid:0

ESTO DEMUESTRA QUE EL QUE HACE LA PETICION ES EL UML-KERNEL (10018)



==============================================================================================

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

CAMBIO DE ESTRATEGIA!!

UML solo maneja 2 procesos UML-USER y UML-KERNEL con Address spaces separados.

Esto solo permitirá manejar 2 endpoints!!!  
		UML-USER y UML-KERNEL 
	
	En UML-USER podemos poner un WEBSERVER
	En UML-KERNEL podemos poner un driver del RDISK 
		
Utiliza SKAS0, por lo que hay codigo en el tope del proceso UML-USER 
Aqui hay:
	1- Hacer el open del FD del DVK (fd_dvk) para guardarlo en una variable global.
	2- Detectar cuando se hace una invocacion a ioctl()
		En este caso ver si el (fd == fd_dvk)
		y en este caso se cambia por un os_ioctl_generic(fd_dvk, cmd,  data)

PROBLEMAS:
          Cuando el UML-USER hace una dvk_call() sin llamar a UML-KERNEL y queda bloqueado entonces TODO UML-USER queda bloqueado !!!! 

POSIBLE SOLUCION:
          Crear un thread que se encargue de las operaciones de DVK.
Ver como hace ubd que crea un thread
      CLONE_VM (since Linux 2.0)If CLONE_VM is set, the calling process and the child process run in the same memory space.
int start_io_thread(unsigned long sp, int *fd_out)
pid = clone(io_thread, (void *) sp, CLONE_FILES | CLONE_VM, NULL);


PREGUNTA: Puede caber todo este codigo en el extremo SKAS se UML_USER ??

struct cpu_task {
	int pid;
	void *task;
};


SE PODRIA ASOCIAR UN THREAD EN EL UML-KERNEL A CADA PROCESO UML-PID 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- El problema aparente esta en las direcciones de memoria de los procesos UML.

1- Verificar que cada proceso UML es un proceso HOST.
2- Imprimir gettid y getpid para ver que usan 
3- en la funcion uml_dvk_ioctl de um_dvk.c se deberían discriminar las llamadas al DVK según el tipo de parametro.
		Si es de entrada o salida
		Si es de un entero o una estructura de datos 
		Cantidad de parametros 
		
4- Como convertir las direcciones virtuales UML a virtuales de HOST ???
virt_to_phys()

HACER: 
UML# more /proc/cpuinfo
processor : 0
vendor_id : User Mode Linux
model name : UML
mode : skas <<<<<<<<<<<<<<<<<< Separeted Kernel Address Space 
host : Linux tp.

In skas mode, this is not the case. The UML kernel runs entirely
within a single process, using longjmp to switch between kernel
stacks on context switches. gdb

CONFIRMADO se usa mode SKAS 
In contrast, in skas3 mode, the UML kernel resides
entirely in a different host address space.

Cuando un proceso UML_user hace un SysCall está cambiando de proceso porque pasa
al Adress Space del UML_kernel

PROBLEMON!!!!!
Quiere decir que el que en realidad hace las ioctl() de DVK es el kernel!!! 

APARENTEMENTE, EL MODO DE USO ES SKAS0 DONDE EN EL TOPE HAY UN STUB 
              PIDb      PIDa 
           ---------  ---------  
		   ! STUB  !  ! 	  !
		   ! SKAS  !  !       !
           ---------  !       !  
		   !       !  !  UML  !
		   !       !  ! KERNEL!
		   !  USER !  !       !
		   !  PROCS!  !       !
		   !       !  !       !
		   !       !  !       !
		   !       !  !       !
           ---------  ---------
		   
PREGUNTA: Como hacer  para saber el PID/TID del proceso de usuario??

/arch/um/kernel/skas/process.c
static int __init start_kernel_proc(void *unused)
{
	int pid;

	block_signals();
	pid = os_getpid(); <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< PONER UN DEBUG 

	cpu_tasks[0].pid = pid;
	cpu_tasks[0].task = current;

	start_kernel();
	return 0;
}

void __switch_mm(struct mm_id *mm_idp)
{
	userspace_pid[0] = mm_idp->u.pid;
}

En 
int start_userspace(unsigned long stub_stack)
esta el PID del userspace 

	pid = clone(userspace_tramp, (void *) sp, flags, (void *) stub_stack);
	if (pid < 0) {
		err = -errno;
		printk(UM_KERN_ERR "start_userspace : clone failed, "
		       "errno = %d\n", errno);
		return err;
	}


/arch/um/os-Linux/skas/process.c
static void handle_trap(int pid, struct uml_pt_regs *regs,
			int local_using_sysemu)
Que invoca a handle_syscall(regs);
			
/arch/um/kernel/skas/syscall.c
Aqui maneja los syscalls

En la estructura 
struct uml_pt_regs {
	unsigned long gp[MAX_REG_NR];
	unsigned long fp[MAX_FP_NR];
	struct faultinfo faultinfo;
	long syscall; <<<<<<<<<<<<<<<<<<<<< SYSCALL 
	int is_user;
};


#define NR_CPUS 1
int userspace_pid[NR_CPUS]; <<<<<<<<<<<<<<<<<<<< USER SPACE PID 

/arch/um/kernel/process.c
static inline int external_pid(void)
{
	/* FIXME: Need to look up userspace_pid by cpu */
	return userspace_pid[0];
}


TENER EN CUENTA
I start uml with the following command line:
linux root=/dev/ubda ubd0=/umls/uml1.rootfs ubd1=/umls/uml1.swapfs mem=128M
con=pty con0=fd:0,fd:1 eth0=tuntap,tap0,,192.168.1.1 umid=uml1

Se compilo el 


 ./linux-dvk-uml con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6   mem=1024M 

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					RESUMEN DE ESTRATEGIA
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

UML-USER es un proceso y UML-KERNEL es un proceso.
UML-USER no es facilmente modificable porque hay que modificar el stub SKAS
Estrategia:  Crear un driver DVK que crea un thread por cada UML-Process 
Para ello:
		Se necesita relacionar el hilo de UML-Kernel con el UML-PID del UML-USER
		Como son espacios de direcciones diferentes, averiguar si UML-KERNEL
		utiliza memory map del UML-USER. De esa forma se dispone en UML-KERNEL
		de las direcciones de memoria de UML-USER y se pueden hacer transferencias
		de mensajes y datos entre  DVK<->UML-KERNEL (mapeado en UML-USER)
		Se requiere tambien disponer del UML-PID para relacionarlo al DVK-thread
		Se requiere saber como se pone en marcha o al menos en LISTO un UML-process 
		despues del que el DVK-Thread ha terminado con su tarea.
		external_pid(): retorna el pid de UML-USER 
		
fd = phys_mapping(to_phys(__syscall_stub_start), &offset);

 * The memory mapped memory of the temporary file is used as backing memory
 * of all user space processes/kernel tasks.
 */
void __init setup_physmem(unsigned long start, unsigned long reserve_end,
			  unsigned long len, unsigned long long highmem)
			--->  os_map_memory()
						----> 	loc = mmap64((void *) virt, len, prot, MAP_SHARED | MAP_FIXED,
		     fd, off);
lo importante aqui es que es MAP_SHARED !!!!!


Deberia hacer un driver y un proceso de usuario de prueba.

Proceso de usuario 
	- imprime su PID (UML-PID)
	- Toma una direccion de memoria de una variable donde almacena 0x12345678
	- Imprime la direccion 
	- Imprime el contenido
	- invoca ioctl() al driver 
	- El driver imprime el PID del proceso, la direccion de memoria y el contenido 
	
kernel process: Map a tmpfs region for each userspace process with 
read/write.
userspace process: Map the same tmpfs for the current process and 
userfaultfd the whole address space, and give the userfaultfd fd to the 
kernel somehow and process the page fault there and fill/copy the 
faulted page accordingly.

**
 * setup_physmem() - Setup physical memory for UML
 * @start:	Start address of the physical kernel memory,
 *		i.e start address of the executable image.
 * @reserve_end:	end address of the physical kernel memory.
 * @len:	Length of total physical memory that should be mapped/made
 *		available, in bytes.
 * @highmem:	Number of highmem bytes that should be mapped/made available.
 *
 * Creates an unlinked temporary file of size (len + highmem) and memory maps
 * it on the last executable image address (uml_reserved).
 *
 * The offset is needed as the length of the total physical memory
 * (len + highmem) includes the size of the memory used be the executable image,
 * but the mapped-to address is the last address of the executable image
 * (uml_reserved == end address of executable image).
 *
 * The memory mapped memory of the temporary file is used as backing memory
 * of all user space processes/kernel tasks.
 */
 
 
 
 Segun entiendo, desplaza el puntero del archivo hasta __syscall_stub_start
 y alli copy una pagina completa que contiene la gestion de syscall 
 
 	/*
	 * Special kludge - This page will be mapped in to userspace processes
	 * from physmem_fd, so it needs to be written out there.
	 */
	os_seek_file(physmem_fd, __pa(__syscall_stub_start));
	os_write_file(physmem_fd, __syscall_stub_start, PAGE_SIZE);
	os_fsync_file(physmem_fd);
	

arch/um/kernel/skas/mmu.c	
	pages[0] = virt_to_page(&__syscall_stub_start);
	pages[1] = virt_to_page(mm->context.id.stack);
	
	
	
 setup_physmem invoca a
	 create_mem_file
	  os_map_memory invoca a 
			loc = mmap64((void *) virt, len, prot, MAP_SHARED | MAP_FIXED, <<<<< SHARED 
		     fd, off);
O sea, esto pareceria ser el mapeo de TODA la memoria en el archivo 


void new_thread_handler(void)
	userspace(&current->thread.regs.regs);
		void userspace(struct uml_pt_regs *regs) 
			da trataiento a los SIGNALS de modo usuario y aparentemente esta en el SKAS
			

"umid=<name>\n"
"    This is used to assign a unique identity to this UML machine and\n"
"    is used for naming the pid file and management console socket


copy_thread(unsign
	handler = fork_handler;
	new_thread(task_stack_page(p), &p->thread.switch_buf, handler);
			

struct mm_id {
	union {
		int mm_fd;
		int pid;
	} u;
	unsigned long stack;
};


static inline long do_syscall_stub(struct mm_id * mm_idp, void **addr)
Se supone que el PID que aparece aqui es el UML-PID

err = ptrace(PTRACE_CONT, pid, 0, 0);
       PTRACE_CONT
              Restart the stopped tracee process.  If data is nonzero, it is
              interpreted as the number of a signal to be delivered to the
              tracee; otherwise, no signal is delivered.  Thus, for example,
              the tracer can control whether a signal sent to the tracee is
              delivered or not.  (addr is ignored.)
			  

UML needs this (one mapping for the "physical" memory area, zero or more
mappings into the kernel VM area, and zero or more mappings into process
address spaces).

The reason it won't work is that each thread is in a different address space, 
so the context switching code needs to know what it should map in to each 
process that runs.  So, somehow you need to keep track of the fact that one 
thread mmapped something in, and have the low-level context switcher mmap it 
in to each new thread that runs.


===============================================================================
20190511:
		Pruebas para determinar como trabaja la memoria y los PIDs.
		
root@node0:/usr/src/linux#  ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6   mem=1024M 
		


		
======================================= EN HOST =======================================

		
root@node0:/usr/src/dvs/dvk-tests# ps -ef | grep linux
root       354     1  0 17:14 tty1     00:00:00 /sbin/agetty --noclear tty1 linux
root     17272   551  5 18:45 pts/0    00:00:09 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     17277 17272  0 18:45 pts/0    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     17278 17272  8 18:45 pts/0    00:00:12 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     17279 17272  0 18:45 pts/0    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     17282 17272  0 18:45 pts/0    00:00:01 [linux]
root     17303 17272  0 18:46 pts/0    00:00:00 [linux]
root     17332 17272  0 18:46 pts/0    00:00:00 [linux]
root     17355 17272  0 18:46 pts/0    00:00:00 [linux]
root     17363 17272  0 18:46 pts/0    00:00:00 [linux]
root     17422 17272  0 18:46 pts/0    00:00:00 [linux]
root     17424 17272  0 18:46 pts/0    00:00:00 [linux]
root     17425 17272  0 18:46 pts/0    00:00:00 [linux]
root     17426 17272  0 18:46 pts/0    00:00:00 [linux]
root     17427 17272  0 18:46 pts/0    00:00:00 [linux]
root     17451 17272  0 18:47 pts/0    00:00:00 [linux]
root     17462 17272  0 18:47 pts/0    00:00:00 [linux]

  
 
 PRIMERA EJECUCION 
[ 5802.322100] DEBUG 17272:dvk_open:167: 
[ 5802.324160] DEBUG 17272:dvk_ioctl:201: cmd=4004E309 arg=488C9CD0
[ 5802.324164] DEBUG 17272:dvk_ioctl:221: DVK_CALL=9 (bind) 
[ 5802.324166] DEBUG 17272:io_bind:97: 
[ 5802.324170] DEBUG 17272:new_bind:1372: oper=0 dcid=0 param_pid=-1 endpoint=-2 nodeid=-1
[ 5802.324172] DEBUG 17272:new_bind:1394: RLOCK_DC dc=0 count=0
[ 5802.324174] DEBUG 17272:new_bind:1407: WLOCK_PROC ep=-2 count=0
[ 5802.324176] DEBUG 17272:init_proc_desc:16: p_name=$noname dcid=0
[ 5802.324180] DEBUG 17272:new_bind:1441: param_pid=-1 lpid=17272 vpid=17272 tid=17272
[ 5802.324181] DEBUG 17272:new_bind:1465: SELF_BIND param_pid=-1 lpid=17272 vpid=17272 tid=17272
[ 5802.324183] DEBUG 17272:new_bind:1487: WUNLOCK_PROC ep=-2 count=0
[ 5802.324184] DEBUG 17272:new_bind:1490: WLOCK_TASK pid=17272 count=0
[ 5802.324185] DEBUG 17272:new_bind:1491: WLOCK_PROC ep=-2 count=0
[ 5802.324254] DEBUG 17272:new_bind:1527: increment the reference count of the task struct=17272 count=2
[ 5802.324255] DEBUG 17272:new_bind:1538: process p_name=linux *p_name_ptr=linux
[ 5802.324258] DEBUG 17272:new_bind:1595: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=17272 vpid=17272 nodeid=0 name=linux 
[ 5802.324261] DEBUG 17272:new_bind:1596: nr=-2 endp=-2 dcid=0 lpid=17272 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[ 5802.324262] DEBUG 17272:new_bind:1610: WUNLOCK_TASK pid=17272 count=0
[ 5802.324263] DEBUG 17272:new_bind:1616: WUNLOCK_PROC ep=-2 count=0
[ 5802.324264] DEBUG 17272:new_bind:1618: DC_INCREF counter=1
[ 5802.324266] DEBUG 17272:new_bind:1619: RUNLOCK_DC dc=0 count=0
[ 5802.324267] ERROR: 17272:dvk_ioctl:225: rcode=-2
[ 5802.325070] DEBUG 17272:dvk_ioctl:201: cmd=8004E31B arg=B786AB68
[ 5802.325072] DEBUG 17272:dvk_ioctl:221: DVK_CALL=27 (getdvsinfo) 
[ 5802.325116] DEBUG 17272:io_getdvsinfo:288: 
[ 5802.325118] DEBUG 17272:new_getdvsinfo:1789: local_nodeid=0 
[ 5802.328238] DEBUG 17272:dvk_ioctl:201: cmd=8004E30E arg=BF8B2B24
[ 5802.328241] DEBUG 17272:dvk_ioctl:221: DVK_CALL=14 (getdcinfo) 
[ 5802.328243] DEBUG 17272:io_getdcinfo:153: 
[ 5802.328264] DEBUG 17272:new_getdcinfo:1818: dcid=0 
[ 5802.371135] DEBUG 17272:check_caller:536: caller_pid=17272 caller_tgid=17272
[ 5802.372608] DEBUG 17272:check_caller:572: WLOCK_PROC ep=-2 count=0
[ 5802.372611] DEBUG 17272:check_caller:601: WUNLOCK_PROC ep=-2 count=0
[ 5802.372613] DEBUG 17272:check_caller:604: dcid=0
[ 5802.372615] DEBUG 17272:check_caller:608: RLOCK_DC dc=0 count=0
[ 5802.372616] DEBUG 17272:check_caller:612: RUNLOCK_DC dc=0 count=0
[ 5802.372618] DEBUG 17272:check_caller:618: caller_pid=17272 
[ 5802.372620] DEBUG 17272:new_getdcinfo:1836: RLOCK_DC dc=0 count=0
[ 5802.372633] DEBUG 17272:new_getdcinfo:1838: RUNLOCK_DC dc=0 count=0

HIZO EL BIND!!! 
root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 17272/17272  0    0   20 27342 27342 27342 27342 linux
 
SEGUNDA EJECUCION !!! 
[ 6293.012942] DEBUG 17272:dvk_open:167: 
[ 6293.015110] DEBUG 17272:dvk_ioctl:201: cmd=4004E309 arg=490E7CD0
[ 6293.015113] DEBUG 17272:dvk_ioctl:221: DVK_CALL=9 (bind) 
[ 6293.015115] DEBUG 17272:io_bind:97: 
[ 6293.015119] DEBUG 17272:new_bind:1372: oper=0 dcid=0 param_pid=-1 endpoint=-2 nodeid=-1
[ 6293.015121] DEBUG 17272:new_bind:1394: RLOCK_DC dc=0 count=0
[ 6293.015123] DEBUG 17272:new_bind:1407: WLOCK_PROC ep=-2 count=0
[ 6293.015127] DEBUG 17272:new_bind:1411: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=17272 vpid=17272 nodeid=0 name=linux 
[ 6293.015128] DEBUG 17272:new_bind:1412: WUNLOCK_PROC ep=-2 count=0
[ 6293.015129] DEBUG 17272:new_bind:1413: RUNLOCK_DC dc=0 count=0
[ 6293.015131] ERROR: 17272:new_bind:1413: rcode=-337
[ 6293.015132] ERROR: 17272:dvk_ioctl:225: rcode=-337
[ 6293.016587] DEBUG 17272:dvk_ioctl:201: cmd=8004E31B arg=B7B06B68
[ 6293.016590] DEBUG 17272:dvk_ioctl:221: DVK_CALL=27 (getdvsinfo) 
[ 6293.016592] DEBUG 17272:io_getdvsinfo:288: 
[ 6293.016593] DEBUG 17272:new_getdvsinfo:1789: local_nodeid=0 
[ 6293.070556] DEBUG 17272:dvk_ioctl:201: cmd=8004E30E arg=BFB4EB24
[ 6293.070560] DEBUG 17272:dvk_ioctl:221: DVK_CALL=14 (getdcinfo) 
[ 6293.070561] DEBUG 17272:io_getdcinfo:153: 
[ 6293.070583] DEBUG 17272:new_getdcinfo:1818: dcid=0 
[ 6293.070587] DEBUG 17272:check_caller:536: caller_pid=17272 caller_tgid=17272
[ 6293.070589] DEBUG 17272:check_caller:572: WLOCK_PROC ep=-2 count=0
[ 6293.070591] DEBUG 17272:check_caller:601: WUNLOCK_PROC ep=-2 count=0
[ 6293.070592] DEBUG 17272:check_caller:604: dcid=0
[ 6293.070594] DEBUG 17272:check_caller:608: RLOCK_DC dc=0 count=0
[ 6293.070595] DEBUG 17272:check_caller:612: RUNLOCK_DC dc=0 count=0
[ 6293.070596] DEBUG 17272:check_caller:618: caller_pid=17272 
[ 6293.070598] DEBUG 17272:new_getdcinfo:1836: RLOCK_DC dc=0 count=0
[ 6293.070600] DEBUG 17272:new_getdcinfo:1838: RUNLOCK_DC dc=0 count=0
 
 ======================================= EN UML =====================================

DMESG UML PREVIO 
root@node0:/usr/src/dvs/dvk-proxies/test# dmesg | grep dvk
[    0.100000] UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
[    0.100000] DEBUG 1:uml_dvk_init_module:200: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
[    0.100000] DEBUG 1:uml_dvk_init_module:205: UML-kernel PID=17272  UML-kernel TID=17272

PRIMERA EJECUCION
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 11
DEBUG 677:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 677:uml_dvk_open:146: dvk_dev=/dev/dvk
DEBUG 677:uml_dvk_open:154: dvk_fd=19
DEBUG 677:uml_bind_X:64: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 677:uml_bind_X:72: os_ioctl_generic ret=-2
DEBUG 677:uml_dvk_open:165: dvk_bind ep=-2
DEBUG 677:dvk_getdvsinfo:120: 
DEBUG 677:uml_dvk_ioctl:113: uml_pid=17498 cmd=8004E31B arg=BF8B2B68
DEBUG 677:uml_dvk_ioctl:120: uml_pid=17498 dvsu_ptr=B786AB68 arg=BF8B2B68
DEBUG 677:uml_dvk_ioctl:132: rcode=0
DEBUG 677:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=0 d_nr_nodes=0 d_nr_procs=0 d_nr_tasks=0 d_nr_sysprocs=0 
DEBUG 677:dvk_getdcinfo:170: dcid=0
DEBUG 677:uml_dvk_ioctl:113: uml_pid=17498 cmd=8004E30E arg=BF8B2B24
DEBUG 677:uml_dvk_ioctl:132: rcode=0
DEBUG 677:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 677:uml_dvk_release:172: dvk_dev=/dev/dvk

DMESG UML LUEGO DE EJECUTAR 
[  204.670000] DEBUG 677:uml_dvk_open:146: dvk_dev=/dev/dvk
[  204.670000] DEBUG 677:uml_dvk_open:154: dvk_fd=19
[  204.670000] DEBUG 677:uml_bind_X:64: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
[  204.670000] DEBUG 677:uml_bind_X:72: os_ioctl_generic ret=-2
[  204.670000] DEBUG 677:uml_dvk_open:165: dvk_bind ep=-2
[  204.670000] DEBUG 677:uml_dvk_ioctl:113: uml_pid=17498 cmd=8004E31B arg=BF8B2B68
[  204.670000] DEBUG 677:uml_dvk_ioctl:120: uml_pid=17498 dvsu_ptr=B786AB68 arg=BF8B2B68
[  204.670000] DEBUG 677:uml_dvk_ioctl:132: rcode=0
[  204.670000] DEBUG 677:uml_dvk_ioctl:113: uml_pid=17498 cmd=8004E30E arg=BF8B2B24
[  204.720000] DEBUG 677:uml_dvk_ioctl:132: rcode=0
[  204.730000] DEBUG 677:uml_dvk_release:172: dvk_dev=/dev/dvk


SEGUNDA EJECUCION 
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 12
DEBUG 679:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 679:uml_dvk_open:146: dvk_dev=/dev/dvk
DEBUG 679:uml_dvk_open:154: dvk_fd=19
DEBUG 679:uml_bind_X:64: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 679:uml_bind_X:72: os_ioctl_generic ret=-337
DEBUG 679:uml_dvk_open:165: dvk_bind ep=-337
DEBUG 679:dvk_getdvsinfo:120: 
DEBUG 679:uml_dvk_ioctl:113: uml_pid=17507 cmd=8004E31B arg=BFB4EB68
DEBUG 679:uml_dvk_ioctl:120: uml_pid=17507 dvsu_ptr=B7B06B68 arg=BFB4EB68
DEBUG 679:uml_dvk_ioctl:132: rcode=0
DEBUG 679:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=0 d_nr_nodes=0 d_nr_procs=0 d_nr_tasks=0 d_nr_sysprocs=0 
DEBUG 679:dvk_getdcinfo:170: dcid=0
DEBUG 679:uml_dvk_ioctl:113: uml_pid=17507 cmd=8004E30E arg=BFB4EB24
DEBUG 679:uml_dvk_ioctl:132: rcode=0
DEBUG 679:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 679:uml_dvk_release:172: dvk_dev=/dev/dvk

[  695.810000] DEBUG 679:uml_dvk_open:146: dvk_dev=/dev/dvk
[  695.810000] DEBUG 679:uml_dvk_open:154: dvk_fd=19
[  695.810000] DEBUG 679:uml_bind_X:64: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
[  695.810000] DEBUG 679:uml_bind_X:72: os_ioctl_generic ret=-337
[  695.810000] DEBUG 679:uml_dvk_open:165: dvk_bind ep=-337
[  695.810000] DEBUG 679:uml_dvk_ioctl:113: uml_pid=17507 cmd=8004E31B arg=BFB4EB68
[  695.810000] DEBUG 679:uml_dvk_ioctl:120: uml_pid=17507 dvsu_ptr=B7B06B68 arg=BFB4EB68
[  695.810000] DEBUG 679:uml_dvk_ioctl:132: rcode=0
[  695.860000] DEBUG 679:uml_dvk_ioctl:113: uml_pid=17507 cmd=8004E30E arg=BFB4EB24
[  695.870000] DEBUG 679:uml_dvk_ioctl:132: rcode=0
[  695.960000] DEBUG 679:uml_dvk_release:172: dvk_dev=/dev/dvk


ATENCION:
uml_pid = userspace_pid[0]; 
Aparentemente el PID no es de UML, es del HOST.

Se modifico
	int uml_pid = get_current_pid();

================================== SEGUNDO SET DE PRUEBAS ================================

EN EL HOST 
root@node0:/usr/src/dvs/dvk-tests# ps -ef | grep linux
root       354     1  0 17:14 tty1     00:00:00 /sbin/agetty --noclear tty1 linux
root     20142 17587 10 19:31 pts/2    00:00:02 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     20147 20142  0 19:31 pts/2    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     20148 20142  5 19:31 pts/2    00:00:01 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     20149 20142  0 19:31 pts/2    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root     20152 20142  1 19:31 pts/2    00:00:00 [linux]
root     20173 20142  0 19:31 pts/2    00:00:00 [linux]
root     20196 20142  0 19:31 pts/2    00:00:00 [linux]
root     20280 20142  0 19:31 pts/2    00:00:00 [linux]
root     20282 20142  0 19:31 pts/2    00:00:00 [linux]
root     20297 20142  0 19:31 pts/2    00:00:00 [linux]
root     20298 20142  0 19:31 pts/2    00:00:00 [linux]
root     20299 20142  0 19:31 pts/2    00:00:00 [linux]
root     20300 20142  0 19:31 pts/2    00:00:00 [linux]
root     20301 20142  0 19:31 pts/2    00:00:00 [linux]
root     20302 20142  0 19:31 pts/2    00:00:00 [linux]
root     20307 17434  0 19:31 pts/1    00:00:00 grep linux

EN UML 

root@node0:/usr/src/dvs/dvk-proxies/test# mknod /dev/dvk c 33 0
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 13                                         
DEBUG 676:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 676:uml_dvk_open:149: dvk_dev=/dev/dvk
DEBUG 676:uml_dvk_open:157: dvk_fd=19
DEBUG 676:uml_bind_X:66: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 676:uml_bind_X:74: os_ioctl_generic ret=-2
DEBUG 676:uml_dvk_open:168: dvk_bind ep=-2
DEBUG 676:dvk_getdvsinfo:120: 
DEBUG 676:uml_dvk_ioctl:116: uml_pid=676 cmd=8004E31B arg=BF981B68
DEBUG 676:uml_dvk_ioctl:123: uml_pid=676 dvsu_ptr=B7939B68 arg=BF981B68
DEBUG 676:uml_dvk_ioctl:135: rcode=0
DEBUG 676:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=0 d_nr_nodes=0 d_nr_procs=0 d_nr_tasks=0 d_nr_sysprocs=0 
DEBUG 676:dvk_getdcinfo:170: dcid=0
DEBUG 676:uml_dvk_ioctl:116: uml_pid=676 cmd=8004E30E arg=BF981B24 
DEBUG 676:uml_dvk_ioctl:135: rcode=0
DEBUG 676:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 676:uml_dvk_release:175: dvk_dev=/dev/dvk

[  150.200000] DEBUG 676:uml_dvk_open:149: dvk_dev=/dev/dvk
[  150.210000] DEBUG 676:uml_dvk_open:157: dvk_fd=19
[  150.210000] DEBUG 676:uml_bind_X:66: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
[  150.210000] DEBUG 676:uml_bind_X:74: os_ioctl_generic ret=-2
[  150.210000] DEBUG 676:uml_dvk_open:168: dvk_bind ep=-2
[  150.210000] DEBUG 676:uml_dvk_ioctl:116: uml_pid=676 cmd=8004E31B arg=BF981B68
[  150.210000] DEBUG 676:uml_dvk_ioctl:123: uml_pid=676 dvsu_ptr=B7939B68 arg=BF981B68
[  150.210000] DEBUG 676:uml_dvk_ioctl:135: rcode=0
[  150.210000] DEBUG 676:uml_dvk_ioctl:116: uml_pid=676 cmd=8004E30E arg=BF981B24
[  150.210000] DEBUG 676:uml_dvk_ioctl:135: rcode=0
[  150.210000] DEBUG 676:uml_dvk_release:175: dvk_dev=/dev/dvk


EN EL HOST 
root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 20142/20142  0    0   20 27342 27342 27342 27342 linux 
 
  8491.974276] DEBUG 20142:dvk_open:167: 
[ 8491.974643] DEBUG 20142:dvk_ioctl:201: cmd=4004E309 arg=487D7CD0
[ 8491.974645] DEBUG 20142:dvk_ioctl:221: DVK_CALL=9 (bind) 
[ 8491.974647] DEBUG 20142:io_bind:97: 
[ 8491.974651] DEBUG 20142:new_bind:1372: oper=0 dcid=0 param_pid=-1 endpoint=-2 nodeid=-1
[ 8491.974653] DEBUG 20142:new_bind:1394: RLOCK_DC dc=0 count=0
[ 8491.974655] DEBUG 20142:new_bind:1407: WLOCK_PROC ep=-2 count=0
[ 8491.974657] DEBUG 20142:init_proc_desc:16: p_name=$noname dcid=0
[ 8491.974660] DEBUG 20142:new_bind:1441: param_pid=-1 lpid=20142 vpid=20142 tid=20142
[ 8491.974662] DEBUG 20142:new_bind:1465: SELF_BIND param_pid=-1 lpid=20142 vpid=20142 tid=20142
[ 8491.974663] DEBUG 20142:new_bind:1487: WUNLOCK_PROC ep=-2 count=0
[ 8491.974665] DEBUG 20142:new_bind:1490: WLOCK_TASK pid=20142 count=0
[ 8491.974666] DEBUG 20142:new_bind:1491: WLOCK_PROC ep=-2 count=0
[ 8491.974668] DEBUG 20142:new_bind:1527: increment the reference count of the task struct=20142 count=2
[ 8491.974669] DEBUG 20142:new_bind:1538: process p_name=linux *p_name_ptr=linux
[ 8491.974672] DEBUG 20142:new_bind:1595: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=20142 vpid=20142 nodeid=0 name=linux 
[ 8491.974674] DEBUG 20142:new_bind:1596: nr=-2 endp=-2 dcid=0 lpid=20142 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[ 8491.974676] DEBUG 20142:new_bind:1610: WUNLOCK_TASK pid=20142 count=0
[ 8491.974677] DEBUG 20142:new_bind:1616: WUNLOCK_PROC ep=-2 count=0
[ 8491.974678] DEBUG 20142:new_bind:1618: DC_INCREF counter=1
[ 8491.974680] DEBUG 20142:new_bind:1619: RUNLOCK_DC dc=0 count=0
[ 8491.974681] ERROR: 20142:dvk_ioctl:225: rcode=-2
[ 8491.975420] DEBUG 20142:dvk_ioctl:201: cmd=8004E31B arg=B7939B68
[ 8491.975422] DEBUG 20142:dvk_ioctl:221: DVK_CALL=27 (getdvsinfo) 
[ 8491.975423] DEBUG 20142:io_getdvsinfo:288: 
[ 8491.975425] DEBUG 20142:new_getdvsinfo:1789: local_nodeid=0 
[ 8491.977152] DEBUG 20142:dvk_ioctl:201: cmd=8004E30E arg=BF981B24
[ 8491.977154] DEBUG 20142:dvk_ioctl:221: DVK_CALL=14 (getdcinfo) 
[ 8491.977156] DEBUG 20142:io_getdcinfo:153: 
[ 8491.977173] DEBUG 20142:new_getdcinfo:1818: dcid=0 
[ 8491.977176] DEBUG 20142:check_caller:536: caller_pid=20142 caller_tgid=20142
[ 8491.977178] DEBUG 20142:check_caller:572: WLOCK_PROC ep=-2 count=0
[ 8491.977179] DEBUG 20142:check_caller:601: WUNLOCK_PROC ep=-2 count=0
[ 8491.977180] DEBUG 20142:check_caller:604: dcid=0
[ 8491.977182] DEBUG 20142:check_caller:608: RLOCK_DC dc=0 count=0
[ 8491.977183] DEBUG 20142:check_caller:612: RUNLOCK_DC dc=0 count=0
[ 8491.977184] DEBUG 20142:check_caller:618: caller_pid=20142 
[ 8491.977186] DEBUG 20142:new_getdcinfo:1836: RLOCK_DC dc=0 count=0
[ 8491.977195] DEBUG 20142:new_getdcinfo:1838: RUNLOCK_DC dc=0 count=0

SEGUNDA EJECUCION 
=========================================== EN UML ==============================
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 14
DEBUG 679:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 679:uml_dvk_open:149: dvk_dev=/dev/dvk
DEBUG 679:uml_dvk_open:157: dvk_fd=19
DEBUG 679:uml_bind_X:66: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 679:uml_bind_X:74: os_ioctl_generic ret=-337
DEBUG 679:uml_dvk_open:168: dvk_bind ep=-337
DEBUG 679:dvk_getdvsinfo:120: 
DEBUG 679:uml_dvk_ioctl:116: uml_pid=679 cmd=8004E31B arg=BFC64B68
DEBUG 679:uml_dvk_ioctl:123: uml_pid=679 dvsu_ptr=B7C1CB68 arg=BFC64B68
DEBUG 679:uml_dvk_ioctl:135: rcode=0
DEBUG 679:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=0 d_nr_nodes=0 d_nr_procs=0 d_nr_tasks=0 d_nr_sysprocs=0 
DEBUG 679:dvk_getdcinfo:170: dcid=0
DEBUG 679:uml_dvk_ioctl:116: uml_pid=679 cmd=8004E30E arg=BFC64B24
DEBUG 679:uml_dvk_ioctl:135: rcode=0
DEBUG 679:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 679:uml_dvk_release:175: dvk_dev=/dev/dvk

[  370.740000] DEBUG 679:uml_dvk_open:149: dvk_dev=/dev/dvk
[  370.740000] DEBUG 679:uml_dvk_open:157: dvk_fd=19
[  370.740000] DEBUG 679:uml_bind_X:66: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
[  370.740000] DEBUG 679:uml_bind_X:74: os_ioctl_generic ret=-337
[  370.740000] DEBUG 679:uml_dvk_open:168: dvk_bind ep=-337
[  370.740000] DEBUG 679:uml_dvk_ioctl:116: uml_pid=679 cmd=8004E31B arg=BFC64B68
[  370.740000] DEBUG 679:uml_dvk_ioctl:123: uml_pid=679 dvsu_ptr=B7C1CB68 arg=BFC64B68
[  370.740000] DEBUG 679:uml_dvk_ioctl:135: rcode=0
[  370.740000] DEBUG 679:uml_dvk_ioctl:116: uml_pid=679 cmd=8004E30E arg=BFC64B24
[  370.740000] DEBUG 679:uml_dvk_ioctl:135: rcode=0
[  370.770000] DEBUG 679:uml_dvk_release:175: dvk_dev=/dev/dvk

=========================================== EN HOST ===========================

[ 8712.521935] DEBUG 20142:dvk_open:167: 
[ 8712.524454] DEBUG 20142:dvk_ioctl:201: cmd=4004E309 arg=487D7CD0
[ 8712.524458] DEBUG 20142:dvk_ioctl:221: DVK_CALL=9 (bind) 
[ 8712.524459] DEBUG 20142:io_bind:97: 
[ 8712.524464] DEBUG 20142:new_bind:1372: oper=0 dcid=0 param_pid=-1 endpoint=-2 nodeid=-1
[ 8712.524466] DEBUG 20142:new_bind:1394: RLOCK_DC dc=0 count=0
[ 8712.524468] DEBUG 20142:new_bind:1407: WLOCK_PROC ep=-2 count=0
[ 8712.524471] DEBUG 20142:new_bind:1411: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=20142 vpid=20142 nodeid=0 name=linux 
[ 8712.524472] DEBUG 20142:new_bind:1412: WUNLOCK_PROC ep=-2 count=0
[ 8712.524473] DEBUG 20142:new_bind:1413: RUNLOCK_DC dc=0 count=0
[ 8712.524475] ERROR: 20142:new_bind:1413: rcode=-337
[ 8712.524476] ERROR: 20142:dvk_ioctl:225: rcode=-337
[ 8712.525058] DEBUG 20142:dvk_ioctl:201: cmd=8004E31B arg=B7C1CB68
[ 8712.525060] DEBUG 20142:dvk_ioctl:221: DVK_CALL=27 (getdvsinfo) 
[ 8712.525061] DEBUG 20142:io_getdvsinfo:288: 
[ 8712.525063] DEBUG 20142:new_getdvsinfo:1789: local_nodeid=0 
[ 8712.525929] DEBUG 20142:dvk_ioctl:201: cmd=8004E30E arg=BFC64B24
[ 8712.525931] DEBUG 20142:dvk_ioctl:221: DVK_CALL=14 (getdcinfo) 
[ 8712.525932] DEBUG 20142:io_getdcinfo:153: 
[ 8712.525941] DEBUG 20142:new_getdcinfo:1818: dcid=0 
[ 8712.525944] DEBUG 20142:check_caller:536: caller_pid=20142 caller_tgid=20142
[ 8712.525945] DEBUG 20142:check_caller:572: WLOCK_PROC ep=-2 count=0
[ 8712.525947] DEBUG 20142:check_caller:601: WUNLOCK_PROC ep=-2 count=0
[ 8712.525948] DEBUG 20142:check_caller:604: dcid=0
[ 8712.525949] DEBUG 20142:check_caller:608: RLOCK_DC dc=0 count=0
[ 8712.525951] DEBUG 20142:check_caller:612: RUNLOCK_DC dc=0 count=0
[ 8712.525952] DEBUG 20142:check_caller:618: caller_pid=20142 
[ 8712.525954] DEBUG 20142:new_getdcinfo:1836: RLOCK_DC dc=0 count=0
[ 8712.525955] DEBUG 20142:new_getdcinfo:1838: RUNLOCK_DC dc=0 count=0


COMPROBADO EN UML !!!!!!
root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 14 &
[1] 681 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<PID EN UML

root@node0:/usr/src/dvs/dvk-proxies/test# DEBUG 681:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 681:uml_dvk_open:149: dvk_dev=/dev/dvk
DEBUG 681:uml_dvk_open:157: dvk_fd=19
DEBUG 681:uml_bind_X:66: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 681:uml_bind_X:74: os_ioctl_generic ret=-337
DEBUG 681:uml_dvk_open:168: dvk_bind ep=-337
DEBUG 681:dvk_getdvsinfo:120: 
DEBUG 681:uml_dvk_ioctl:116: uml_pid=681 cmd=8004E31B arg=BFC68B68       <<<<<<<< PID UML 
DEBUG 681:uml_dvk_ioctl:123: uml_pid=681 dvsu_ptr=B7C20B68 arg=BFC68B68
DEBUG 681:uml_dvk_ioctl:135: rcode=0
DEBUG 681:dvk_getdvsinfo:122: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=0 d_nr_nodes=0 d_nr_procs=0 d_nr_tasks=0 d_nr_sysprocs=0 
DEBUG 681:dvk_getdcinfo:170: dcid=0
DEBUG 681:uml_dvk_ioctl:116: uml_pid=681 cmd=8004E30E arg=BFC68B24
DEBUG 681:uml_dvk_ioctl:135: rcode=0
DEBUG 681:dvk_getdcinfo:174: ioctl ret=0 errno=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=0 dc_nr_tasks=0 dc_nr_sysprocs=0 dc_nr_nodes=0
 copy_server.c:main:59:flags=0 dc_nodes=0 dc_pid=1073780313 dc_name=
svr_ep must be > 0 and < 0
DEBUG 681:uml_dvk_release:175: dvk_dev=/dev/dvk
[1]+  Exit 1                  ./copy_server 0 14

=========================================================================================================
=========================================================================================================
=========================================================================================================
SE TRATA DE HACER BIND AL PROCESO UML 

	} else if ( cmd == DVK_IOCSDVKBIND){ 
		bind_ptr = to_phys(arg);
		DVKDEBUG(DBGPARAMS,"uml_pid=%d uml_vpid=%d cmd=%X arg=%X\n", uml_pid, uml_vpid, cmd, arg);
		DVKDEBUG(DBGPARAMS, "BEFORE cmd=%d dcid=%d pid=%d endpoint=%d nodeid=%d\n", 
			bind_ptr->parm_cmd, bind_ptr->parm_dcid, bind_ptr->parm_pid, bind_ptr->parm_ep, bind_ptr->parm_nodeid);
		bind_ptr->parm_cmd  = LCL_BIND;
		bind_ptr->parm_dcid = DCID0;
		bind_ptr->parm_pid  = uml_pid;
		bind_ptr->parm_nodeid   = LOCALNODE;
		DVKDEBUG(DBGPARAMS, "AFTER cmd=%d dcid=%d pid=%d endpoint=%d nodeid=%d\n", 
			bind_ptr->parm_cmd, bind_ptr->parm_dcid, bind_ptr->parm_pid, bind_ptr->parm_ep, bind_ptr->parm_nodeid);		
		rcode = os_ioctl_generic(file->private_data, cmd, dvsu_ptr);
		
		
EN UML 
root@node0:/usr/src/dvs/dvk-tests# ./test_bind  0 15 
DEBUG 674:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 674:uml_dvk_open:170: dvk_dev=/dev/dvk
DEBUG 674:uml_dvk_open:178: dvk_fd=19
DEBUG 674:uml_bind_X:76: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 674:uml_bind_X:84: os_ioctl_generic ret=-337
DEBUG 674:uml_dvk_open:188: dvk_bind ep=-337
PARENT dvk_bind Binding process 674 to DC0 with p_nr=15
DEBUG 674:dvk_bind_X:607: cmd=0 dcid=0 pid=-1 endpoint=15 nodeid=-1
DEBUG 674:uml_dvk_ioctl:126: uml_pid=28274 uml_vpid=674 cmd=4004E309 arg=BFD54CD8
DEBUG 674:uml_dvk_ioctl:141: uml_pid=28274 uml_vpid=674 cmd=4004E309 arg=BFD54CD8

EIP: 0073:[<08065bae>] CPU: 0 Not tainted ESP: 007b:49037de0
 EFLAGS: 00010216
    Not tainted
EAX: 00000051 EBX: bfd54cd8 ECX: 00000006 EDX: 0832eca8
ESI: 4004e309 EDI: b7d0ccd8 EBP: 49037e18 DS: 007b ES: 007b
Kernel panic - not syncing: Kernel tried to access user memory at addr 0xb7d0cce4, ip 0x8065bae
CPU: 0 PID: 674 Comm: test_bind Not tainted 4.9.88 #3
Stack:
 082db19e 000002a2 0827cc20 0000008d 00006e72 000002a2 4004e309 bfd54cd8
 000002a2 00006e72 48656de0 bfd54cd8 00000003 484a66d0 49037e2c 080e75fa
 484bae60 4004e309 bfd54cd8 49037ea4 080e8123 484bae60 4004e309 bfd54cd8
Call Trace:
 [<080e75fa>] vfs_ioctl+0x20/0x2c
 [<080e8123>] do_vfs_ioctl+0x59b/0x9b0
 [<080daf23>] ? vfs_write+0x111/0x14a
 [<080e8564>] SyS_ioctl+0x2c/0x49
 [<0805c577>] handle_syscall+0x6f/0x84
 [<0806a42b>] userspace+0x2d6/0x332
 [<0806d538>] ? os_set_thread_area+0x13/0x25
 [<0806c75c>] ? do_set_thread_area+0x14/0x35
 [<0806c8ae>] ? arch_switch_tls+0xc9/0xec
 [<08059fae>] fork_handler+0x56/0x5b
Abortado


NUEVA PRUEBA MODIFICANDO 
root@node0:/usr/src/dvs/dvk-tests# ./test_bind 0 15
DEBUG 672:dvk_open:47: Open dvk device file /dev/dvk
DEBUG 672:uml_dvk_open:171: dvk_dev=/dev/dvk
DEBUG 672:uml_dvk_open:179: dvk_fd=19
DEBUG 672:uml_bind_X:76: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
DEBUG 672:uml_bind_X:84: os_ioctl_generic ret=-2
DEBUG 672:uml_dvk_open:189: dvk_bind ep=-2
PARENT dvk_bind Binding process 672 to DC0 with p_nr=15
DEBUG 672:dvk_bind_X:607: cmd=0 dcid=0 pid=-1 endpoint=15 nodeid=-1
DEBUG 672:uml_dvk_ioctl:126: uml_pid=31019 uml_vpid=672 cmd=4004E309 arg=BF95CCE8
DEBUG 672:uml_dvk_ioctl:142: uml_pid=31019 uml_vpid=672 cmd=4004E309 arg=BF95CCE8
DEBUG 672:uml_dvk_ioctl:144: BEFORE cmd=0 dcid=0 pid=0 endpoint=0 nodeid=0        <<<<<<<<<<<<< ESTA TODO MAL 
DEBUG 672:uml_dvk_ioctl:150: AFTER cmd=1 dcid=0 pid=31019 endpoint=0 nodeid=-1
DEBUG 672:uml_dvk_ioctl:157: rcode=-336        <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< EDVSSLOTUSED
DEBUG 672:dvk_bind_X:616: ioctl ret=-1 errno=336
ERROR: 672:dvk_bind_X:623: rcode=-336
ERROR: test_bind.c:main:27: rcode=-336
DEBUG 672:dvk_getep:109: pid=672
DEBUG 672:uml_dvk_ioctl:126: uml_pid=31019 uml_vpid=672 cmd=8004E31A arg=2A0
DEBUG 672:uml_dvk_ioctl:157: rcode=-338 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< EDVSBADRANGE
DEBUG 672:dvk_getep:111: ioctl ret=-1 errno=338
ERROR: 672:dvk_getep:112: rcode=-338
PARENT ep=-336 dvk_getep=-338
PARENT dvk_lclbind 673 to DC0 with p_nr+index=16
DEBUG 672:dvk_bind_X:607: cmd=1 dcid=0 pid=673 endpoint=16 nodeid=-1
DEBUG 672:uml_dvk_ioctl:126: uml_pid=31019 uml_vpid=672 cmd=4004E309 arg=BF95CCE8
DEBUG 672:uml_dvk_ioctl:142: uml_pid=31019 uml_vpid=672 cmd=4004E309 arg=BF95CCE8
DEBUG 672:uml_dvk_ioctl:144: BEFORE cmd=1 dcid=0 pid=31019 endpoint=0 nodeid=-1
DEBUG 672:uml_dvk_ioctl:150: AFTER cmd=1 dcid=0 pid=31019 endpoint=0 nodeid=-1
DEBUG 672:uml_dvk_ioctl:157: rcode=-336
CHILD[1] dvk_lclbind
DEBUG 672:dvk_bind_X:616: ioctl ret=-1 errno=336
ERROR: 672:dvk_bind_X:623: rcode=-336
ERROR: test_bind.c:main:44: rcode=-336
DEBUG 672:dvk_getep:109: pid=673
DEBUG 672:uml_dvk_ioctl:126: uml_pid=31019 uml_vpid=672 cmd=8004E31A arg=2A1
DEBUG 672:uml_dvk_ioctl:157: rcode=-338
DEBUG 672:dvk_getep:111: ioctl ret=-1 errno=338
ERROR: 672:dvk_getep:112: rcode=-338
PARENT ep=-336 dvk_getep=-338
CHILD[2] dvk_replbind Binding process 674 to DC0 with p_nr=17
DEBUG 674:dvk_bind_X:607: cmd=4 dcid=0 pid=674 endpoint=17 nodeid=-1
DEBUG 674:uml_dvk_ioctl:126: uml_pid=31021 uml_vpid=674 cmd=4004E309 arg=BF95CCE8
DEBUG 674:uml_dvk_ioctl:142: uml_pid=31021 uml_vpid=674 cmd=4004E309 arg=BF95CCE8
DEBUG 674:uml_dvk_ioctl:144: BEFORE cmd=1 dcid=0 pid=31019 endpoint=0 nodeid=-1
DEBUG 674:uml_dvk_ioctl:150: AFTER cmd=1 dcid=0 pid=31021 endpoint=0 nodeid=-1
DEBUG 674:uml_dvk_ioctl:157: rcode=-336
PARENT waiting child index=2
DEBUG 674:dvk_bind_X:616: ioctl ret=-1 errno=336
ERROR: 674:dvk_bind_X:623: rcode=-336
ERROR: test_bind.c:main:53: rcode=-336
DEBUG 674:dvk_getep:109: pid=674
DEBUG 674:uml_dvk_ioctl:126: uml_pid=31021 uml_vpid=674 cmd=8004E31A arg=2A2
DEBUG 674:uml_dvk_ioctl:157: rcode=-338
DEBUG 674:dvk_getep:111: ioctl ret=-1 errno=338
ERROR: 674:dvk_getep:112: rcode=-338
CHILD[2] ep=-336 dvk_getep=-338
DEBUG 673:dvk_getep:109: pid=673
DEBUG 673:uml_dvk_ioctl:126: uml_pid=31020 uml_vpid=673 cmd=8004E31A arg=2A1
DEBUG 673:uml_dvk_ioctl:157: rcode=-338
DEBUG 673:dvk_getep:111: ioctl ret=-1 errno=338
ERROR: 673:dvk_getep:112: rcode=-338
CHILD[1] dvk_getep=-338

		
RESUMEN: NO ES LA DIRECCION DE MEMORIA CORRECTA

	SOLUCION COMPLICADA:
			Si no se encuentra la forma de localizar la direccion del proceso UML entonces se va a tener que manejar con copias
			Para ellos hay que:
				Cada proceso UML que haga BIND debera crear un hilo en el kernel que hara el bind 
				Cada IPC que haga el proceso UML sera hecha por su hilo correspondiente
				Hay que mantener una relacion proceso_UML-Thread_KERNEL_UML
				

DONDE HAY mmap()????????
kernel/syscall.c:long old_mmap(unsigned long addr, unsigned long len,
kernel/tlb.c:static int add_mmap(unsigned long virt, unsigned long phys, unsigned long len,
kernel/tlb.c:				ret = add_mmap(addr, pte_val(*pte) & PAGE_MASK,
kernel/skas/mmu.c:void arch_exit_mmap(struct mm_struct *mm)
include/asm/mmu_context.h:static inline void arch_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)
include/asm/mmu_context.h:extern void arch_exit_mmap(struct mm_struct *mm);
os-Linux/mem.c:	addr = mmap(NULL, UM_KERN_PAGE_SIZE,
os-Linux/skas/process.c:		addr = mmap((void *) STUB_DATA,
os-Linux/skas/process.c:	stack = mmap(NULL, UM_KERN_PAGE_SIZE,
drivers/mmapper_kern.c:static int mmapper_mmap(struct file *file, struct vm_area_struct *vma)

EN QUE DIRECTORIO CREA LOS ARCHIVOS TEMPORALES ???
os-Linux/skas/process.c
	static int userspace_tramp(void *stack){
		
	}


Skas effects on the host
You will notice some differences on the host. If you run ps, you 
will notice only four processes per UML rather than the dozens 
that you see in tt mode. They are 
The UML kernel thread, which runs in the separate kernel 
address space, executes kernel code, and does system call 
interception on UML processes 
•
The UML userspace thread, which runs all UML process 
code and switches between host address spaces on each 
UML context switch 
•
The ubd driver asynchronous IO thread •
The write SIGIO emulation thread  •

Quien usa clone??
drivers/ubd_user.c:     pid = clone(io_thread, (void *) sp, CLONE_FILES | CLONE_VM, NULL);
os-Linux/helper.c:      pid = clone(helper_child, (void *) sp, CLONE_VM, &data);
os-Linux/helper.c:      pid = clone(proc, (void *) sp, flags, arg);
os-Linux/skas/process.c:        pid = clone(userspace_tramp, (void *) sp, flags, (void *) stub_stack);
os-Linux/process.c: * syscalls, and also breaks with clone(), which does not unshare the TLS.


PARA CONSIDERAR!!!!!!!!!!!!!!!!!1111
En el kernel se puede obtener el task_ptr a partir el uml_vpid
Como se convierte una direccion desde la tarea al kernel ??
https://slideplayer.com/slide/13193958/79/images/28/UML+tt%2Fskas3%2Fskas0+Modes.jpg

CONFIRMADO:  SE CREA UN PROCESO EN LINUX POR CADA PROCESO EN UML-USER 
Seguramente todos comparten el mismo 

En UML
root@node0:~# read "hola" &
[1] 673
[1]+  Stopped                 read "hola"
root@node0:~# read "hola" &
[2] 675
[2]+  Stopped                 read "hola"
root@node0:~# read "hola" &
[3] 676
[3]+  Stopped                 read "hola"
root@node0:~# read "hola" &
[4] 677
root@node0:~# read "hola" &
[5] 678
[4]-  Stopped                 read "hola"
[5]+  Stopped                 read "hola"
root@node0:~# read "hola" &
[6] 679
[6]+  Stopped                 read "hola"

En HOST 
root@node0:/usr/src/linux/arch/um# ps -ef | grep linux 
root       442     1  0 20:58 tty1     00:00:00 /sbin/agetty --noclear tty1 linux
root       680   670  2 21:15 pts/1    00:00:03 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root       686   680  0 21:15 pts/1    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root       687   680  0 21:15 pts/1    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root       688   680  0 21:15 pts/1    00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M
root       690   680  0 21:15 pts/1    00:00:00 [linux]
root       712   680  0 21:15 pts/1    00:00:00 [linux]
root       732   680  0 21:15 pts/1    00:00:00 [linux]
root       817   680  0 21:15 pts/1    00:00:00 [linux]
root       818   680  0 21:15 pts/1    00:00:00 [linux]
root       833   680  0 21:15 pts/1    00:00:00 [linux]
root       834   680  0 21:15 pts/1    00:00:00 [linux]
root       835   680  0 21:15 pts/1    00:00:00 [linux]
root       836   680  0 21:15 pts/1    00:00:00 [linux]
root       837   680  0 21:15 pts/1    00:00:00 [linux]
root       847   680  0 21:16 pts/1    00:00:00 [linux] <<<< 
root       858   680  0 21:16 pts/1    00:00:00 [linux] <<<<
root       864   680  0 21:16 pts/1    00:00:00 [linux] <<<<
root       870   680  0 21:17 pts/1    00:00:00 [linux] <<<<
root       871   680  0 21:17 pts/1    00:00:00 [linux] <<<<
root       872   680  0 21:17 pts/1    00:00:00 [linux] <<<<
root       873   680  0 21:17 pts/1    00:00:00 [linux] <<<<
root       874   680  0 21:17 pts/1    00:00:00 [linux] <<<<
root       879   620  0 21:17 pts/0    00:00:00 grep linux

  PID TTY      STAT   TIME  MAJFL   TRS   DRS   RSS %MEM COMMAND
  872 pts/1    t+     0:00      0  3529 4191458 340  0.0      \_ [linux]
  873 pts/1    t+     0:00      0  3529 4191458 340  0.0      \_ [linux]
  874 pts/1    t+     0:00      0  3529 4191458 340  0.0      \_ [linux]
  893 pts/1    t+     0:00      0  3529 4191458 340  0.0      \_ [linux]
  895 pts/1    t+     0:00      0  3529 4191462 340  0.0      \_ [linux]
  897 pts/1    t+     0:00      0  3529 4191462 340  0.0      \_ [linux]



skas0 Mode
More recently, an Italian college student, Paolo Giarrusso, who had been doing good work on UML,
thought that it might be possible to implement something like skas3 on hosts without the skas3 patch.

His basic idea was to insert just enough code into the address space of each UML process to perform
the address space updates and information retrieval for which skas3 requires a host patch. 
As I implemented it over the following weekend, this inserted code takes the form of two pages 
mapped by the UML kernel at the top of each process address space. 
One of these pages is for a SIGSEGV signal frame and is mapped with write permission, 
and the other contains UML code and is mapped read-only.

The code page contains a function that invokes mmap, munmap, and mprotect as requested by the UML kernel.
The page also contains the SIGSEGV signal handler. The function is invoked whenever address space 
changes are needed in a UML process and is the equivalent of requesting an address space change 
through a /proc/mm file descriptor. 

The signal handler implements the equivalent of PTRACE_FAULTINFO by receiving the SIGSEGV signal, 
reading all of the fault information from its stack, and putting it in a convenient form where 
the UML kernel can read it.

Without changes in the host kernel, we have no way to create new host address spaces without 
creating new host processes. So, skas0 mode resembles tt mode in having one host process  <<<<<<<<<<<<<<<<<<<<<<<<<<<<
for each UML process.

This is the only similarity between skas0 mode and tt mode. In skas0 mode, the UML kernel 
runs in a separate host process and has a separate host address space from its processes. 
All of the skas3 benefits to security and performance flow from this property. 

The fact that the UML kernel is controlling many more processes than in skas3 mode 
means that we have the same wasted kernel memory that tt mode has.

This makes skas0 mode somewhat less efficient than skas3 mode but still a large improvement over tt mode.

C:\Users\Usuario\AppData\Local\Temp\scp32181\usr\src\linux\arch\um\kernel\skas\syscall.c
	void handle_syscall(struct uml_pt_regs *r)
	{
		struct pt_regs *regs = container_of(r, struct pt_regs, regs);
		int syscall;
		
		static int pid, vpid ;
			if( vpid != get_current_pid()) {
				pid = os_getpid();
				vpid = get_current_pid();
			}
	
	
		syscall = UPT_SYSCALL_NR(r);
#define SYSCALL_IOCTL	54	
	if( syscall == SYSCALL_IOCTL)
		printk("UML pid=%d vpid=%d ioctl syscall=%d\n", pid, vpid, syscall);
	

En 
/usr/src/linux/arch/x86/include/generated/asm/syscalls_32.h
esta la lista de SYSCALLS
donde 
__SYSCALL_I386(54, sys_ioctl, )

UML pid=2421 vpid=661 ioctl syscall=54
UML pid=2421 vpid=661 ioctl syscall=54
UML pid=2421 vpid=661 ioctl syscall=54
UML pid=2421 vpid=661 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
Debian GNU/Linux 9 node0 tty1
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
node0 login: UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54
UML pid=2421 vpid=660 ioctl syscall=54

Esto demuestra que el PID que ejecuta los syscalls es el PID del KERNEL

root@node0:~# cat /etc/network/interfaces
UML pid=2421 vpid=670 ioctl syscall=54             <<<<< 670 es la shell 
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=675 ioctl syscall=54 				<<<<< 675 es el cat 
# interfaces(5) file used by ifup(8) and ifdown(8)
# Include files from /etc/network/interfaces.d:
source-directory /etc/network/interfaces.d
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54
UML pid=2421 vpid=670 ioctl syscall=54

POR LO TANTO, aqui se puede ver cuando el proceso hace un IOCTL al DVK 

====================================================================================================
20190513:

			SE INCORPORO LA LECTURA DE PARAMETROS EN LA LINEA DE COMANDOS (dcid=23 uml_ep=-4 rd_ep=3)
			
			root@node0:/usr/src/linux#  ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 
		>>>>	uml_dcid: dcid=0
		>>>>	uml_ep: uml_ep=-2
		>>>>	uml_rd_ep: rd_ep=3
				Locating the bottom of the address space ... 0x0
				Locating the top of the address space ... 0xc0000000
				Core dump limits :
						soft - 0
						hard - NONE
				Checking that ptrace can change system call numbers...OK
				Checking syscall emulation patch for ptrace...OK
				Checking advanced syscall emulation patch for ptrace...OK
				Checking environment variables for a tempdir...none found
				Checking if /dev/shm is on tmpfs...OK
				Checking PROT_EXEC mmap in /dev/shm...OK
				Adding 11911168 bytes to physical memory to account for exec-shield gap
				DEBUG 0:start_kernel_proc:30: UML-kernel PID=31362  UML-kernel TID=31362
				DEBUG 0:start_kernel_proc:36: DVK device file successfully opened!! dvk_fd=3
				Linux version 4.9.88 (root@node0) (gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) ) #29 Tue May 14 00:01:20 -03 2019
				Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 262981
				Kernel command line: con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 root=98:0
				PID hash table entries: 4096 (order: 2, 16384 bytes)
				Dentry cache hash table entries: 262144 (order: 8, 1048576 bytes)
				Inode-cache hash table entries: 131072 (order: 7, 524288 bytes)
				Memory: 1035020K/1060208K available (2184K kernel code, 627K rwdata, 620K rodata, 81K init, 125K bss, 25188K reserved, 0K cma-reserved)
				NR_IRQS:15
				clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
				Calibrating delay loop... 1836.64 BogoMIPS (lpj=9183232)
				pid_max: default: 32768 minimum: 301
				Mount-cache hash table entries: 4096 (order: 2, 16384 bytes)
				Mountpoint-cache hash table entries: 4096 (order: 2, 16384 bytes)
				Checking for host processor cmov support...Yes
				Checking that host ptys support output SIGIO...Yes
				Checking that host ptys support SIGIO on close...No, enabling workaround
				devtmpfs: initialized
				Using 2.6 host AIO
				clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
				futex hash table entries: 256 (order: -1, 3072 bytes)
				NET: Registered protocol family 16
				clocksource: Switched to clocksource timer
				VFS: Disk quotas dquot_6.6.0
				VFS: Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
				NET: Registered protocol family 2
				TCP established hash table entries: 16384 (order: 4, 65536 bytes)
				TCP bind hash table entries: 16384 (order: 4, 65536 bytes)
				TCP: Hash tables configured (established 16384 bind 16384)
				UDP hash table entries: 1024 (order: 2, 16384 bytes)
				UDP-Lite hash table entries: 1024 (order: 2, 16384 bytes)
				NET: Registered protocol family 1
				console [stderr0] disabled
				mconsole (version 2) initialized on /root/.uml/wHVYj1/mconsole
				Checking host MADV_REMOVE support...OK
				UML Audio Relay (host dsp = /dev/sound/dsp, host mixer = /dev/sound/mixer)
		>>>>>   UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
		>>>>>   DEBUG 1:uml_dvk_init_module:298: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
		>>>>>	DEBUG 1:uml_dvk_init_module:303: UML-kernel PID=31362  UML-kernel TID=31362
				Host TLS support detected
				Detected host type: i386 (GDT indexes 6 to 9)
				workingset: timestamp_bits=30 max_order=18 bucket_order=0
				io scheduler noop registered
				io scheduler deadline registered (default)
				io scheduler cfq registered
				loop: module loaded
				nbd: registered device at major 43
				tun: Universal TUN/TAP device driver, 1.6
				tun: (C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>
				PPP generic driver version 2.4.2
				SLIP: version 0.8.4-NET3.019-NEWTTY (dynamic channels, max=256).
				NET: Registered protocol family 17
				Initialized stdio console driver
				Console initialized on /dev/tty0
				console [tty0] enabled
				Initializing software serial port version 1
				console [mc-1] enabled
				EXT4-fs (ubda): couldn't mount as ext3 due to feature incompatibilities
				EXT4-fs (ubda): mounting ext2 file system using the ext4 subsystem
				EXT4-fs (ubda): mounted filesystem without journal. Opts: (null)
				VFS: Mounted root (ext2 filesystem) readonly on device 98:0.
				devtmpfs: mounted
				This architecture does not have kernel memory protection.
				random: fast init done
				systemd[1]: systemd 232 running in system mode. (+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN)
				systemd[1]: Detected virtualization vmware.
				systemd[1]: Detected architecture x86.

				Welcome to Debian GNU/Linux 9 (stretch)!

				systemd[1]: Set hostname to <node0>.
				systemd[1]: Failed to enable kbrequest handling: Inappropriate ioctl for device
				systemd[1]: Created slice System Slice.
				[  OK  ] Created slice System Slice.
				systemd[1]: Reached target Slices.
				[  OK  ] Reached target Slices.
				systemd[1]: Started Dispatch Password Requests to Console Directory Watch.
				[  OK  ] Started Dispatch Password Requests to Console Directory Watch.
				systemd[1]: Set up automount Arbitrary Executable File Formats File System Automount Point.
				[  OK  ] Set up automount Arbitrary Executabâ¦rmats File System Automount Point.
				systemd[1]: dev-hugepages.mount: Couldn't determine result for ConditionVirtualization=!private-users, assuming failed: No such file or directory
				[  OK  ] Reached target Remote File Systems.
						 Mounting POSIX Message Queue File System...
				[  OK  ] Reached target Swap.
				[  OK  ] Listening on Journal Socket (/dev/log).
				[  OK  ] Listening on udev Control Socket.
				[  OK  ] Listening on udev Kernel Socket.
				[  OK  ] Created slice system-getty.slice.
				[  OK  ] Started Forward Password Requests to Wall Directory Watch.
				[  OK  ] Reached target Encrypted Volumes.
				[  OK  ] Reached target Paths.
				[  OK  ] Listening on Journal Socket.
						 Starting Remount Root and Kernel File Systems...
				[  OK  ] Listening on Syslog Socket.
						 Starting Journal Service...
						 Starting Load Kernel Modules...
						 Starting Create Static Device Nodes in /dev...
				[  OK  ] Listening on /dev/initctl Compatibility Named Pipe.
				[  OK  ] Reached target Sockets.
				[  OK  ] Mounted POSIX Message Queue File System.
				[  OK  ] Started Remount Root and Kernel File Systems.
						 Starting Load/Save Random Seed...
						 Starting udev Coldplug all Devices...
				[  OK  ] Started Load Kernel Modules.
						 Starting Apply Kernel Variables...
				[  OK  ] Started Journal Service.
				[  OK  ] Started Load/Save Random Seed.
						 Starting Flush Journal to Persistent Storage...
				[  OK  ] Started Create Static Device Nodes in /dev.
						 Starting udev Kernel Device Manager...
				[  OK  ] Reached target Local File Systems (Pre).
				[  OK  ] Reached target Local File Systems.
				[  OK  ] Started Apply Kernel Variables.
				systemd-journald[351]: Received request to flush runtime journal from PID 1
				[  OK  ] Started Flush Journal to Persistent Storage.
						 Starting Create Volatile Files and Directories...
						 Starting Raise network interfaces...
				[  OK  ] Started udev Kernel Device Manager.
				[  OK  ] Started udev Coldplug all Devices.
				[FAILED] Failed to start Create Volatile Files and Directories.
				See 'systemctl status systemd-tmpfiles-setup.service' for details.
				[FAILED] Failed to start Network Time Synchronization.
				See 'systemctl status systemd-timesyncd.service' for details.
				[  OK  ] Reached target System Time Synchronized.
						 Starting Update UTMP about System Boot/Shutdown...
				[  OK  ] Stopped Network Time Synchronization.
				[FAILED] Failed to start Network Time Synchronization.
				See 'systemctl status systemd-timesyncd.service' for details.
				[  OK  ] Stopped Network Time Synchronization.
				[FAILED] Failed to start Network Time Synchronization.
				See 'systemctl status systemd-timesyncd.service' for details.
				[FAILED] Failed to start Update UTMP about System Boot/Shutdown.
				See 'systemctl status systemd-update-utmp.service' for details.
				[DEPEND] Dependency failed for Update UTMP about System Runlevel Changes.
				[  OK  ] Stopped Network Time Synchronization.
				[FAILED] Failed to start Network Time Synchronization.
				See 'systemctl status systemd-timesyncd.service' for details.
				[  OK  ] Reached target System Initialization.
				[  OK  ] Reached target Basic System.
				[  OK  ] Started Daily Cleanup of Temporary Directories.
				[  OK  ] Started Daily apt download activities.
				[  OK  ] Started Daily apt upgrade and clean activities.
				[  OK  ] Reached target Timers.
						 Starting System Logging Service...
						 Starting getty on tty2-tty6 if dbus and logind are not available...
				[  OK  ] Started Regular background program processing daemon.
				[  OK  ] Stopped Network Time Synchronization.
				[FAILED] Failed to start Network Time Synchronization.
				See 'systemctl status systemd-timesyncd.service' for details.
				[  OK  ] Started System Logging Service.
				[  OK  ] Started Raise network interfaces.
				[  OK  ] Reached target Network.
						 Starting Permit User Sessions...
				[  OK  ] Stopped Network Time Synchronization.
				[FAILED] Failed to start Network Time Synchronization.
				See 'systemctl status systemd-timesyncd.service' for details.
				[  OK  ] Started getty on tty2-tty6 if dbus and logind are not available.
				[  OK  ] Started Permit User Sessions.
				[  OK  ] Started Getty on tty2.
				[  OK  ] Started Getty on tty4.
				[  OK  ] Started Getty on tty1.
				[  OK  ] Started Getty on tty3.
				[  OK  ] Started Getty on tty6.
				[  OK  ] Started Getty on tty5.
				[  OK  ] Reached target Login Prompts.
				[  OK  ] Reached target Multi-User System.
				[  OK  ] Reached target Graphical Interface.

				Debian GNU/Linux 9 node0 tty1

		
		SE LEE INFO DEL DC Y DEL DVS en el open del device /dev/dvk 
			root@node0:~# mknod /dev/dvk c 33 0
			random: crng init done
			root@node0:~# echo > /dev/dvk
			DEBUG 668:uml_dvk_open:224: dvk_dev=/dev/dvk
			DEBUG 668:uml_dvk_open:232: dvk_fd=20
			
			DEBUG 668:uml_getdvsinfo:96: 
			DEBUG 668:uml_getdvsinfo:98: os_ioctl_generic ret=0
			DEBUG 668:uml_getdvsinfo:100: d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
			
			DEBUG 668:uml_dvk_open:247: local_nodeid=0
			DEBUG 668:uml_getdcinfo:82: dcid=0
			DEBUG 668:uml_getdcinfo:86: os_ioctl_generic ret=0
			DEBUG 668:uml_getdcinfo:88: dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
			DEBUG 668:uml_getdcinfo:89: flags=0 dc_nodes=3 dc_pid=16698 dc_name=DC0

			DEBUG 668:uml_bind_X:126: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
			DEBUG 668:uml_bind_X:134: os_ioctl_generic ret=-2
			DEBUG 668:uml_dvk_open:257: uml_bind ep=-2
			DEBUG 668:uml_getprocinfo:109: dcid=0 p_nr=-2 
			DEBUG 668:uml_getprocinfo:114: os_ioctl_generic ret=0
			DEBUG 668:uml_getprocinfo:116: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=31362 vpid=31362 nodeid=0 name=linux 
			-bash: echo: write error: Invalid argument
			DEBUG 668:uml_dvk_release:270: dvk_dev=/dev/dvk

		EN EL HOST 
			root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0  -2    -2 31362/31362  0    0   20 27342 27342 27342 27342 linux

====================================================================================================
20190514:
		Se incluyeron todas las funciones de la libreria stub_dvkcall.c como fuentes
		dentro de um_dvk.c
		Obviamente se modifico completa la stub_dvkcall.c pero de esta forma se mantiene
		compatibilidad a futuro.
		Se especifican dcid, uml_ep, rd_ep y rd_cfg.
		
		
		# cd /usr/src/dvs/dvk-tests/
		# ./tests.sh 0 0
		# . /dev/shm/DC0.sh 
		# cd /usr/src/linux 
		# nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 rd_cfg="rdisk.cfg"

		EN UML 
		UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
		DEBUG 1:uml_dvk_init_module:185: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
		DEBUG 1:uml_dvk_init_module:190: UML-kernel PID=2  UML-kernel TID=2

		winch_thread : TIOCSCTTY failed on fd 1 err = 1 <<<<<<<!!!!!!!!!! WHY ?????????
		
		root@node0:~# mknod /dev/dvk c 33 0
		random: crng init done
		root@node0:~# echo > /dev/dvk 
		DEBUG 664:uml_dvk_open:116: dvk_dev=/dev/dvk
		DEBUG 2:dvk_open:61: Open dvk device file /dev/dvk
		DEBUG 2:dvk_getdvsinfo:176: 
		DEBUG 2:dvk_getdvsinfo:184: ioctl ret=0
		DEBUG 664:uml_dvk_open:131: local_nodeid=0
		DEBUG 664:uml_dvk_open:132: d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		DEBUG 2:dvk_getdcinfo:254: dcid=0
		DEBUG 2:dvk_getdcinfo:264: ioctl ret=0
		DEBUG 664:uml_dvk_open:138: dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		DEBUG 664:uml_dvk_open:139: flags=0 dc_nodes=3 dc_pid=30977 dc_name=DC0
		DEBUG 2:dvk_bind_X:922: cmd=0 dcid=0 pid=2 endpoint=-2 nodeid=-1
		DEBUG 2:dvk_bind_X:941: ioctl ret=-2
		DEBUG 664:uml_dvk_open:142: uml_bind uml_ep=-2 ep=-2
		DEBUG 2:dvk_getprocinfo:890: dcid=0 p_nr=-2 
		DEBUG 2:dvk_getprocinfo:901: ioctl ret=0
		DEBUG 664:uml_dvk_open:150: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=1739 vpid=2 nodeid=0 name=linux 
		-bash: echo: write error: Invalid argument
		DEBUG 664:uml_dvk_release:157: dvk_dev=/dev/dvk 

		EN UML 
		[   31.370000] DEBUG 664:uml_dvk_open:116: dvk_dev=/dev/dvk
		[   31.370000] DEBUG 2:dvk_open:61: Open dvk device file /dev/dvk
		[   31.370000] DEBUG 2:dvk_getdvsinfo:176: 
		[   31.370000] DEBUG 2:dvk_getdvsinfo:184: ioctl ret=0
		[   31.370000] DEBUG 664:uml_dvk_open:131: local_nodeid=0
		[   31.370000] DEBUG 664:uml_dvk_open:132: d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		[   31.370000] DEBUG 2:dvk_getdcinfo:254: dcid=0
		[   31.370000] DEBUG 2:dvk_getdcinfo:264: ioctl ret=0
		[   31.370000] DEBUG 664:uml_dvk_open:138: dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		[   31.370000] DEBUG 664:uml_dvk_open:139: flags=0 dc_nodes=3 dc_pid=30977 dc_name=DC0
		[   31.370000] DEBUG 2:dvk_bind_X:922: cmd=0 dcid=0 pid=2 endpoint=-2 nodeid=-1
		[   31.370000] DEBUG 2:dvk_bind_X:941: ioctl ret=-2
		[   31.370000] DEBUG 664:uml_dvk_open:142: uml_bind uml_ep=-2 ep=-2
		[   31.370000] DEBUG 2:dvk_getprocinfo:890: dcid=0 p_nr=-2 
		[   31.370000] DEBUG 2:dvk_getprocinfo:901: ioctl ret=0
		[   31.370000] DEBUG 664:uml_dvk_open:150: nr=-2 endp=-2 dcid=0 flags=0 misc=20 lpid=1739 vpid=2 nodeid=0 name=linux 
		[   31.370000] DEBUG 664:uml_dvk_release:157: dvk_dev=/dev/dvk


		EN EL HOST 
		root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
		DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
		 0  -2    -2  1739/2      0    0   20 27342 27342 27342 27342 linux   
 
		
		root@node0:/usr/src/linux# ps -ef | grep linux
		root       451     1  0 19:05 tty1     00:00:00 /sbin/agetty --noclear tty1 linux
		root      1738  1721  0 20:58 pts/1    00:00:00 nsenter -p -t30977 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 rd_cfg=rdisk.cfg
		root      1739  1738  1 20:58 ?        00:00:02 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 rd_cfg=rdisk.cfg
		root      1744  1739  0 20:58 ?        00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 rd_cfg=rdisk.cfg
		root      1745  1739  0 20:58 ?        00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 rd_cfg=rdisk.cfg
		root      1746  1739  0 20:58 ?        00:00:00 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 rd_cfg=rdisk.cfg
		root      1748  1739  0 20:58 ?        00:00:00 [linux] <defunct>
		root      1749  1739  0 20:58 ?        00:00:00 [linux]
		root      1779  1739  0 20:58 ?        00:00:00 [linux]
		root      1791  1739  0 20:58 ?        00:00:00 [linux]
		root      1857  1739  0 20:58 ?        00:00:00 [linux]
		root      1863  1739  0 20:58 ?        00:00:00 [linux]
		root      1889  1739  0 20:58 ?        00:00:00 [linux] <defunct> <<<<<<< QUE LE HABRA PASASO ?????
		root      1890  1739  0 20:58 ?        00:00:00 [linux]
		root      1892  1739  0 20:58 ?        00:00:00 [linux]
		root      1893  1739  0 20:58 ?        00:00:00 [linux]
		root      1894  1739  0 20:58 ?        00:00:00 [linux]
		root      1895  1739  0 20:58 ?        00:00:00 [linux]
		root      1896  1739  0 20:59 ?        00:00:00 [linux]
		root      1907  1739  0 20:59 ?        00:00:00 [linux]



====================================================================================================
20190518:
			Modifique mol/drivers/rdisk 
			Incorpore um/drivers/rdisk_user.*
			
			ATENCION: hay que modificar el Kconfig.char del directorio arch/um/
			
config UML_RDISK 
	bool "UML Replicated Disk proxy"
	default y
	help
	This options enable RDISK proxy to the host RDISK.
	
	
config UML_DVK 
	bool "UML Distributed Virtualization Kernel (DVK) pseudo character device"
	default y
	help
	This options enable DVK pseudo device driver as a pass-through to the host-DVK.
	
	
	
> UML Character Devices qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
  lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq UML Character Devices qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk
  x  Arrow keys navigate the menu.  <Enter> selects submenus ---> (or empty submenus  x
  x  ----).  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes,   x
  x  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> for       x
  x  Search.  Legend: [*] built-in  [ ] excluded  <M> module  < > module capable      x
  x lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk x
  x x    [*] UML Replicated Disk proxy                                              x x <<<<<<<<<<<<<<<
  x x    [*] UML Distributed Virtualization Kernel (DVK) pseudo character device    x x <<<<<<<<<<<<<<<
  x x    [ ] stderr console                                                         x x
  x x    [ ] Virtual serial line                                                    x x
  x x    [ ] null channel support                                                   x x
  x x    [ ] port channel support                                                   x x
  x x    [ ] pty channel support                                                    x x
  x x    [ ] tty channel support                                                    x x
  x x    [ ] xterm channel support                                                  x x
  x x    (fd:0,fd:1) Default main console channel initialization                    x x
  x x    (xterm) Default console channel initialization                             x x
  x x    (pty) Default serial line channel initialization                           x x
  x x    [ ] Sound support                                                          x x
  x x                                                                               x x
  x x                                                                               x x
  x mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj x
  tqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqu
  x             <Select>    < Exit >    < Help >    < Save >    < Load >              x
  mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj

====================================================================================================
20190520:

		# cd /usr/src/dvs/dvk-tests/
		# ./tests.sh 0 0
		# . /dev/shm/DC0.sh 
		# cd /dev/shm 
		# nsenter -p -u -F -t$DC0 /usr/src/dvs/vos/mol/drivers/rdisk/rdisk -d 0 -e 3 -c /dev/shm/rdisk.cfg > /dev/shm/rdisk.out 2> /dev/shm/rdisk.err &
		# cat /proc/dvs/DC0/procs 
		# cd /usr/src/linux 
		# nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 
		


root@node0:/usr/src/linux# nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3
				uml_dcid: dcid=0
				uml_uml_ep: uml_ep=-2
				uml_rd_ep: rd_ep=3
				Locating the bottom of the address space ... 0x0
				Locating the top of the address space ... 0xc0000000
				Core dump limits :
						soft - 0
						hard - NONE
				Checking that ptrace can change system call numbers...OK
				Checking syscall emulation patch for ptrace...OK
				Checking advanced syscall emulation patch for ptrace...OK
				Checking environment variables for a tempdir...none found
				Checking if /dev/shm is on tmpfs...OK
				Checking PROT_EXEC mmap in /dev/shm...OK
				Adding 14602240 bytes to physical memory to account for exec-shield gap
				Abortado

LO QUE FALTA ES 
				DEBUG 0:start_kernel_proc:30: UML-kernel PID=31362  UML-kernel TID=31362
				DEBUG 0:start_kernel_proc:36: DVK device file successfully opened!! dvk_fd=3
				Linux version 4.9.88 (root@node0) (gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) ) #29 Tue May 14 00:01:20 -03 2019
				Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 262981


EL PROBLEMA APARENTEMENTE ESTA EN LOS DVKDEBUG 
SI SE LOS REMUEVE DA EL RESULTADO DE ABAJO 

static int __init start_kernel_proc(void *unused)
{
	int pid, tid;

	block_signals();
	
#ifdef CONFIG_UML_DVK
	pid = os_getpid();
	tid = os_gettid();
	printf("UML-kernel PID=%d  UML-kernel TID=%d\n", pid, tid);
//	DVKDEBUG(INTERNAL, "UML-kernel PID=%d  UML-kernel TID=%d\n", pid, tid);
	os_flush_stdout();
	
	dvk_fd = (-1);
	dvk_fd = os_open_file(UML_DVK_DEV, of_set_rw(OPENFLAGS(), 1, 1), 0);
	if ( dvk_fd < 0){
		ERROR_PRINT(dvk_fd);
	}else{
//		DVKDEBUG(INTERNAL, "DVK device file successfully opened!! dvk_fd=%d\n", dvk_fd);
printf("DVK device file successfully opened!! dvk_fd=%d\n", dvk_fd);
	}
	os_flush_stdout();
#endif // CONFIG_UML_DVK
		
	cpu_tasks[0].pid = pid;
	cpu_tasks[0].task = current;

	start_kernel();
	return 0;
}


root@node0:/usr/src/linux# nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3
uml_dcid: dcid=0
uml_uml_ep: uml_ep=-2
uml_rd_ep: rd_ep=3
Locating the bottom of the address space ... 0x0
Locating the top of the address space ... 0xc0000000
Core dump limits :
        soft - 0
        hard - NONE
Checking that ptrace can change system call numbers...OK
Checking syscall emulation patch for ptrace...OK
Checking advanced syscall emulation patch for ptrace...OK
Checking environment variables for a tempdir...none found
Checking if /dev/shm is on tmpfs...OK
Checking PROT_EXEC mmap in /dev/shm...OK
Adding 21426176 bytes to physical memory to account for exec-shield gap
UML-kernel PID=99  UML-kernel TID=99
DVK device file successfully opened!! dvk_fd=3
Abortado


==============================================================================================
20190523:
			Se termino parcialmente rdisk driver .
			
root@node0:/usr/src/linux# nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3
uml_dcid: dcid=0
uml_uml_ep: uml_ep=-2
uml_rd_ep: rd_ep=3
Locating the bottom of the address space ... 0x0
Locating the top of the address space ... 0xc0000000
Core dump limits :
        soft - 0
        hard - NONE
Checking that ptrace can change system call numbers...OK
Checking syscall emulation patch for ptrace...OK
Checking advanced syscall emulation patch for ptrace...OK
Checking environment variables for a tempdir...none found
Checking if /dev/shm is on tmpfs...OK
Checking PROT_EXEC mmap in /dev/shm...OK
Adding 19259392 bytes to physical memory to account for exec-shield gap
DEBUG start_kernel_proc:32: UML-kernel PID=2  UML-kernel TID=2
DEBUG start_kernel_proc:41: DVK device file successfully opened!! dvk_fd=3
Linux version 4.9.88 (root@node0) (gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) ) #34 Tue May 21 07:56:20 -03 2019
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 264761
Kernel command line: con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 root=98:0
PID hash table entries: 4096 (order: 2, 16384 bytes)
Dentry cache hash table entries: 262144 (order: 8, 1048576 bytes)
Inode-cache hash table entries: 131072 (order: 7, 524288 bytes)
Memory: 1034944K/1067384K available (2188K kernel code, 632K rwdata, 620K rodata, 81K init, 125K bss, 32440K reserved, 0K cma-reserved)
NR_IRQS:15
clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
Calibrating delay loop... 1797.32 BogoMIPS (lpj=8986624)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 4096 (order: 2, 16384 bytes)
Mountpoint-cache hash table entries: 4096 (order: 2, 16384 bytes)
Checking for host processor cmov support...Yes
Checking that host ptys support output SIGIO...Yes
Checking that host ptys support SIGIO on close...No, enabling workaround
devtmpfs: initialized
Using 2.6 host AIO
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
futex hash table entries: 256 (order: -1, 3072 bytes)
NET: Registered protocol family 16
clocksource: Switched to clocksource timer
VFS: Disk quotas dquot_6.6.0
VFS: Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
NET: Registered protocol family 2
TCP established hash table entries: 16384 (order: 4, 65536 bytes)
TCP bind hash table entries: 16384 (order: 4, 65536 bytes)
TCP: Hash tables configured (established 16384 bind 16384)
UDP hash table entries: 1024 (order: 2, 16384 bytes)
UDP-Lite hash table entries: 1024 (order: 2, 16384 bytes)
NET: Registered protocol family 1
console [stderr0] disabled
mconsole (version 2) initialized on /root/.uml/SGISDp/mconsole
Checking host MADV_REMOVE support...OK
UML Audio Relay (host dsp = /dev/sound/dsp, host mixer = /dev/sound/mixer)
UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
DEBUG uml_dvk_init_module:147: UML Distributed Virtualization Kernel (host dvk_dev = /dev/dvk)
DEBUG uml_dvk_init_module:152: UML-kernel PID=2  UML-kernel TID=2
Host TLS support detected
Detected host type: i386 (GDT indexes 6 to 9)
workingset: timestamp_bits=30 max_order=18 bucket_order=0
io scheduler noop registered
io scheduler deadline registered (default)
io scheduler cfq registered
loop: module loaded
nbd: registered device at major 43
tun: Universal TUN/TAP device driver, 1.6
tun: (C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>
PPP generic driver version 2.4.2
SLIP: version 0.8.4-NET3.019-NEWTTY (dynamic channels, max=256).
NET: Registered protocol family 17
Initialized stdio console driver
Console initialized on /dev/tty0
console [tty0] enabled
Initializing software serial port version 1
console [mc-1] enabled
winch_thread : TIOCSCTTY failed on fd 2 err = 1
EXT4-fs (ubda): couldn't mount as ext3 due to feature incompatibilities
EXT4-fs (ubda): mounting ext2 file system using the ext4 subsystem
EXT4-fs (ubda): mounted filesystem without journal. Opts: (null)
VFS: Mounted root (ext2 filesystem) readonly on device 98:0.
devtmpfs: mounted
This architecture does not have kernel memory protection.
random: fast init done
systemd[1]: systemd 232 running in system mode. (+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN)
systemd[1]: Detected virtualization vmware.
systemd[1]: Detected architecture x86.

Welcome to Debian GNU/Linux 9 (stretch)!

systemd[1]: Set hostname to <node0>.
systemd[1]: Failed to enable kbrequest handling: Inappropriate ioctl for device
systemd[1]: Created slice System Slice.
[  OK  ] Created slice System Slice.
systemd[1]: Listening on udev Control Socket.
[  OK  ] Listening on udev Control Socket.
systemd[1]: dev-hugepages.mount: Couldn't determine result for ConditionVirtualization=!private-users, assuming failed: No such file or directory
systemd[1]: Listening on Journal Socket.
[  OK  ] Listening on Journal Socket.
systemd[1]: Starting Load Kernel Modules...
         Starting Load Kernel Modules...
[  OK  ] Reached target Remote File Systems.
[  OK  ] Created slice system-getty.slice.
         Mounting POSIX Message Queue File System...
[  OK  ] Listening on Syslog Socket.
[  OK  ] Listening on Journal Socket (/dev/log).
[  OK  ] Reached target Swap.
[  OK  ] Listening on /dev/initctl Compatibility Named Pipe.
         Starting Remount Root and Kernel File Systems...
[  OK  ] Listening on udev Kernel Socket.
[  OK  ] Reached target Slices.
[  OK  ] Started Dispatch Password Requests to Console Directory Watch.
[  OK  ] Reached target Sockets.
         Starting Journal Service...
[  OK  ] Set up automount Arbitrary Executabâ¦rmats File System Automount Point.
[  OK  ] Started Forward Password Requests to Wall Directory Watch.
[  OK  ] Reached target Encrypted Volumes.
[  OK  ] Reached target Paths.
         Starting Create Static Device Nodes in /dev...
[  OK  ] Mounted POSIX Message Queue File System.
[  OK  ] Started Load Kernel Modules.
[  OK  ] Started Remount Root and Kernel File Systems.
         Starting udev Coldplug all Devices...
         Starting Load/Save Random Seed...
         Starting Apply Kernel Variables...
[  OK  ] Started Journal Service.
[  OK  ] Started Create Static Device Nodes in /dev.
         Starting udev Kernel Device Manager...
[  OK  ] Reached target Local File Systems (Pre).
[  OK  ] Reached target Local File Systems.
         Starting Flush Journal to Persistent Storage...
[  OK  ] Started Load/Save Random Seed.
[  OK  ] Started Apply Kernel Variables.
[  OK  ] Started udev Kernel Device Manager.
systemd-journald[352]: Received request to flush runtime journal from PID 1
         Starting Raise network interfaces...
[  OK  ] Started Flush Journal to Persistent Storage.
         Starting Create Volatile Files and Directories...
[FAILED] Failed to start Create Volatile Files and Directories.
See 'systemctl status systemd-tmpfiles-setup.service' for details.
[FAILED] Failed to start Network Time Synchronization.
See 'systemctl status systemd-timesyncd.service' for details.
[  OK  ] Reached target System Time Synchronized.
         Starting Update UTMP about System Boot/Shutdown...
[  OK  ] Stopped Network Time Synchronization.
[FAILED] Failed to start Network Time Synchronization.
See 'systemctl status systemd-timesyncd.service' for details.
[  OK  ] Stopped Network Time Synchronization.
[FAILED] Failed to start Network Time Synchronization.
See 'systemctl status systemd-timesyncd.service' for details.
[  OK  ] Started udev Coldplug all Devices.
[  OK  ] Stopped Network Time Synchronization.
[FAILED] Failed to start Network Time Synchronization.
See 'systemctl status systemd-timesyncd.service' for details.
[FAILED] Failed to start Update UTMP about System Boot/Shutdown.
See 'systemctl status systemd-update-utmp.service' for details.
[DEPEND] Dependency failed for Update UTMP about System Runlevel Changes.
[  OK  ] Stopped Network Time Synchronization.
[FAILED] Failed to start Network Time Synchronization.
See 'systemctl status systemd-timesyncd.service' for details.
[  OK  ] Reached target System Initialization.
[  OK  ] Started Daily Cleanup of Temporary Directories.
[  OK  ] Started Daily apt download activities.
[  OK  ] Started Daily apt upgrade and clean activities.
[  OK  ] Reached target Timers.
[  OK  ] Reached target Basic System.
[  OK  ] Started Regular background program processing daemon.
         Starting System Logging Service...
         Starting getty on tty2-tty6 if dbus and logind are not available...
[  OK  ] Started System Logging Service.
[  OK  ] Started getty on tty2-tty6 if dbus and logind are not available.
[  OK  ] Started Raise network interfaces.
[  OK  ] Reached target Network.
         Starting Permit User Sessions...
[  OK  ] Stopped Network Time Synchronization.
[FAILED] Failed to start Network Time Synchronization.
See 'systemctl status systemd-timesyncd.service' for details.
[  OK  ] Started Permit User Sessions.
[  OK  ] Started Getty on tty4.
[  OK  ] Started Getty on tty5.
[  OK  ] Started Getty on tty6.
[  OK  ] Started Getty on tty3.
[  OK  ] Started Getty on tty1.
[  OK  ] Started Getty on tty2.
[  OK  ] Reached target Login Prompts.
[  OK  ] Reached target Multi-User System.
[  OK  ] Reached target Graphical Interface.
winch_thread : TIOCSCTTY failed on fd 1 err = 1

Debian GNU/Linux 9 node0 tty1

node0 login:

==============================================================================================
20190529:
		Se modifico RDISK pero hay un problema en rdisk_user.c 
Aparentemente ignora la constante de configuracion CONFIG_UML_RDISK y no compila si la 
siguiente lineas estan habilitadas
 	
// #ifdef CONFIG_UML_RDISK 
.....
// #endif // CONFIG_UML_RDISK 


EN EL HOST
[ 1850.940406] DEBUG dvk_open:167: 
[ 1851.086936] DEBUG dvk_open:167: 
[ 1851.086946] DEBUG dvk_ioctl:201: cmd=8004E31B arg=83C6A20
[ 1851.086948] DEBUG dvk_ioctl:221: DVK_CALL=27 (getdvsinfo) 
[ 1851.086949] DEBUG io_getdvsinfo:288: 
[ 1851.086951] DEBUG new_getdvsinfo:1789: local_nodeid=0 
[ 1851.086960] DEBUG dvk_ioctl:201: cmd=8004E30E arg=48958FA8
[ 1851.086961] DEBUG dvk_ioctl:221: DVK_CALL=14 (getdcinfo) 
[ 1851.086963] DEBUG io_getdcinfo:153: 
[ 1851.086964] DEBUG new_getdcinfo:1818: dcid=0 
[ 1851.087053] DEBUG check_caller:536: caller_pid=13424 caller_tgid=13424
[ 1851.087055] ERROR: 13424:check_caller:570: rcode=-310
[ 1851.087057] DEBUG new_getdcinfo:1836: RLOCK_DC dc=0 count=0
[ 1851.087059] DEBUG new_getdcinfo:1838: RUNLOCK_DC dc=0 count=0
[ 1851.087071] DEBUG dvk_ioctl:201: cmd=4004E309 arg=48958F88
[ 1851.087073] DEBUG dvk_ioctl:221: DVK_CALL=9 (bind) 
[ 1851.087074] DEBUG io_bind:97: 
[ 1851.087076] DEBUG new_bind:1372: oper=0 dcid=0 param_pid=10 endpoint=30 nodeid=-1
[ 1851.087078] DEBUG new_bind:1394: RLOCK_DC dc=0 count=0
[ 1851.087079] DEBUG new_bind:1407: WLOCK_PROC ep=30 count=0
[ 1851.087081] DEBUG init_proc_desc:16: p_name=$noname dcid=0
[ 1851.087084] DEBUG new_bind:1441: param_pid=10 lpid=13424 vpid=10 tid=13424
[ 1851.087085] DEBUG new_bind:1465: SELF_BIND param_pid=10 lpid=13424 vpid=10 tid=13424
[ 1851.087087] DEBUG new_bind:1487: WUNLOCK_PROC ep=30 count=0
[ 1851.087088] DEBUG new_bind:1490: WLOCK_TASK pid=13424 count=0
[ 1851.087089] DEBUG new_bind:1491: WLOCK_PROC ep=30 count=0
[ 1851.087090] DEBUG new_bind:1527: increment the reference count of the task struct=13424 count=2
[ 1851.087091] DEBUG new_bind:1538: process p_name=linux *p_name_ptr=linux
[ 1851.087094] DEBUG new_bind:1595: nr=30 endp=30 dcid=0 flags=0 misc=20 lpid=13424 vpid=10 nodeid=0 name=linux 
[ 1851.087096] DEBUG new_bind:1596: nr=30 endp=30 dcid=0 lpid=13424 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[ 1851.087098] DEBUG new_bind:1610: WUNLOCK_TASK pid=13424 count=0
[ 1851.087099] DEBUG new_bind:1616: WUNLOCK_PROC ep=30 count=0
[ 1851.087099] DEBUG new_bind:1618: DC_INCREF counter=2
[ 1851.087101] DEBUG new_bind:1619: RUNLOCK_DC dc=0 count=0
[ 1851.087106] DEBUG dvk_ioctl:201: cmd=8004E30F arg=48958F8C
[ 1851.087107] DEBUG dvk_ioctl:221: DVK_CALL=15 (getprocinfo) 
[ 1851.087108] DEBUG io_getprocinfo:164: 
[ 1851.087109] DEBUG new_getprocinfo:1898: dcid=0 p_nr=30
[ 1851.087111] DEBUG check_caller:536: caller_pid=13424 caller_tgid=13424
[ 1851.087112] DEBUG check_caller:572: WLOCK_PROC ep=30 count=0
[ 1851.087113] DEBUG check_caller:601: WUNLOCK_PROC ep=30 count=0
[ 1851.087114] DEBUG check_caller:604: dcid=0
[ 1851.087115] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[ 1851.087116] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[ 1851.087117] DEBUG check_caller:618: caller_pid=13424 
[ 1851.087118] DEBUG new_getprocinfo:1915: RLOCK_DC dc=0 count=0
[ 1851.087119] DEBUG new_getprocinfo:1920: RUNLOCK_DC dc=0 count=0
[ 1851.087120] DEBUG new_getprocinfo:1922: RLOCK_PROC ep=30 count=0
[ 1851.087121] DEBUG new_getprocinfo:1923: lpid=13424 name=linux
[ 1851.087123] DEBUG new_getprocinfo:1925: RUNLOCK_PROC ep=30 count=0

[ 1854.765504] DEBUG dvk_ioctl:201: cmd=4004E305 arg=48169C2C
[ 1854.765508] DEBUG dvk_ioctl:221: DVK_CALL=5 (mini_sendrec) 
[ 1854.765509] DEBUG io_mini_sendrec:56: 
[ 1854.765510] DEBUG new_mini_sendrec:507: srcdst_ep=3
[ 1854.765512] DEBUG check_caller:536: caller_pid=13416 caller_tgid=13416
[ 1854.765514] ERROR: 13416:check_caller:570: rcode=-310
[ 1854.765515] ERROR: 13416:new_mini_sendrec:511: rcode=-310 <<<<<<<<<<<<<<<<< EDVSNOTBIND
[ 1854.765516] ERROR: 13416:dvk_ioctl:225: rcode=-310

[ 1884.620082] DEBUG dvk_ioctl:221: DVK_CALL=5 (mini_sendrec) 
[ 1884.620083] DEBUG io_mini_sendrec:56: 
[ 1884.620085] DEBUG new_mini_sendrec:507: srcdst_ep=3
[ 1884.620087] DEBUG check_caller:536: caller_pid=13416 caller_tgid=13416
[ 1884.620088] ERROR: 13416:check_caller:570: rcode=-310
[ 1884.620090] ERROR: 13416:new_mini_sendrec:511: rcode=-310
[ 1884.620091] ERROR: 13416:dvk_ioctl:225: rcode=-310
[ 1884.625925] DEBUG dvk_ioctl:201: cmd=4004E305 arg=48C07CC0
[ 1884.625928] DEBUG dvk_ioctl:221: DVK_CALL=5 (mini_sendrec) 
[ 1884.625929] DEBUG io_mini_sendrec:56: 
[ 1884.625931] DEBUG new_mini_sendrec:507: srcdst_ep=3
[ 1884.625933] DEBUG check_caller:536: caller_pid=13416 caller_tgid=13416
[ 1884.625935] ERROR: 13416:check_caller:570: rcode=-310
[ 1884.625936] ERROR: 13416:new_mini_sendrec:511: rcode=-310
[ 1884.625937] ERROR: 13416:dvk_ioctl:225: rcode=-310
[ 1884.641001] DVK: exit_unbind local_nodeid:0

root@node0:/usr/src/dvs/vos/mol/drivers/rdisk# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   3     3   695/695    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 13424/10     0    0   20 27342 27342 27342 27342 linux 

PROBLEMA: 
[ 1851.087096] DEBUG new_bind:1596: nr=30 endp=30 dcid=0 lpid=13424 <<<<<< p_cpumask=FFFFFFFF nodemap=1 name=linux 

[ 1854.765512] DEBUG check_caller:536: caller_pid=13416 caller_tgid=13416<<<<<<<<<
   


EN UML 

root@node0:~# mount /dev/rdiska /mnt
DEBUG rd_open:654: 
DEBUG rd_open_dev:276: major=3 minor=0
DEBUG rd_open_dev:287: source=1219208292 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1219208192 m2p1=  (null)
DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 2:dvk_sendrec_T:712: ioctl ret=-310
ERROR: 2:dvk_sendrec_T:714: rcode=-310
ERROR: 682:rd_open_dev:289: rcode=-310
rdiska: Can't open: errno = 310
DEBUG rd_open:654: 
DEBUG rd_open_dev:276: major=3 minor=0
DEBUG rd_open_dev:287: source=1219208292 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1219208192 m2p1=  (null)
DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 2:dvk_sendrec_T:712: ioctl ret=-310
ERROR: 2:dvk_sendrec_T:714: rcode=-310
ERROR: 682:rd_open_dev:289: rcode=-310
rdiska: Can't open: errno = 310
mount: mount /dev/rdiska on /mnt failed: Unknown error 310
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:8192
root@node0:~# DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0


==============================================================================================
20190531:
	Sesion 1:
		Arrancar rtest.sh 
		Arrancar rdisk.sh 
		root@node0:/usr/src/linux/arch/um# cat /proc/dvs/DC0/procs 
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0   3     3   695/695    0    8   20 31438 27342 27342 27342 rdisk
		
	Sesion 2:
		. /dev/shm/DC0.sh
		cd /usr/src/linux 
		nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3
		
	Aqui se bindea RDISK CLIENT con el mayor nombre disponible
		root@node0:/usr/src/linux/arch/um# cat /proc/dvs/DC0/procs 
		DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name        
		 0   3     3   695/695    0    8   20 31438 27342 27342 27342 rdisk          
		
	Luego hacer DENTRO de UML 
		mknod /dev/dvk c 33 0 
		echo > /dev/dvk  <<<<<<<<<<<< ESTO FUERZA EL OPEN DEL DVK y por lo tanto hace el BIND del UML con endpoint=SYSTASK 
		
	root@node0:/usr/src/linux/arch/um# cat /proc/dvs/DC0/procs 
	DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
	 0  -2    -2 13416/2      0    0   20 27342 27342 27342 27342 linux  <<<<<<<<< UML KERNEL 
	 0   3     3   695/695    0    8   20 31438 27342 27342 27342 rdisk          
	 0  30    30 13424/10     0    0   20 27342 27342 27342 27342 linux  <<<<<<<<<<<< RDISK CLIENT 
	  
	  
		EN EL BOOTEO DE UML 
	  DEBUG rd_open:651: 
		DEBUG rd_open_dev:273: major=3 minor=0
		DEBUG rd_open_dev:284: source=1205896292 type=1030 m2i1=0 m2i2=0 m2i3=0 m2l1=0 m2l2=1205896192 m2p1=  (null)
		DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
		DEBUG 2:dvk_sendrec_T:712: ioctl ret=-310
		ERROR: 2:dvk_sendrec_T:714: rcode=-310
		ERROR: 579:rd_open_dev:286: rcode=-310
		rdiska: Can't open: errno = 310

	  
	 Cuando se trata de hacer el mount del RDISK en UML 
root@node0:~# mount /dev/rdiska /mnt
DEBUG rd_open:651: 
DEBUG rd_open_dev:273: major=3 minor=0
DEBUG rd_open_dev:284: source=1218733156 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1218733056 m2p1=  (null)
DEBUG 226:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 226:dvk_sendrec_T:712: ioctl ret=0
DEBUG rd_open_dev:287: source=3 type=68 m2i1=30 m2i2=0 m2i3=0 m2l1=0 m2l2=1218733056 m2p1=  (null)
DEBUG rd_open:651: 
DEBUG rd_open_dev:273: major=3 minor=0
DEBUG rd_open_dev:284: source=1218733156 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1218733056 m2p1=  (null)
DEBUG 226:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 226:dvk_sendrec_T:712: ioctl ret=0
DEBUG rd_open_dev:287: source=3 type=68 m2i1=30 m2i2=-16 m2i3=0 m2l1=0 m2l2=1218733056 m2p1=  (null)
DEBUG do_rdisk:877: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:857: source=4 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=46d33000
DEBUG 234:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 234:dvk_sendrec_T:712: ioctl ret=-108
ERROR: 234:dvk_sendrec_T:714: rcode=-108
ERROR: 0:rdisk_rw:859: rcode=-108
do_rdisk - read failed, err = -108
find_irq_by_fd doesn't have descriptor 14
DEBUG do_rdisk:877: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:857: source=1204 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=46d34000
DEBUG 234:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 234:dvk_sendrec_T:712: ioctl ret=-105
ERROR: 234:dvk_sendrec_T:714: rcode=-105
ERROR: 0:rdisk_rw:859: rcode=-105
do_rdisk - read failed, err = -105

RDISK VE 
 driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=-2, m_type=1030, DEVICE=0, IO_ENDPT=0, POSITION=0, COUNT=0, ADDRESS:0, compress(m2_l2):1205896192
 driver.c:driver_task:140:device_caller= -2, mess.m_source= -2
 driver.c:driver_task:147:m_type: 1030 - DEV_OPEN
 rdisk.c:m_do_open:711:m_do_open - device number: 0 - OK to open
 rdisk.c:m_do_open:717:rcode 0
 rdisk.c:m_do_open:726:Open imagen FD=4
 rdisk.c:m_do_open:743:Aligned Buffer size=4096 on address 246E000, device=0
 rdisk.c:m_do_open:744:Local Buffer 246E000
 rdisk.c:m_do_open:745:Buffer size 4096
 rdisk.c:m_do_open:748:Device 0 is active_flag 1
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:966:img_fd=4 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=246E000 active=1 available=1
 rdisk.c:get_geometry:972:base=0 size=102400000 cyl=97 heads=64 sec=32
 rdisk.c:m_do_open:810:img_fd=4 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=246E000 active=1 available=1
 rdisk.c:m_do_open:812:END m_do_open
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: -2 -> m_type=68, (REP_ENDPT)=0, (REP_STATUS)=0
DEBUG 597:dvk_send_T:653: endpoint=-2 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=-2, m_type=1030, DEVICE=0, IO_ENDPT=0, POSITION=0, COUNT=0, ADDRESS:0, compress(m2_l2):1205896192
 driver.c:driver_task:140:device_caller= -2, mess.m_source= -2
 driver.c:driver_task:147:m_type: 1030 - DEV_OPEN
 rdisk.c:m_do_open:711:m_do_open - device number: 0 - OK to open
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: -2 -> m_type=68, (REP_ENDPT)=0, (REP_STATUS)=-16
DEBUG 597:dvk_send_T:653: endpoint=-2 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
 

==============================================================================================
20190601:
	
UML MOUNT 	
root@node0:~# mount /dev/rdiska /mnt/
DEBUG rd_open:651: 
DEBUG rd_open_dev:273: major=3 minor=0
DEBUG rd_open_dev:284: source=1231062116 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1231062016 m2p1=  (null)
DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 2:dvk_sendrec_T:712: ioctl ret=0
DEBUG rd_open_dev:287: source=3 type=68 m2i1=30 m2i2=0 m2i3=0 m2l1=0 m2l2=1231062016 m2p1=  (null)
DEBUG rd_open:651: 
DEBUG rd_open_dev:273: major=3 minor=0
DEBUG rd_open_dev:284: source=1231062116 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1231062016 m2p1=  (null)
DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 2:dvk_sendrec_T:712: ioctl ret=0
DEBUG rd_open_dev:287: source=3 type=68 m2i1=30 m2i2=0 m2i3=0 m2l1=0 m2l2=1231062016 m2p1=  (null)
DEBUG do_rdisk:877: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:857: source=4 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47918000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:860: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47918000
find_irq_by_fd doesn't have descriptor 14 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
DEBUG do_rdisk:877: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:857: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47919000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:860: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47919000

RDISK REPORTA 		 
driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=-2, m_type=1030, DEVICE=0, IO_ENDPT=30, POSITION=0, COUNT=0, ADDRESS:0, compress(m2_l2):1231062016
 driver.c:driver_task:140:device_caller= -2, mess.m_source= -2
 driver.c:driver_task:147:m_type: 1030 - DEV_OPEN
 rdisk.c:m_do_open:719:m_do_open - device number: 0 - OK to open
 rdisk.c:m_do_open:728:rcode 0
 rdisk.c:m_do_open:737:Open imagen FD=4
 rdisk.c:m_do_open:754:Aligned Buffer size=4096 on address 154F000, device=0
 rdisk.c:m_do_open:755:Local Buffer 154F000
 rdisk.c:m_do_open:756:Buffer size 4096
 rdisk.c:m_do_open:759:Device 0 is active_flag 1
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:977:img_fd=4 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=154F000 active=1 available=1
 rdisk.c:get_geometry:983:base=0 size=102400000 cyl=97 heads=64 sec=32
 rdisk.c:m_do_open:821:img_fd=4 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=154F000 active=1 available=1
 rdisk.c:m_do_open:823:END m_do_open
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: -2 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=0
DEBUG 597:dvk_send_T:653: endpoint=-2 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=-2, m_type=1030, DEVICE=0, IO_ENDPT=30, POSITION=0, COUNT=0, ADDRESS:0, compress(m2_l2):1231062016
 driver.c:driver_task:140:device_caller= -2, mess.m_source= -2
 driver.c:driver_task:147:m_type: 1030 - DEV_OPEN
 rdisk.c:m_do_open:719:m_do_open - device number: 0 - OK to open
 rdisk.c:m_do_open:728:rcode 0
 rdisk.c:m_do_open:737:Open imagen FD=5
 rdisk.c:m_do_open:754:Aligned Buffer size=4096 on address 1551000, device=0
 rdisk.c:m_do_open:755:Local Buffer 1551000
 rdisk.c:m_do_open:756:Buffer size 4096
 rdisk.c:m_do_open:759:Device 0 is active_flag 1
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:977:img_fd=5 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=1551000 active=1 available=1
 rdisk.c:get_geometry:983:base=0 size=102400000 cyl=97 heads=64 sec=32
 rdisk.c:m_do_open:821:img_fd=5 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=1551000 active=1 available=1
 rdisk.c:m_do_open:823:END m_do_open
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: -2 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=0
DEBUG 597:dvk_send_T:653: endpoint=-2 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=-2, m_type=1030, DEVICE=0, IO_ENDPT=30, POSITION=0, COUNT=0, ADDRESS:0, compress(m2_l2):1231062016
 driver.c:driver_task:140:device_caller= -2, mess.m_source= -2
 driver.c:driver_task:147:m_type: 1030 - DEV_OPEN
 rdisk.c:m_do_open:719:m_do_open - device number: 0 - OK to open
 rdisk.c:m_do_open:728:rcode 0
 rdisk.c:m_do_open:737:Open imagen FD=6
 rdisk.c:m_do_open:754:Aligned Buffer size=4096 on address 1553000, device=0
 rdisk.c:m_do_open:755:Local Buffer 1553000
 rdisk.c:m_do_open:756:Buffer size 4096
 rdisk.c:m_do_open:759:Device 0 is active_flag 1
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:977:img_fd=6 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=1553000 active=1 available=1
 rdisk.c:get_geometry:983:base=0 size=102400000 cyl=97 heads=64 sec=32
 rdisk.c:m_do_open:821:img_fd=6 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=1553000 active=1 available=1
 rdisk.c:m_do_open:823:END m_do_open
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: -2 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=0
DEBUG 597:dvk_send_T:653: endpoint=-2 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=30, m_type=1027, DEVICE=0, IO_ENDPT=30, POSITION=0, COUNT=4096, ADDRESS:47918000, compress(m2_l2):0
 driver.c:driver_task:140:device_caller= 30, mess.m_source= 30
 driver.c:driver_task:164:m_type: 1027 - (DEV_READ= 1027 ? WRITE= 1028)
 driver.c:do_rdwt:267:mp->COUNT=4096
 driver.c:do_rdwt:277:mp->IO_ENDPT=30 - mp->ADDRESS:47918000 - mp->COUNT=4096
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:977:img_fd=6 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=1553000 active=1 available=1
 rdisk.c:get_geometry:983:base=0 size=102400000 cyl=97 heads=64 sec=32
 driver.c:do_rdwt:283:mp->m_type: 1027
 driver.c:do_rdwt:303:opcode: 1033 - DEV_GATHER=1033 - DEV_SCATTER=1032
 rdisk.c:m_transfer:299:m_device: 0
 rdisk.c:m_transfer:312:dv_size: 102400000
 rdisk.c:m_transfer:315:posit: 0
 rdisk.c:m_transfer:316:nr_req: 1
 rdisk.c:m_transfer:326:count: 4096
 rdisk.c:m_transfer:330:user_vir 47918000
 rdisk.c:m_transfer:351:
<DEV_GATHER>
 rdisk.c:m_transfer:357:bytes: 4096
 rdisk.c:m_transfer:361:pread: bytes=4096
DEBUG 597:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
DEBUG 597:dvk_vcopy:89: ioctl ret=4096 errno=0
 rdisk.c:m_transfer:396:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
 rdisk.c:m_transfer:397:bytes= 4096
 rdisk.c:m_transfer:398:DRIVER - Offset (read) 1553000
 rdisk.c:m_transfer:400:user_vir: 47918000 (in proc_nr 30)
 rdisk.c:m_transfer:413:user_vir (do-buffer) 47919000
 rdisk.c:m_transfer:416:count=0 stbytes=4096 position=4096
 rdisk.c:m_transfer:702:subtotal de bytes
 driver.c:do_rdwt:310:mp->m2_l2 =0, buffer_size=0
 driver.c:do_rdwt:311:dr_trasnfer = (r) 4096
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: 30 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=4096
DEBUG 597:dvk_send_T:653: endpoint=30 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
DEBUG 597:dvk_receive_T:677: endpoint=31438 timeout=-1
DEBUG 597:dvk_receive_T:683: ioctl ret=0 errno=0
 driver.c:driver_task:129:
RECEIVE: m_source=30, m_type=1027, DEVICE=0, IO_ENDPT=30, POSITION=0, COUNT=4096, ADDRESS:47919000, compress(m2_l2):0
 driver.c:driver_task:140:device_caller= 30, mess.m_source= 30
 driver.c:driver_task:164:m_type: 1027 - (DEV_READ= 1027 ? WRITE= 1028)
 driver.c:do_rdwt:267:mp->COUNT=4096
 driver.c:do_rdwt:277:mp->IO_ENDPT=30 - mp->ADDRESS:47919000 - mp->COUNT=4096
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:977:img_fd=6 dev_owner=-2 st_size=102400000 st_blksize=4096 localbuff=1553000 active=1 available=1
 rdisk.c:get_geometry:983:base=0 size=102400000 cyl=97 heads=64 sec=32
 driver.c:do_rdwt:283:mp->m_type: 1027
 driver.c:do_rdwt:303:opcode: 1033 - DEV_GATHER=1033 - DEV_SCATTER=1032
 rdisk.c:m_transfer:299:m_device: 0
 rdisk.c:m_transfer:312:dv_size: 102400000
 rdisk.c:m_transfer:315:posit: 0
 rdisk.c:m_transfer:316:nr_req: 1
 rdisk.c:m_transfer:326:count: 4096
 rdisk.c:m_transfer:330:user_vir 47919000
 rdisk.c:m_transfer:351:
<DEV_GATHER>
 rdisk.c:m_transfer:357:bytes: 4096
 rdisk.c:m_transfer:361:pread: bytes=4096
DEBUG 597:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
DEBUG 597:dvk_vcopy:89: ioctl ret=4096 errno=0
 rdisk.c:m_transfer:396:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
 rdisk.c:m_transfer:397:bytes= 4096
 rdisk.c:m_transfer:398:DRIVER - Offset (read) 1553000
 rdisk.c:m_transfer:400:user_vir: 47919000 (in proc_nr 30)
 rdisk.c:m_transfer:413:user_vir (do-buffer) 4791A000
 rdisk.c:m_transfer:416:count=0 stbytes=4096 position=4096
 rdisk.c:m_transfer:702:subtotal de bytes
 driver.c:do_rdwt:310:mp->m2_l2 =0, buffer_size=0
 driver.c:do_rdwt:311:dr_trasnfer = (r) 4096
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: 30 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=4096
DEBUG 597:dvk_send_T:653: endpoint=30 timeout=-1
DEBUG 597:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...
 
 
==============================================================================================
20190602:
		TRATO DE HACER EL MKFS DEL RDISK 
		
UML REPORTA en STDOUT 		
uml_dcid: dcid=0
uml_uml_ep: uml_ep=-2
uml_rd_ep: rd_ep=3
Locating the bottom of the address space ... 0x0
Locating the top of the address space ... 0xc0000000
Core dump limits :
	soft - 0
	hard - NONE
Checking environment variables for a tempdir...none found
Checking if /dev/shm is on tmpfs...OK
Checking PROT_EXEC mmap in /dev/shm...OK
Adding 24932352 bytes to physical memory to account for exec-shield gap
DEBUG start_kernel_proc:90: UML-kernel PID=2 TID=2 uml_ep=-2
DEBUG start_kernel_proc:99: DVK device file successfully opened!! dvk_fd=3

root@node0:~# fsck -v /dev/rdiska 
fsck from util-linux 2.29.2
DEBUG rd_open:669: 
DEBUG rd_open_dev:291: major=3 minor=0
DEBUG rd_open_dev:302: source=1205818468 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1205818368 m2p1=  (null)
DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 2:dvk_sendrec_T:712: ioctl ret=0
DEBUG rd_open_dev:305: source=3 type=68 m2i1=30 m2i2=0 m2i3=0 m2l1=0 m2l2=1205818368 m2p1=  (null)
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47531000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47531000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47530000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47530000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=4753d000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=4753d000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=475ba000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=475ba000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474b5000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474b5000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=4753c000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=4753c000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=476c7000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=476c7000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474bf000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474bf000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474be000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474be000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47fe9000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47fe9000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474b4000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474b4000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47559000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47559000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47558000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47558000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47cc5000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47cc5000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=475fc000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=475fc000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47562000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47562000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474fb000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474fb000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47461000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47461000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474f5000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474f5000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=48028000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=48028000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=4768e000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=4768e000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=474f4000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=474f4000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47463000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47463000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=476c6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=476c6000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=475b5000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=475b5000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47545000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47545000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=475c7000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=475c7000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=475bb000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=475bb000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47ff3000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47ff3000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47cc3000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47cc3000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47ca9000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47ca9000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47690000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47690000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=475b3000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=475b3000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47518000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47518000
DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47ca6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=47ca6000

ESTA ES LA ULTIMA PETICION RECIBIDA POR RDISK (VER ABAJO) 
	DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
	DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=4760e000
	DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
	DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
	DEBUG rdisk_rw:892: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=0 m2l2=0 m2p1=4760e000
ESTA ULTIMA PETICION NO LLEGA 
	DEBUG do_rdisk:909: op=0 offset=0 length=4096 sectorsize=512 error=0
	DEBUG rdisk_rw:889: source=3 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=0 m2l2=0 m2p1=47608000

RDISK REGISTRA 
	<DEV_GATHER>
	 rdisk.c:m_transfer:349:bytes: 4096
	 rdisk.c:m_transfer:353:pread: bytes=4096
	DEBUG 590:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
	DEBUG 590:dvk_vcopy:89: ioctl ret=4096 errno=0
	 rdisk.c:m_transfer:388:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
	 rdisk.c:m_transfer:389:bytes= 4096
	 rdisk.c:m_transfer:390:DRIVER - Offset (read) 767000
	 rdisk.c:m_transfer:392:user_vir: 4760E000 (in proc_nr 30)
	 rdisk.c:m_transfer:405:user_vir (do-buffer) 4760F000
	 rdisk.c:m_transfer:408:count=0 stbytes=4096 position=4096
	 rdisk.c:m_transfer:694:subtotal de bytes
	 driver.c:do_rdwt:310:mp->m2_l2 =0, buffer_size=0
	 driver.c:do_rdwt:311:dr_trasnfer = (r) 4096
	 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: 30 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=4096
	DEBUG 590:dvk_send_T:653: endpoint=30 timeout=-1
	DEBUG 590:dvk_send_T:659: ioctl ret=76 errno=0
	 driver.c:driver_task:114:M3-IPC Listening ...

EL DVK NO REGISTRA NINGUN CAMBIO DE ESTADO DEL PROCESO ENPOINT 30
	root@node0:/usr/src/dvs/vos/mol/drivers/rdisk# cat /proc/dvs/DC0/procs 
	DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
	 0  -2    -2   608/2      0    0   20 27342 27342 27342 27342 linux          
	 0   3     3   590/590    0    8   20 31438 27342 27342 27342 rdisk          
	 0  30    30   616/10     0    0   20 27342 27342 27342 27342 linux 

DMESG 
UML_RDISK sendrec 
[  130.393591] DEBUG dvk_ioctl:201: cmd=4004E305 arg=47D4CF20
[  130.393592] DEBUG dvk_ioctl:221: DVK_CALL=5 (mini_sendrec) 
[  130.393593] DEBUG io_mini_sendrec:56: 
[  130.393594] DEBUG new_mini_sendrec:507: srcdst_ep=3
[  130.393595] DEBUG check_caller:536: caller_pid=616 caller_tgid=616
[  130.393596] DEBUG check_caller:572: WLOCK_PROC ep=30 count=0
[  130.393597] DEBUG check_caller:601: WUNLOCK_PROC ep=30 count=0
[  130.393598] DEBUG check_caller:604: dcid=0
[  130.393599] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[  130.393600] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[  130.393601] DEBUG check_caller:618: caller_pid=616 
[  130.393602] DEBUG new_mini_sendrec:518: RLOCK_PROC ep=30 count=0
[  130.393604] DEBUG new_mini_sendrec:523: caller_nr=30 caller_ep=30 srcdst_ep=3 
[  130.393605] DEBUG new_mini_sendrec:526: RUNLOCK_PROC ep=30 count=0
[  130.393606] DEBUG new_mini_sendrec:528: dcid=0
[  130.393607] DEBUG new_mini_sendrec:532: RLOCK_DC dc=0 count=0
[  130.393608] DEBUG new_mini_sendrec:535: RUNLOCK_DC dc=0 count=0
[  130.393609] DEBUG new_mini_sendrec:550: WLOCK_PROC ep=30 count=0
[  130.393610] DEBUG new_mini_sendrec:557: WUNLOCK_PROC ep=30 count=0
[  130.393611] DEBUG new_mini_sendrec:557: WLOCK_PROC ep=3 count=0
[  130.393612] DEBUG new_mini_sendrec:557: WLOCK_PROC ep=30 count=0
[  130.393613] DEBUG new_mini_sendrec:558: srcdst_nr=3 srcdst_ep=3
[  130.393614] DEBUG new_mini_sendrec:578: srcdst_ptr->p_usr.p_nodeid=0
[  130.393615] DEBUG new_mini_sendrec:582: RLOCK_DC dc=0 count=0
[  130.393616] DEBUG new_mini_sendrec:586: RUNLOCK_DC dc=0 count=0
[  130.393618] DEBUG new_mini_sendrec:601: dcid=0 caller_pid=616 caller_nr=30 srcdst_ep=3 
[  130.393618] DEBUG new_mini_sendrec:606: SENDING HALF
[  130.393619] DEBUG new_mini_sendrec:687: destination is waiting. Copy the message and wakeup destination
[  130.393621] DEBUG copy_usr2usr:886: rqtr_ep=30 src_ep=30 src_lpid=616 src_vpid=10 src_addr=47d4cf4c
[  130.393623] DEBUG copy_usr2usr:889: dst_ep=3 dst_lpid=590 dst_vpid=590 dst_addr=bf8842d8 bytes=76
[  130.393624] DEBUG copy_usr2usr:893: task_pid_nr(current)=616
[  130.393624] DEBUG copy_usr2usr:896: WRITE
[  130.393625] DEBUG copy_usr2usr:901: task_pid_nr(dst_ptr->p_task)=590
[  130.393627] DEBUG dvk_vm_rw:441: pid=590 liovcnt=1 riovcnt=1 flags=0 vm_write=1
[  130.393628] DEBUG dvk_check_iovect:1280: type=1 nr_segs=1
[  130.393629] DEBUG dvk_rw_check_kvector:862: type=1 nr_segs=1
[  130.393630] DEBUG dvk_rw_check_kvector:862: type=-1 nr_segs=1
[  130.393631] DEBUG dvk_vm_rw_core:277: pid=590 riovcnt=1 flags=0 vm_write=1
[  130.393633] DEBUG dvk_vm_rw_core:331: i=0 rc=0
[  130.393640] DEBUG dvk_vm_rw_core:349: rc=76
[  130.393641] DEBUG dvk_vm_rw_core:356: rc=76
[  130.393642] DEBUG copy_usr2usr:954: len=76
[  130.393643] DEBUG inherit_cpu:288: cpuid=0 vpid=ld
[  130.393645] ERROR: 616:inherit_cpu:292: rcode=-3
[  130.393647] DEBUG inherit_cpu:296: nr=3 endp=3 dcid=0 lpid=590 p_cpumask=FFFFFFFF nodemap=1 name=rdisk 
[  130.393648] DEBUG new_mini_sendrec:693: BEFORE UP lpid=590 p_sem=-1 rcode=76
[  130.393652] DEBUG new_mini_sendrec:701: WUNLOCK_PROC ep=3 count=0
[  130.393653] DEBUG sleep_proc:344: timeout=30000
[  130.393655] DEBUG sleep_proc:355: BEFORE DOWN lpid=616 p_sem=0 timeout=30000
[  130.393656] DEBUG sleep_proc:357: endpoint=30 flags=8
[  130.393657] DEBUG sleep_proc:361: WUNLOCK_PROC ep=30 count=0
[  130.393662] DEBUG sleep_proc:368: endpoint=3 ret=0 p_rcode=76

RDISK se despierta 
[  130.393663] DEBUG sleep_proc:369: endpoint=3 flags=0 cpuid=0
[  130.393664] DEBUG sleep_proc:370: WLOCK_PROC ep=3 count=0
[  130.393666] DEBUG sleep_proc:417: nr=3 endp=3 dcid=0 lpid=590 p_cpumask=FFFFFFFF nodemap=1 name=rdisk 
[  130.393667] DEBUG sleep_proc:419: someone wakeups me: sem=0 p_rcode=0
[  130.393668] DEBUG new_mini_receive:488: WUNLOCK_PROC ep=3 count=0

RDISK hace VCOPY 
[  130.393829] DEBUG dvk_ioctl:201: cmd=4004E30D arg=BF884174
[  130.393830] DEBUG dvk_ioctl:221: DVK_CALL=13 (vcopy) 
[  130.393831] DEBUG io_vcopy:142: 
[  130.393833] DEBUG new_vcopy:1049: src_ep=3 dst_ep=30 bytes=4096
[  130.393835] DEBUG check_caller:536: caller_pid=590 caller_tgid=590
[  130.393836] DEBUG check_caller:572: WLOCK_PROC ep=3 count=0
[  130.393837] DEBUG check_caller:601: WUNLOCK_PROC ep=3 count=0
[  130.393838] DEBUG check_caller:604: dcid=0
[  130.393839] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[  130.393840] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[  130.393841] DEBUG check_caller:618: caller_pid=590 
[  130.393842] DEBUG new_vcopy:1063: RLOCK_PROC ep=3 count=0
[  130.393843] DEBUG new_vcopy:1084: dcid=0
[  130.393844] DEBUG new_vcopy:1089: RUNLOCK_PROC ep=3 count=0
[  130.393845] DEBUG new_vcopy:1091: RLOCK_DC dc=0 count=0
[  130.393846] DEBUG new_vcopy:1117: LOCK PROCESSES IN ASCENDENT ORDER
[  130.393847] DEBUG new_vcopy:1122: WLOCK_PROC ep=3 count=0
[  130.393848] DEBUG new_vcopy:1122: WLOCK_PROC ep=30 count=0
[  130.393849] DEBUG new_vcopy:1128: CHECK FOR SOURCE/DESTINATION STATUS
[  130.393850] DEBUG new_vcopy:1210: RUNLOCK_DC dc=0 count=0
[  130.393851] DEBUG new_vcopy:1227: CALLER dcid=0 caller_pid=590 caller_nr=3 caller_ep=3 
[  130.393852] DEBUG new_vcopy:1233: CALLER p_endpoint=3 
[  130.393853] DEBUG new_vcopy:1234: SOURCE p_endpoint=3 
[  130.393854] DEBUG new_vcopy:1235: DESTIN p_endpoint=30 
[  130.393855] DEBUG new_vcopy:1236: BYTES  bytes	=4096 
[  130.393856] DEBUG new_vcopy:1246: src_pid=590 src_tgid=590 dst_pid=616 dst_tgid=616
[  130.393857] DEBUG new_vcopy:1254: COPY_USR2USR_PROC copylen=4096
[  130.393859] DEBUG copy_usr2usr:886: rqtr_ep=27342 src_ep=3 src_lpid=590 src_vpid=590 src_addr=00767000
[  130.393861] DEBUG copy_usr2usr:889: dst_ep=30 dst_lpid=616 dst_vpid=10 dst_addr=4760e000 bytes=4096
[  130.393862] DEBUG copy_usr2usr:893: task_pid_nr(current)=590
[  130.393862] DEBUG copy_usr2usr:896: WRITE
[  130.393863] DEBUG copy_usr2usr:901: task_pid_nr(dst_ptr->p_task)=616
[  130.393865] DEBUG dvk_vm_rw:441: pid=616 liovcnt=1 riovcnt=1 flags=0 vm_write=1
[  130.393866] DEBUG dvk_check_iovect:1280: type=1 nr_segs=1
[  130.393867] DEBUG dvk_rw_check_kvector:862: type=1 nr_segs=1
[  130.393868] DEBUG dvk_rw_check_kvector:862: type=-1 nr_segs=1
[  130.393870] DEBUG dvk_vm_rw_core:277: pid=616 riovcnt=1 flags=0 vm_write=1
[  130.393871] DEBUG dvk_vm_rw_core:331: i=0 rc=0
[  130.393880] DEBUG dvk_vm_rw_core:349: rc=4096
[  130.393881] DEBUG dvk_vm_rw_core:356: rc=4096
[  130.393882] DEBUG copy_usr2usr:954: len=4096
[  130.393883] DEBUG new_vcopy:1508: WUNLOCK_PROC ep=30 count=0
[  130.393884] DEBUG new_vcopy:1515: WUNLOCK_PROC ep=3 count=0

RDISK RESPONDE SEND 
[  130.393968] DEBUG dvk_ioctl:201: cmd=4004E302 arg=BF884290
[  130.393969] DEBUG dvk_ioctl:221: DVK_CALL=2 (mini_send) 
[  130.393970] DEBUG io_mini_send:24: 
[  130.393971] DEBUG new_mini_send:39: dst_ep=30
[  130.393973] DEBUG check_caller:536: caller_pid=590 caller_tgid=590
[  130.393974] DEBUG check_caller:572: WLOCK_PROC ep=3 count=0
[  130.393975] DEBUG check_caller:601: WUNLOCK_PROC ep=3 count=0
[  130.393976] DEBUG check_caller:604: dcid=0
[  130.393977] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[  130.393978] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[  130.393979] DEBUG check_caller:618: caller_pid=590 
[  130.393980] DEBUG new_mini_send:51: RLOCK_PROC ep=3 count=0
[  130.393981] DEBUG new_mini_send:55: caller_nr=3 caller_ep=3 dst_ep=30 
[  130.393982] DEBUG new_mini_send:58: RUNLOCK_PROC ep=3 count=0
[  130.393983] DEBUG new_mini_send:60: dcid=0
[  130.393984] DEBUG new_mini_send:64: RLOCK_DC dc=0 count=0
[  130.393985] DEBUG new_mini_send:67: RUNLOCK_DC dc=0 count=0
[  130.393986] DEBUG new_mini_send:82: WLOCK_PROC ep=3 count=0
[  130.393987] DEBUG new_mini_send:86: WLOCK_PROC ep=30 count=0
[  130.393989] DEBUG new_mini_send:90: dst_nr=30 dst_ep=30
[  130.393989] DEBUG new_mini_send:109: dst_ptr->p_usr.p_nodeid=0
[  130.393990] DEBUG new_mini_send:113: RLOCK_DC dc=0 count=0
[  130.393992] DEBUG new_mini_send:117: RUNLOCK_DC dc=0 count=0
[  130.393993] DEBUG new_mini_send:132: dcid=0 caller_pid=590 caller_nr=3 dst_ep=30 
[  130.393994] DEBUG new_mini_send:210: destination is waiting. Copy the message and wakeup destination
[  130.393996] DEBUG copy_usr2usr:886: rqtr_ep=3 src_ep=3 src_lpid=590 src_vpid=590 src_addr=bf8842d8
[  130.393997] DEBUG copy_usr2usr:889: dst_ep=30 dst_lpid=616 dst_vpid=10 dst_addr=47d4cf4c bytes=76
[  130.393998] DEBUG copy_usr2usr:893: task_pid_nr(current)=590
[  130.393999] DEBUG copy_usr2usr:896: WRITE
[  130.394000] DEBUG copy_usr2usr:901: task_pid_nr(dst_ptr->p_task)=616
[  130.394002] DEBUG dvk_vm_rw:441: pid=616 liovcnt=1 riovcnt=1 flags=0 vm_write=1
[  130.394003] DEBUG dvk_check_iovect:1280: type=1 nr_segs=1
[  130.394004] DEBUG dvk_rw_check_kvector:862: type=1 nr_segs=1
[  130.394005] DEBUG dvk_rw_check_kvector:862: type=-1 nr_segs=1
[  130.394006] DEBUG dvk_vm_rw_core:277: pid=616 riovcnt=1 flags=0 vm_write=1
[  130.394009] DEBUG dvk_vm_rw_core:331: i=0 rc=0
[  130.394031] DEBUG dvk_vm_rw_core:349: rc=76
[  130.394032] DEBUG dvk_vm_rw_core:356: rc=76
[  130.394033] DEBUG copy_usr2usr:954: len=76
[  130.394034] DEBUG inherit_cpu:288: cpuid=0 vpid=ld
[  130.394036] ERROR: 590:inherit_cpu:292: rcode=-22
[  130.394038] DEBUG inherit_cpu:296: nr=30 endp=30 dcid=0 lpid=616 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[  130.394039] DEBUG new_mini_send:221: BEFORE UP lpid=616 p_sem=-1 rcode=76
[  130.394040] DEBUG new_mini_send:222: WUNLOCK_PROC ep=30 count=0
[  130.394042] DEBUG new_mini_send:257: WUNLOCK_PROC ep=3 count=0

RDISK LLAMA A RECEIVE PARA ESPERAR NUEVA PETICION   
[  130.394059] DEBUG dvk_ioctl:201: cmd=4004E303 arg=BF884290
[  130.394060] DEBUG dvk_ioctl:221: DVK_CALL=3 (mini_receive) 
[  130.394061] DEBUG io_mini_receive:35: 
[  130.394062] DEBUG new_mini_receive:288: src_ep=31438
[  130.394063] DEBUG check_caller:536: caller_pid=590 caller_tgid=590
[  130.394065] DEBUG check_caller:572: WLOCK_PROC ep=3 count=0
[  130.394066] DEBUG check_caller:601: WUNLOCK_PROC ep=3 count=0
[  130.394066] DEBUG check_caller:604: dcid=0
[  130.394067] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[  130.394069] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[  130.394070] DEBUG check_caller:618: caller_pid=590 
[  130.394071] DEBUG new_mini_receive:299: RLOCK_PROC ep=3 count=0
[  130.394072] DEBUG new_mini_receive:303: caller_nr=3 caller_ep=3 src_ep=31438 
[  130.394073] DEBUG new_mini_receive:307: dcid=0
[  130.394074] DEBUG new_mini_receive:311: RUNLOCK_PROC ep=3 count=0
[  130.394075] DEBUG new_mini_receive:313: RLOCK_DC dc=0 count=0
[  130.394076] DEBUG new_mini_receive:316: RUNLOCK_DC dc=0 count=0
[  130.394077] DEBUG new_mini_receive:366: WLOCK_PROC ep=3 count=0
[  130.394078] DEBUG new_mini_receive:471: Any suitable message from 31438 was not found.
[  130.394079] DEBUG sleep_proc:344: timeout=-1
[  130.394080] DEBUG sleep_proc:355: BEFORE DOWN lpid=590 p_sem=0 timeout=-1
[  130.394081] DEBUG sleep_proc:357: endpoint=3 flags=8
[  130.394082] DEBUG sleep_proc:361: WUNLOCK_PROC ep=3 count=0

UML_RDISK SE DESPIERTA 
[  130.399365] DEBUG sleep_proc:368: endpoint=30 ret=7500 p_rcode=76
[  130.399369] DEBUG sleep_proc:369: endpoint=30 flags=0 cpuid=0
[  130.399371] DEBUG sleep_proc:370: WLOCK_PROC ep=30 count=0
[  130.399374] DEBUG sleep_proc:417: nr=30 endp=30 dcid=0 lpid=616 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[  130.399375] DEBUG sleep_proc:419: someone wakeups me: sem=0 p_rcode=0
[  130.399377] DEBUG new_mini_sendrec:748: WUNLOCK_PROC ep=30 count=0

[  130.404119] systemd-journald[181]: /dev/kmsg buffer overrun, some messages lost. ???????????? 

---------------------------------------------------------------------------

DVK: old_exit_unbind code:0
[  OK  ] Started Permit User Sessions.
[  OK  ] Started Getty on tty3.
[  OK  ] Started Getty on tty6.
[  OK  ] Started Getty on tty1.
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
[  OK  ] Started Getty on tty5.
[  OK  ] Started Getty on tty2.
[  OK  ] Started Getty on tty4.
[  OK  ] Reached target Login Prompts.
[  OK  ] Reached target Multi-User System.
[  OK  ] Reached target Graphical Interface.
winch_thread : TIOCSCTTY failed on fd 1 err = 1

Debian GNU/Linux 9 node0 tty1

node0 login: 
Debian GNU/Linux 9 node0 tty1

node0 login: root
Password: 
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
Linux node0 4.9.88 #15 Sun Jun 2 21:55:52 -03 2019 i686

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

ATENCION !!! EL FSCK FUNCION OK!!!!!!


ror=0
                                  134217728
DEBUG rd_thread:1019: op=0 offset=133914624 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133914624 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133914624
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133914624 m2l2=0 m2p1=4760e000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133914624 m2l2=0 m2p1=4760e000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133914624
DEBUG rd_prepare_request:720: op=0 offset=133869568 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=133869568 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133869568 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133869568
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133869568 m2l2=0 m2p1=47599000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133869568 m2l2=0 m2p1=47599000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133869568
DEBUG rd_prepare_request:720: op=0 offset=133840896 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=133840896 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133840896 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133840896
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133840896 m2l2=0 m2p1=47658000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133840896 m2l2=0 m2p1=47658000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133840896
DEBUG rd_prepare_request:720: op=0 offset=133750784 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=133750784 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133750784 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133750784
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133750784 m2l2=0 m2p1=47642000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133750784 m2l2=0 m2p1=47642000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133750784
DEBUG rd_prepare_request:720: op=0 offset=133718016 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=133718016 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133718016 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133718016
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133718016 m2l2=0 m2p1=47466000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133718016 m2l2=0 m2p1=47466000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133718016
DEBUG rd_prepare_request:720: op=0 offset=133709824 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=133709824 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133709824 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133709824
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133709824 m2l2=0 m2p1=47661000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133709824 m2l2=0 m2p1=47661000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133709824
DEBUG rd_prepare_request:720: op=0 offset=133730304 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=133730304 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=133730304 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=133730304
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133730304 m2l2=0 m2p1=47fe6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133730304 m2l2=0 m2p1=47fe6000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=133730304
DEBUG rd_prepare_request:720: op=0 offset=132636672 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=132636672 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=132636672 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=132636672
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=132636672 m2l2=0 m2p1=47648000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=132636672 m2l2=0 m2p1=47648000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=132636672
DEBUG rd_prepare_request:720: op=0 offset=1048576 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=1048576 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=1048576 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=1048576
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=1048576 m2l2=0 m2p1=47641000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=1048576 m2l2=0 m2p1=47641000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=1048576
DEBUG rd_prepare_request:720: op=0 offset=12288 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=12288 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=12288 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=12288
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=12288 m2l2=0 m2p1=47638000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=12288 m2l2=0 m2p1=47638000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=12288
DEBUG rd_prepare_request:720: op=0 offset=28672 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=28672 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=28672 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=28672
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=28672 m2l2=0 m2p1=474ea000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=28672 m2l2=0 m2p1=474ea000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=28672
DEBUG rd_prepare_request:720: op=0 offset=61440 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=61440 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=61440 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=61440
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=61440 m2l2=0 m2p1=47fa6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=61440 m2l2=0 m2p1=47fa6000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=61440
DEBUG rd_prepare_request:720: op=0 offset=8192 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=8192 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=8192 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=8192
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=8192 m2l2=0 m2p1=47586000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=8192 m2l2=0 m2p1=47586000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=8192
DEBUG rd_prepare_request:720: op=0 offset=16384 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=16384 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=16384 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=16384
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=16384 m2l2=0 m2p1=4754b000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=16384 m2l2=0 m2p1=4754b000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=16384
DEBUG rd_prepare_request:720: op=0 offset=20480 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=20480 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=20480 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=20480
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=20480 m2l2=0 m2p1=4757e000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=20480 m2l2=0 m2p1=4757e000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=20480
DEBUG rd_prepare_request:720: op=0 offset=24576 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=24576 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=24576 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=24576
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=24576 m2l2=0 m2p1=47662000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=24576 m2l2=0 m2p1=47662000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=24576
DEBUG rd_prepare_request:720: op=0 offset=32768 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=32768 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=32768 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=32768
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=32768 m2l2=0 m2p1=47cb1000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=32768 m2l2=0 m2p1=47cb1000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=32768
DEBUG rd_prepare_request:720: op=0 offset=36864 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=36864 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=36864 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=36864
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=36864 m2l2=0 m2p1=47ca6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=36864 m2l2=0 m2p1=47ca6000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=36864
DEBUG rd_prepare_request:720: op=0 offset=40960 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=40960 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=40960 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=40960
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=40960 m2l2=0 m2p1=47675000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=40960 m2l2=0 m2p1=47675000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=40960
DEBUG rd_prepare_request:720: op=0 offset=45056 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=45056 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=45056 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=45056
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=45056 m2l2=0 m2p1=47666000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=45056 m2l2=0 m2p1=47666000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=45056
DEBUG rd_prepare_request:720: op=0 offset=49152 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=49152 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=49152 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=49152
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=49152 m2l2=0 m2p1=47655000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=49152 m2l2=0 m2p1=47655000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=49152
DEBUG rd_prepare_request:720: op=0 offset=53248 length=4096 sectorsize=512 error=0
DEBUG rd_prepare_request:720: op=0 offset=57344 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=53248 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=53248 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=53248
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=53248 m2l2=0 m2p1=47549000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=53248 m2l2=0 m2p1=47549000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=53248
DEBUG rd_prepare_request:720: op=0 offset=65536 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=57344 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=57344 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=57344
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=57344 m2l2=0 m2p1=48032000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=57344 m2l2=0 m2p1=48032000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=57344
DEBUG rd_prepare_request:720: op=0 offset=69632 length=8192 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=65536 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=65536 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=65536
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=65536 m2l2=0 m2p1=48033000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=65536 m2l2=0 m2p1=48033000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=65536
DEBUG rd_prepare_request:720: op=0 offset=77824 length=8192 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=69632 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=69632 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=69632
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=69632 m2l2=0 m2p1=474c6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=69632 m2l2=0 m2p1=474c6000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=69632
DEBUG rd_thread:1019: op=0 offset=77824 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=77824 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=77824
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=77824 m2l2=0 m2p1=47cb4000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=77824 m2l2=0 m2p1=47cb4000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=77824
DEBUG rd_prepare_request:720: op=0 offset=86016 length=8192 sectorsize=512 error=0
DEBUG rd_prepare_request:720: op=0 offset=94208 length=8192 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=86016 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=86016 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=86016
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=86016 m2l2=0 m2p1=474f6000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=86016 m2l2=0 m2p1=474f6000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=86016
DEBUG rd_prepare_request:720: op=0 offset=102400 length=8192 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=94208 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=94208 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=94208
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=94208 m2l2=0 m2p1=47560000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=94208 m2l2=0 m2p1=47560000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=94208
DEBUG rd_prepare_request:720: op=0 offset=110592 length=8192 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=102400 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=102400 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=102400
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=102400 m2l2=0 m2p1=4759a000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=102400 m2l2=0 m2p1=4759a000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=102400
DEBUG rd_thread:1019: op=0 offset=110592 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=110592 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=110592
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=110592 m2l2=0 m2p1=4766a000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_prepare_request:720: op=0 offset=118784 length=8192 sectorsize=512 error=0
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=110592 m2l2=0 m2p1=4766a000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=110592
DEBUG rd_thread:1019: op=0 offset=118784 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=118784 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=118784
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=118784 m2l2=0 m2p1=474c2000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_prepare_request:720: op=0 offset=126976 length=8192 sectorsize=512 error=0
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=118784 m2l2=0 m2p1=474c2000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=118784
DEBUG rd_prepare_request:720: op=0 offset=135168 length=4096 sectorsize=512 error=0
DEBUG rd_thread:1019: op=0 offset=126976 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=126976 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=126976
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=126976 m2l2=0 m2p1=474b2000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=126976 m2l2=0 m2p1=474b2000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=126976
DEBUG rd_thread:1019: op=0 offset=135168 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=135168 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=135168
DEBUG rdisk_rw:891: source=1 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=135168 m2l2=0 m2p1=48002000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=135168 m2l2=0 m2p1=48002000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=135168
systemd-journald[356]: /dev/kmsg buffer overrun, some messages lost.
DEBUG rd_prepare_request:720: op=0 offset=139264 length=4096 sectorsize=512 error=0

======================>> 4096
DEBUG rd_thread:1019: op=0 offset=139264 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=139264 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=8 len=4096
DEBUG do_rdisk:925: start_sec=0 end_sec=8 len=4096 off=139264
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=139264 m2l2=0 m2p1=48003000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=139264 m2l2=0 m2p1=48003000
DEBUG do_rdisk:946: start_sec=8 minor=0 len=0 off=139264
DEBUG rd_prepare_request:720: op=0 offset=143360 length=8192 sectorsize=512 error=0

======================>> 8192
DEBUG rd_thread:1019: op=0 offset=143360 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=143360 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=143360
DEBUG rdisk_rw:891: source=0 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=143360 m2l2=0 m2p1=475ba000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=143360 m2l2=0 m2p1=475ba000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=143360DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=200704 m2l2=0 m2p1=474f0000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=200704

DEBUG rd_thread:1019: op=0 offset=208896 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=208896 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=208896
DEBUG rdisk_rw:891: source=1 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=208896 m2l2=0 m2p1=474b4000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=208896 m2l2=0 m2p1=474b4000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=208896

DEBUG rd_thread:1019: op=0 offset=217088 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=217088 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=217088
DEBUG rdisk_rw:891: source=1 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=217088 m2l2=0 m2p1=4762c000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=217088 m2l2=0 m2p1=4762c000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=217088

DEBUG rd_thread:1019: op=0 offset=225280 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=225280 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=225280
DEBUG rdisk_rw:891: source=1 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=225280 m2l2=0 m2p1=47596000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=225280 m2l2=0 m2p1=47596000
DEBUG do_rdisk:946: start_sec=16 minor=0 len=0 off=225280

DEBUG rd_thread:1019: op=0 offset=233472 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=233472 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=16 len=8192
DEBUG do_rdisk:925: start_sec=0 end_sec=16 len=8192 off=233472
DEBUG rdisk_rw:891: source=1 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=233472 m2l2=0 m2p1=47708000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0

==============================================================================================
20190602:
		en FSCK 
		
UML entra en LOOP y el ultimo mensaje intercambiado con RDISK es este 
		
DEBUG rd_thread:1019: op=0 offset=229376 length=16384 sectorsize=512 error=0
DEBUG do_rdisk:911: op=0 offset=229376 length=16384 sectorsize=512 error=0
DEBUG do_rdisk:918: minor=0 nsectors=32 len=16384
DEBUG do_rdisk:925: start_sec=0 end_sec=32 len=16384 off=229376
DEBUG rdisk_rw:891: source=1 type=1027 m2i1=0 m2i2=30 m2i3=16384 m2l1=229376 m2l2=0 m2p1=4886c000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:894: source=3 type=68 m2i1=30 m2i2=16384 m2i3=16384 m2l1=229376 m2l2=0 m2p1=4886c000

RDISK RECIBE Y ATIENDE CORRECTAMENTE EL MENSAJE
RECEIVE: m_source=30, m_type=1027, DEVICE=0, IO_ENDPT=30, POSITION=38000, COUNT=16384, ADDRESS:4886C000, compress(m2_l2):0
 driver.c:driver_task:140:device_caller= 30, mess.m_source= 30
 driver.c:driver_task:164:m_type: 1027 - (DEV_READ= 1027 ? WRITE= 1028)
 driver.c:do_rdwt:267:mp->COUNT=16384
 driver.c:do_rdwt:277:mp->IO_ENDPT=30 - mp->ADDRESS:4886C000 - mp->COUNT=16384
 rdisk.c:m_prepare:262:device = 0
 rdisk.c:get_geometry:969:img_fd=6 dev_owner=-2 st_size=134217728 st_blksize=4096 localbuff=1AB9000 active=1 available=1
 rdisk.c:get_geometry:977:base=0 size=134217728 cyl=128 heads=64 sec=32
 driver.c:do_rdwt:283:mp->m_type: 1027
 driver.c:do_rdwt:303:opcode: 1033 - DEV_GATHER=1033 - DEV_SCATTER=1032
 rdisk.c:m_transfer:299:m_device: 0
 rdisk.c:m_transfer:312:dv_size: 134217728
 rdisk.c:m_transfer:315:posit: 38000
 rdisk.c:m_transfer:316:nr_req: 1
 rdisk.c:m_transfer:322:count: 16384
 rdisk.c:m_transfer:326:user_vir 4886C000
 rdisk.c:m_transfer:343:
<DEV_GATHER>
 rdisk.c:m_transfer:349:bytes: 4096
 rdisk.c:m_transfer:353:pread: bytes=4096
DEBUG 617:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
DEBUG 617:dvk_vcopy:89: ioctl ret=4096 errno=0
 rdisk.c:m_transfer:388:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
 rdisk.c:m_transfer:389:bytes= 4096
 rdisk.c:m_transfer:390:DRIVER - Offset (read) 1AB9000
 rdisk.c:m_transfer:392:user_vir: 4886C000 (in proc_nr 30)
 rdisk.c:m_transfer:405:user_vir (do-buffer) 4886D000
 rdisk.c:m_transfer:408:count=12288 stbytes=4096 position=233472
 rdisk.c:m_transfer:349:bytes: 4096
 rdisk.c:m_transfer:353:pread: bytes=4096
DEBUG 617:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
DEBUG 617:dvk_vcopy:89: ioctl ret=4096 errno=0
 rdisk.c:m_transfer:388:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
 rdisk.c:m_transfer:389:bytes= 4096
 rdisk.c:m_transfer:390:DRIVER - Offset (read) 1AB9000
 rdisk.c:m_transfer:392:user_vir: 4886D000 (in proc_nr 30)
 rdisk.c:m_transfer:405:user_vir (do-buffer) 4886E000
 rdisk.c:m_transfer:408:count=8192 stbytes=8192 position=237568
 rdisk.c:m_transfer:349:bytes: 4096
 rdisk.c:m_transfer:353:pread: bytes=4096
DEBUG 617:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
DEBUG 617:dvk_vcopy:89: ioctl ret=4096 errno=0
 rdisk.c:m_transfer:388:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
 rdisk.c:m_transfer:389:bytes= 4096
 rdisk.c:m_transfer:390:DRIVER - Offset (read) 1AB9000
 rdisk.c:m_transfer:392:user_vir: 4886E000 (in proc_nr 30)
 rdisk.c:m_transfer:405:user_vir (do-buffer) 4886F000
 rdisk.c:m_transfer:408:count=4096 stbytes=12288 position=241664
 rdisk.c:m_transfer:349:bytes: 4096
 rdisk.c:m_transfer:353:pread: bytes=4096
DEBUG 617:dvk_vcopy:80: src_ep=3 dst_ep=30 bytes=4096
DEBUG 617:dvk_vcopy:89: ioctl ret=4096 errno=0
 rdisk.c:m_transfer:388:DRIVER: dvk_vcopy(DRIVER -> proc_nr) rcode=4096
 rdisk.c:m_transfer:389:bytes= 4096
 rdisk.c:m_transfer:390:DRIVER - Offset (read) 1AB9000
 rdisk.c:m_transfer:392:user_vir: 4886F000 (in proc_nr 30)
 rdisk.c:m_transfer:405:user_vir (do-buffer) 48870000
 rdisk.c:m_transfer:408:count=0 stbytes=16384 position=245760
 rdisk.c:m_transfer:694:subtotal de bytes
 driver.c:do_rdwt:310:mp->m2_l2 =0, buffer_size=0
 driver.c:do_rdwt:311:dr_trasnfer = (r) 16384
 driver.c:driver_task:230:SEND msg a DEVICE_CALLER: 30 -> m_type=68, (REP_ENDPT)=30, (REP_STATUS)=16384
DEBUG 617:dvk_send_T:653: endpoint=30 timeout=-1
DEBUG 617:dvk_send_T:659: ioctl ret=76 errno=0
 driver.c:driver_task:114:M3-IPC Listening ...



==============================================================================================
20190603:		FUNCIONO EL FSCK Y MOUNT !!!

			root@node0:~# mount
			/dev/ubda on / type ext2 (ro,relatime,block_validity,barrier,user_xattr)
			devtmpfs on /dev type devtmpfs (rw,relatime,mode=755)
			.......
			mqueue on /dev/mqueue type mqueue (rw,relatime)
			/dev/rdiska on /mnt type ext2 (rw,relatime,block_validity,barrier,user_xattr

			root@node0:~# ls -l /mnt
			total 63708
			-rw------- 1 root root      793 Jun  2 15:24 debug.h
			-rw-r--r-- 1 root root 10485760 Jun  2 15:24 file10M.txt
			-rw-r--r-- 1 root root 52428800 Jun  2 15:24 file50M.txt
			-rw------- 1 root root   103630 Jun  2 15:24 index.html
			-rw-r--r-- 1 root root  1377610 Jun  2 15:24 index.mht
			drwx------ 2 root root    12288 Jun  2 15:21 lost+found
			-rw------- 1 root root      984 Jun  2 15:24 macros.h
			-rw-r--r-- 1 root root   100000 Jun  2 15:24 muk.txt
			-rw-r--r-- 1 root root   320742 Jun  2 15:24 test.tar.gz
			-rw-r--r-- 1 root root   142097 Jun  2 15:24 test.z


DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133799936 length=24576 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133799936 length=24576 sectorsize=512 error=0
DEBUG do_rdisk:970: len=24576 off=133799936
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=24576 m2l1=133799936 m2l2=0 m2p1=48b08000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=24576 m2i3=24576 m2l1=133799936 m2l2=0 m2p1=48b08000
DEBUG do_rdisk:995: minor=0 len=0 off=133799936
systemd-journald[360]: /dev/kmsg buffer overrun, some messages lost.
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=16384
DEBUG rd_prepare_request:763: op=0 offset=133824512 length=16384 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133824512 length=16384 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133824512 length=16384 sectorsize=512 error=0
DEBUG do_rdisk:970: len=16384 off=133824512
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=16384 m2l1=133824512 m2l2=0 m2p1=48b0e000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=16384 m2i3=16384 m2l1=133824512 m2l2=0 m2p1=48b0e000
DEBUG do_rdisk:995: minor=0 len=0 off=133824512
DEBUG rd_prepare_request:753: len=24576
DEBUG rd_prepare_request:763: op=0 offset=133844992 length=24576 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133844992 length=24576 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133844992 length=24576 sectorsize=512 error=0
DEBUG do_rdisk:970: len=24576 off=133844992
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=24576 m2l1=133844992 m2l2=0 m2p1=48b12000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=24576 m2i3=24576 m2l1=133844992 m2l2=0 m2p1=48b12000
DEBUG do_rdisk:995: minor=0 len=0 off=133844992
DEBUG rd_prepare_request:753: len=40960
DEBUG rd_prepare_request:763: op=0 offset=133873664 length=40960 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133873664 length=40960 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133873664 length=40960 sectorsize=512 error=0
DEBUG do_rdisk:970: len=40960 off=133873664
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=40960 m2l1=133873664 m2l2=0 m2p1=48b18000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=40960 m2i3=40960 m2l1=133873664 m2l2=0 m2p1=48b18000
DEBUG do_rdisk:995: minor=0 len=0 off=133873664
DEBUG rd_prepare_request:753: len=24576
DEBUG rd_prepare_request:763: op=0 offset=133918720 length=24576 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133918720 length=24576 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133918720 length=24576 sectorsize=512 error=0
DEBUG do_rdisk:970: len=24576 off=133918720
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=24576 m2l1=133918720 m2l2=0 m2p1=48b22000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_prepare_request:753: len=8192
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=24576 m2i3=24576 m2l1=133918720 m2l2=0 m2p1=48b22000
DEBUG do_rdisk:995: minor=0 len=0 off=133918720
DEBUG rd_prepare_request:763: op=0 offset=133943296 length=8192 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133943296 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133943296 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:970: len=8192 off=133943296
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=133943296 m2l2=0 m2p1=48ac8000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_prepare_request:753: len=4096
DEBUG rd_prepare_request:763: op=0 offset=133951488 length=4096 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=133943296 m2l2=0 m2p1=48ac8000
DEBUG do_rdisk:995: minor=0 len=0 off=133943296
DEBUG rd_thread:1069: op=0 offset=133951488 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133951488 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:970: len=4096 off=133951488
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=133951488 m2l2=0 m2p1=48acb000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_intr:666: 
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=133951488 m2l2=0 m2p1=48acb000
DEBUG do_rdisk:995: minor=0 len=0 off=133951488
DEBUG rd_handler:637: 
systemd-journald[360]: /dev/kmsg buffer overrun, some messages lost.
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=57344
DEBUG rd_prepare_request:763: op=0 offset=133955584 length=57344 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=133955584 length=57344 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=133955584 length=57344 sectorsize=512 error=0
DEBUG do_rdisk:970: len=57344 off=133955584
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=57344 m2l1=133955584 m2l2=0 m2p1=48acc000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=57344 m2i3=57344 m2l1=133955584 m2l2=0 m2p1=48acc000
DEBUG do_rdisk:995: minor=0 len=0 off=133955584
DEBUG rd_prepare_request:753: len=57344
DEBUG rd_prepare_request:763: op=0 offset=134017024 length=57344 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=134017024 length=57344 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=134017024 length=57344 sectorsize=512 error=0
DEBUG do_rdisk:970: len=57344 off=134017024
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=57344 m2l1=134017024 m2l2=0 m2p1=48ada000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=57344 m2i3=57344 m2l1=134017024 m2l2=0 m2p1=48ada000
DEBUG do_rdisk:995: minor=0 len=0 off=134017024
DEBUG rd_prepare_request:753: len=8192
DEBUG rd_prepare_request:763: op=0 offset=134074368 length=8192 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=134074368 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=134074368 length=8192 sectorsize=512 error=0
DEBUG do_rdisk:970: len=8192 off=134074368
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=8192 m2l1=134074368 m2l2=0 m2p1=48aa8000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=8192 m2i3=8192 m2l1=134074368 m2l2=0 m2p1=48aa8000
DEBUG do_rdisk:995: minor=0 len=0 off=134074368
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
systemd-journald[360]: /dev/kmsg buffer overrun, some messages lost.
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=61440
DEBUG rd_prepare_request:763: op=0 offset=134090752 length=61440 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=134090752 length=61440 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=134090752 length=61440 sectorsize=512 error=0
DEBUG do_rdisk:970: len=61440 off=134090752
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=61440 m2l1=134090752 m2l2=0 m2p1=48aaa000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=61440 m2i3=61440 m2l1=134090752 m2l2=0 m2p1=48aaa000
DEBUG do_rdisk:995: minor=0 len=0 off=134090752
DEBUG rd_prepare_request:753: len=28672
DEBUG rd_prepare_request:763: op=0 offset=134156288 length=28672 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=134156288 length=28672 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=134156288 length=28672 sectorsize=512 error=0
DEBUG do_rdisk:970: len=28672 off=134156288
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=28672 m2l1=134156288 m2l2=0 m2p1=48ab9000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG rd_prepare_request:753: len=20480
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=28672 m2i3=28672 m2l1=134156288 m2l2=0 m2p1=48ab9000
DEBUG do_rdisk:995: minor=0 len=0 off=134156288
DEBUG rd_prepare_request:763: op=0 offset=134189056 length=20480 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=134189056 length=20480 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=134189056 length=20480 sectorsize=512 error=0
DEBUG do_rdisk:970: len=20480 off=134189056
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=20480 m2l1=134189056 m2l2=0 m2p1=48ac0000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=4096
DEBUG rd_prepare_request:763: op=0 offset=2097152 length=4096 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=2097152 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=2097152 length=4096 sectorsize=512 error=0
DEBUG do_rdisk:970: len=4096 off=2097152
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=4096 m2l1=2097152 m2l2=0 m2p1=48ac5000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=4096 m2i3=4096 m2l1=2097152 m2l2=0 m2p1=48ac5000
DEBUG do_rdisk:995: minor=0 len=0 off=2097152
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
systemd-journald[360]: /dev/kmsg buffer overrun, some messages lost.
DEBUG rd_release:737: 
DEBUG rd_close_dev:294: 
DEBUG rd_open:708: 
DEBUG rd_open_dev:305: major=3 minor=0
DEBUG rd_open_dev:316: source=1227088996 type=1030 m2i1=0 m2i2=30 m2i3=0 m2l1=0 m2l2=1227088896 m2p1=  (null)
DEBUG 2:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 2:dvk_sendrec_T:712: ioctl ret=0
DEBUG rd_open_dev:319: source=3 type=68 m2i1=30 m2i2=0 m2i3=0 m2l1=0 m2l2=1227088896 m2p1=  (null)
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=1024 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=1024 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=1024 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=1024
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=1024 m2l2=0 m2p1=48aca400
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=1024 m2l2=0 m2p1=48aca400
DEBUG do_rdisk:995: minor=0 len=0 off=1024
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
EXT4-fs (rdiska): mounting ext2 file system using the ext4 subsystem
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=2048 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=2048 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=2048 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=2048
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=2048 m2l2=0 m2p1=48aca800
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=2048 m2l2=0 m2p1=48aca800
DEBUG do_rdisk:995: minor=0 len=0 off=2048
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=268288 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=268288 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=268288 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=268288
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=268288 m2l2=0 m2p1=47313800
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=268288 m2l2=0 m2p1=47313800
DEBUG do_rdisk:995: minor=0 len=0 off=268288
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=269312 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=269312 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=269312 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=269312
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=269312 m2l2=0 m2p1=47313c00
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=269312 m2l2=0 m2p1=47313c00
DEBUG do_rdisk:995: minor=0 len=0 off=269312DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=284672 m2l2=0 m2p1=4730f800
DEBUG do_rdisk:995: minor=0 len=0 off=284672
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=285696 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=285696 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=285696 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=285696
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=285696 m2l2=0 m2p1=4730fc00
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=285696 m2l2=0 m2p1=4730fc00
DEBUG do_rdisk:995: minor=0 len=0 off=285696
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=286720 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=286720 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=286720 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=286720
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=286720 m2l2=0 m2p1=4730e000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=286720 m2l2=0 m2p1=4730e000
DEBUG do_rdisk:995: minor=0 len=0 off=286720
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=287744 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=287744 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=287744 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=287744
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=287744 m2l2=0 m2p1=4730e400
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=287744 m2l2=0 m2p1=4730e400
DEBUG do_rdisk:995: minor=0 len=0 off=287744
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=288768 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=288768 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=288768 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=288768
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=288768 m2l2=0 m2p1=4730e800
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=288768 m2l2=0 m2p1=4730e800
DEBUG do_rdisk:995: minor=0 len=0 off=288768
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=289792 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=289792 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=289792 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=289792
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=289792 m2l2=0 m2p1=4730ec00
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=289792 m2l2=0 m2p1=4730ec00
DEBUG do_rdisk:995: minor=0 len=0 off=289792
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=290816 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=290816 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=290816 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=290816
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=290816 m2l2=0 m2p1=4730d000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=290816 m2l2=0 m2p1=4730d000
DEBUG do_rdisk:995: minor=0 len=0 off=290816
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=291840 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=291840 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=291840 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=291840
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=291840 m2l2=0 m2p1=4730d400
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=291840 m2l2=0 m2p1=4730d400
DEBUG do_rdisk:995: minor=0 len=0 off=291840
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=292864 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=292864 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=292864 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=292864
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=292864 m2l2=0 m2p1=4730d800
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=292864 m2l2=0 m2p1=4730d800
DEBUG do_rdisk:995: minor=0 len=0 off=292864
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=293888 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=293888 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=293888 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=293888
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=293888 m2l2=0 m2p1=4730dc00
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=293888 m2l2=0 m2p1=4730dc00
DEBUG do_rdisk:995: minor=0 len=0 off=293888
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=294912 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG rd_thread:1069: op=0 offset=294912 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:963: op=0 offset=294912 length=1024 sectorsize=512 error=0
DEBUG do_rdisk:970: len=1024 off=294912
DEBUG rdisk_rw:943: source=1225879404 type=1027 m2i1=0 m2i2=30 m2i3=1024 m2l1=294912 m2l2=0 m2p1=4730c000
DEBUG 10:dvk_sendrec_T:701: endpoint=3 timeout=30000
DEBUG 10:dvk_sendrec_T:712: ioctl ret=0
DEBUG rdisk_rw:946: source=3 type=68 m2i1=30 m2i2=1024 m2i3=1024 m2l1=294912 m2l2=0 m2p1=4730c000
DEBUG do_rdisk:995: minor=0 len=0 off=294912
DEBUG rd_intr:666: 
DEBUG rd_handler:637: 
DEBUG do_rd_request:804: 
DEBUG rd_prepare_request:753: len=1024
DEBUG rd_prepare_request:763: op=0 offset=295936 length=1024 sectorsize=512 error=0
DEBUG rd_submit_request:781: 
DEBUG do_rd_request:804: 
DEBUG rd_thread:1069: op=0 offset=295936 length=1024 sectorsize=512 error=0EXT4-fs (rdiska): mounted filesystem without journal. Opts: (null)
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0

------------------------------------------------------------------------------------------
OBJETIVO: Hacer que un programa comun UML puede invocar las APIs del DVK 

LA CLAVE DE LO QUE ESTA EN EL STUB ESTA EN
		/arch/um/os-Linux/skas

mknod /dev/dvk c 33 0

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
DEBUG uml_dvk_open:83: dvk_dev=/dev/dvk
DEBUG 1889:dvk_open:61: Open dvk device file /dev/dvk
DEBUG uml_dvk_ioctl:57: uml_pid=2071 uml_vpid=684 cmd=4004E309 arg=BF94ACE8
DEBUG uml_dvk_ioctl:67: rcode=-301
ERROR: 684:dvk_bind_X:943: rcode=-301 <<<< EDVSBADNODEID
DEBUG uml_dvk_ioctl:57: uml_pid=2071 uml_vpid=684 cmd=8004E31A arg=2AC
DEBUG uml_dvk_ioctl:67: rcode=-310
ERROR: 684:dvk_getep:163: rcode=-310
PARENT dvk_getep pid=684 ep=-301 rep=-310 fd=0


root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 27178/1889   0    0   20 27342 27342 27342 27342 linux          
 0   3     3   607/607    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 27186/1897   0    0   20 27342 27342 27342 27342 linux 
 
 ==============================================================================================
20190603:  
      
 root@node0:/usr/src/dvs/dvk-tests# mknod /dev/dvk c 33 0
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
DEBUG uml_dvk_open:88: dvk_dev=/dev/dvk
DEBUG 682:dvk_open:61: Open dvk device file /dev/dvk
DEBUG uml_dvk_ioctl:60: lnx_pid=682 us_pid=866 uml_pid=685 cmd=4004E309 arg=BFADCCE8
DEBUG uml_dvk_ioctl:72: rcode=-1079128856
DEBUG uml_dvk_ioctl:60: lnx_pid=682 us_pid=866 uml_pid=685 cmd=8004E31A arg=2AD
DEBUG uml_dvk_ioctl:72: rcode=-305
UML DVK CALL user=1 tracee_lpid=866 tracer_lpid=682 dvk_fd=27 cmd=8004E31A
ERROR: 685:dvk_getep:163: rcode=-305
PARENT dvk_getep pid=685 ep=-1079128856 rep=-305 fd=0

lnx_pid= UML KERNEL = 682 (userspace de LINUX HOST)
us_pid = USER MODE PROCESS = 866 (userspace de LINUX HOST)
uml_pid= 685 = PID del proceso desde el punto de vista de UML 

	int lnx_pid = os_getpid();
	int us_pid = userspace_pid[0];
	int uml_pid = get_current_pid();
	DVKDEBUG(DBGPARAMS,"lnx_pid=%d us_pid=%d uml_pid=%d cmd=%X arg=%X\n", 
		lnx_pid, us_pid, uml_pid, cmd, arg);
		
tracer_lpid UML KERNEL = 682 (userspace de LINUX HOST)
tracee_lpid=721 es el PID de uml_bind (userspace de LINUX HOST) 

EN EL HOST 
root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 14193/682    0    0   20 27342 27342 27342 27342 linux          
 0   3     3  3198/3198   0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 14201/690    0    0   20 27342 27342 27342 27342 linux  
 
 
 root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=684
DEBUG uml_dvk_open:88: dvk_dev=/dev/dvk
DEBUG 936:dvk_open:61: Open dvk device file /dev/dvk
UML user-mode dvk_fd=0
DEBUG uml_dvk_ioctl:60: lnx_pid=936 us_pid=1119 uml_pid=684 cmd=4004E309 arg=BF8D6CE8
DEBUG uml_dvk_ioctl:72: rcode=-1081250584
ERROR: uml_bind.c:main:28: rcode=-1081250584
DEBUG uml_dvk_ioctl:60: lnx_pid=936 us_pid=1119 uml_pid=684 cmd=8004E31A arg=2AC
DEBUG uml_dvk_ioctl:72: rcode=-305
UML DVK CALL user=1 tracee_lpid=1119 tracer_lpid=936 dvk_fd=27 cmd=8004E31A
ERROR: 684:dvk_getep:163: rcode=-305
ERROR: uml_bind.c:main:31: rcode=-305
PARENT dvk_getep pid=684 ep=-1081250584 rep=-305 dvk_fd=0
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DEBUG uml_dvk_release:131: dvk_dev=/dev/dvk

----------------------------------------------------------------------------------
PROBLEMA:
		UML trabaja con ptrace. Llamemos UML_USR al proceso de usuario TRACEE que quiere utilizar DVK.
		Llamemos UML_KERNEL al kernel de UML que es el TRACER

		Hay que encontrar la forma en que UML_USR puede utilizar una llamada al sistema IOCTL
		sin ser traceada por UML_KERNEL. Esta llamada DEBE ser hecha por el mismo proceso porque
		el DVK obtienes sus atributos reales: proc_ptr, lpid, y su espacio de memoria para
		hacer las copias de datos copy_to_user(), copy_from_user() y copy_usr2usr()
		
		Se podria modificar la syscall sys_ptrace en el kernel de linux y si cumple la condicion:
				- syscall: __NR_ioctl
				- fd = (-1)
		entonces asume que es correcta y retorna.
		
		Seguramente la cosa es diferente. Cuando uno invoca sys_ioctl hay algun flag que indica si 
		es traceada o no. 
		
		
EN /arch/x86/entry/common.c
		
static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)
{
	struct thread_info *ti = current_thread_info(); 
	unsigned int nr = (unsigned int)regs->orig_ax;

#ifdef CONFIG_IA32_EMULATION
	ti->status |= TS_COMPAT;
#endif

	if (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY) {  <<<< FLAGS EN /arch/x86/include/asm/thread_info.h
		/*
		 * Subtlety here: if ptrace pokes something larger than
		 * 2^32-1 into orig_ax, this truncates it.  This may or
		 * may not be necessary, but it matches the old asm
		 * behavior.
		 */
		nr = syscall_trace_enter(regs);
	}

	if (likely(nr < IA32_NR_syscalls)) {
		nr = array_index_nospec(nr, IA32_NR_syscalls);
		/*
		 * It's possible that a 32-bit syscall implementation
		 * takes a 64-bit parameter but nonetheless assumes that
		 * the high bits are zero.  Make sure we zero-extend all
		 * of the args.
		 */
		regs->ax = ia32_sys_call_table[nr](
			(unsigned int)regs->bx, (unsigned int)regs->cx,
			(unsigned int)regs->dx, (unsigned int)regs->si,
			(unsigned int)regs->di, (unsigned int)regs->bp);
	}

	syscall_return_slowpath(regs);
}		

SOLUCION PARA NO SER TRACEADO:
		Poner los flags de READ_ONCE(ti->flags) en CERO 
		
ESTRATEGIA: Supongamos que el kernel a través de uml_dvk (driver) hace el bind de proceso-
	
	
????????????????????????????????????????????????????????????????????????????????????????
OTRA ESTRATEGIA:
		El UML_KERNEL se comporta como SYSTASK+PM pero en forma implicita 
		Los procesos UML_USER para utilizar deberàn ejecutar dvk_bind()
		este será atrapado por el uml_kernel el cual harà el bind en el DVK
		El UML_DVK creará un hilo con CLONE  por cada proceso bindeado. 
		Por lo tanto habra que tener tantos identifiadores de threads
		struckt dvk_proxy_s {
			int user_lpid;		// PID del HOST del proceso UML_USER 
			int proxy_tid;		// Thread ID del representante del proceso en el UML_KERNEL 
			int pipe_fd[2];		// PIPE para comunicar los UML_KERNEL con DVK_PROXY
		}; 
		typedef dvk_proxy_s dvk_proxy_t; 
		dvk_threads_t dvk_proxy[NR_PROCS] <<< Solo admite endpoints de procesos de usuario
			
		PRIMITIVAS DE GESTION: 
			- bind: 
					Se crea el thread asociado en dvk_proxy[ep_nr] 
					conecta al pipe
					El thread asociado hace el bind(ep_nr)
					thread se conecta al PIPE 
					DVK_PROXY retorna el resultado al UML_DVK por el pipe 
					DVK_PROXY queda a la espera de nuevos comandos en un pipe
					UML_DVK si el resultado del BIND es OK
					retorna al UML_USER  
					sino 
						envia un comando de FIN al DVK_PROXY el cual finaliza cerrando el pipe 
						UML_DVK cierra el pipe
			- unbind:
					UML_DVK ->> DVK_PROXY 
					DVK_PROXY hace el unbind 
					DVK_PROXY sale del loop 
					retorna el resultado a UML_DVK
					UML_DVK 
					
			- getep: 
			- wait4bind
			- wain4unbind 
					UML_DVK ->> DVK_PROXY 
					DVK_PROXY wait4bind
					cuando despierta retorna el resultado a UML_DVK
					UML_DVK 
		PRIMITIVAS DE IPC:
			- send
			- receive
			- sendrec
			- notify
			- vcopy; 
			- rcvrqst
			- sendrply
	
PROBLEMAS A RESOLVER:
			- supongamos que el DVK_PROXY espera en una primitiva.
			- como retorna al UML_USER ????
			- Se puede utilizar el mecanismo de interrupciones IRQ usado por ubd_kern
			- Se puede utilizar copy_to_user y copy_from_user para copiar los parametros de ioctl 
			- Respecto a vcopy, no queda otra que asignar un buffer al DVK_PROXY al iniciarlo y usarlo 
				para todas las transferencias como intermediario.
							
EN /arch/um/include/shared/os.h ESTAN TODAS LAS LLAMADAS PERMITIDAS DESDE UML-->HOST 
LAS QUE ESTAN DEFINIDAS EN  /arch/um/os-Linux/file.c

ATENCION: Pensar de tener un DVK_PROXY como servidor modo usuario en UML: que ganamos??
			igual debe esperar alguien en el kernel, no parece alentador 
			
==============================================================================================
20190605: 
				CAMBIO DE ESTRATEGIA: QUE LO HAGA EL STUB 

		
ATENCION!!! Quizas se pueden ejecutar cosas en el STUB!!!
long run_syscall_stub(struct mm_id * mm_idp, int syscall,
		      unsigned long *args, long expected, void **addr,
		      int done)
static inline long do_syscall_stub(struct mm_id * mm_idp, void **addr)
donde 
		struct mm_id * mm_idp = &current->mm->context.id;
		
TRABAJA DE LA SIGUIENTE MANERA
		UML_USER hace una syscall pero que tiene que ejecutarse en su espacio de direcciones
		UML_KERNEL intercepta el syscall y carga los argumentos para que se ejecute una funcion/syscall 
		generica en el STUB.
		Luego hace continuar el UML_USER, pero ahora desde una direccion del STUB 
		Luego espera por el STUB hasta que finalice.
		
SE NECESITA LOCALIZAR CUANDO UNA SYSCALL ES RECIBIDA 
void handle_syscall(struct uml_pt_regs *r)
Se deberia hacer el open del DVK al arrancar el proceso de usuario y almacenar su valor en el STUB.

Ver en /arch/um/os-Linux/skas/mem.c donde se hace el map y unmap

EL CODIGO QUE ESTA EN EL STUB ES ESTE!!
/arch/um/kernel/skas

En este directorio estan las funciones que preparan el entorno para la ejecución de algo en el STUB
/arch/um/os-Linux/skas

Aqui habria que incluir un archivo dvk.c para que contenga la invocacion

Quizas aqui se pueda incluir la apertura del dvk para obtener el FD.
stub_clone_handler(void)


Stub_syscall3 y el  resto se encuentran definidos en 
/arch/x86/um/shared/sysdep/stub_32.h

/arch/um/include/shared/skas/mm_id.h


Se podria modificar 
/arch/um/include/shared/skas/mm_id.h
struct mm_id {
	union {
		int mm_fd;
		int pid;
	} u;
	unsigned long stack;
	Int dvk_fd;
};

HAY QUE INICIALIZAR  mm_idp->dvk_fd = (-1);
Quizas en void userspace(struct uml_pt_regs *regs)
struct mm_id * mm_idp = &current->mm->context.id;
mm_idp->dvk_fd = (-1);

ATENCION ATENCION ATENCION 
ATENCION ATENCION ATENCION 
ATENCION ATENCION ATENCION 
ATENCION ATENCION ATENCION 
 EN arch/um/os-Linux/skas se ignoran las constantes de configuracion CONFIG_UML_DVK!!!

DESPUES DE COMPILAR DA ESTOS ERRORES QUE QUEDAN PENDIENTES 
arch/um/os-Linux/skas/process.c:379:27: error: ‘current’ undeclared (first use in this function)
   struct mm_id *mm_idp = &current->mm->context.id;
                           ^~~~~~~
arch/um/os-Linux/skas/process.c:379:27: note: each undeclared identifier is reported only once for each function it appears in
arch/um/os-Linux/skas/process.c:395:16: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
      open_path = UPT_SYSCALL_ARG1(regs);
                ^
arch/um/os-Linux/skas/process.c:398:14: error: implicit declaration of function ‘copy_from_user’ [-Werror=implicit-function-declaration]
      rcode = copy_from_user(tmp_path, open_path, len);
              ^~~~~~~~~~~~~~
arch/um/os-Linux/skas/process.c:404:8: error: implicit declaration of function ‘PT_REGS_SET_SYSCALL_RETURN’ [-Werror=implicit-function-declaration]
        PT_REGS_SET_SYSCALL_RETURN(regs, rcode); // set the return code


==============================================================================================
20190606: 

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 77
UML DVK __NR_ioctl tracee_lpid=185 tracer_lpid=13 fd=0 cmd=5403
UML DVK __NR_ioctl tracee_lpid=185 tracer_lpid=13 fd=0 cmd=5401
UML DVK __NR_ioctl tracee_lpid=185 tracer_lpid=13 fd=2 cmd=BFA11FC8
UML DVK __NR_ioctl tracee_lpid=185 tracer_lpid=13 fd=0 cmd=BFA1273C
UML DVK __NR_ioctl tracee_lpid=185 tracer_lpid=13 fd=2 cmd=BFA127BC
UML user-mode pid=691
ERROR: 691:dvk_open:65: rcode=-2
ERROR: uml_bind.c:main:24: rcode=-2
UML user-mode dvk_fd=-2
UML DVK __NR_ioctl tracee_lpid=204 tracer_lpid=13 fd=2 cmd=BF8027F0
ERROR: uml_bind.c:main:28: rcode=-1
UML DVK __NR_ioctl tracee_lpid=204 tracer_lpid=13 fd=1074446336 cmd=8004E31A
ERROR: 691:dvk_getep:163: rcode=-9
ERROR: uml_bind.c:main:31: rcode=-9
PARENT dvk_getep pid=691 ep=-1 rep=-9 dvk_fd=-2

ATENCION: TUVE QUE ANULAR EN stub_dvkcall los indicios de CONFIG_UML_DVK
//###################################################################
//###################################################################
#ifdef CONFIG_UML_DVK
#undef CONFIG_UML_DVK
#endif // CONFIG_UML_DVK
//###################################################################
//###################################################################

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=683 DVK_FILE_NAME=/dev/dvk
DVK userspace MATCH __NR_open user=1 tracee_lpid=3290 tracer_lpid=3110 tmp_path=/dev/dvk flags=0 mode=80000C6F
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Segmentation fault

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=684 DVK_FILE_NAME=/dev/dvk
DVK userspace MATCH __NR_open user=1 tracee_lpid=3292 tracer_lpid=3110 tmp_path=/dev/dvk flags=0 mode=80000C6F
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Segmentation fault


ESTO QUIERE DECIR QUE NO ESTA RETORNANDO CORRECTAMENTE A LA MISMA POSICION QUE TENIA.
ATENCION, PARA PODER DISTINGUIR SI ES UN PEDIDO AL DVK, SE PUEDE HACER UTILIZAR
#define DVK_IOC_MAGIC  0xE3 <<<<<<<<<<<<<<<<<< 

Todas estan constitudas con este componente.
#define DVK_IOCQGETEP	 _IOR(DVK_IOC_MAGIC, DVK_GETEP, int)

Aaparentemente funciona asi:
	El UML_USER hace un syscalll
	
==============================================================================================
20190607/8:
		Ya probe en insertar el codigo tanto en process.c/userspace como en syscall.c/handle_syscall
		En todo los casos da segmentation fault
		
root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=683 DVK_FILE_NAME=/dev/dvk
DVK userspace MATCH __NR_open user=0 tracee_lpid=0 tracer_lpid=2 tmp_path=/dev/dvk flags=0 mode=C6F
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Segmentation fault

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=684 DVK_FILE_NAME=/dev/dvk
DVK userspace MATCH __NR_open user=0 tracee_lpid=0 tracer_lpid=2 tmp_path=/dev/dvk flags=0 mode=C6F
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Segmentation fault

PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP (since Linux 2.6.14)
For PTRACE_SYSEMU, continue and stop on entry to the next system call, which will not be executed. 
For PTRACE_SYSEMU_SINGLESTEP, do the same but also singlestep if not a system call. 
This call is used by programs like User Mode Linux that want to emulate all the tracee's system calls. 
The data argument is treated as for PTRACE_CONT. The addr argument is ignored. These requests 
are currently supported only on x8

PTRACE_SYSCALL, PTRACE_SINGLESTEP
Restart the stopped tracee as for PTRACE_CONT, but arrange for the tracee to be stopped at the next entry
 to or exit from a system call, or after execution of a single instruction, respectively. 
 (The tracee will also, as usual, be stopped upon receipt of a signal.) 
 From the tracer's perspective, the tracee will appear to have been stopped by receipt of a SIGTRAP. 
 So, for PTRACE_SYSCALL, for example, the idea is to inspect the arguments to the system call at the first stop, 
 then do another PTRACE_SYSCALL and inspect the return value of the system call at the second stop. 
 The data argument is treated as for PTRACE_CONT. (addr is ignored.)
	
WIFCONTINUED(status)
(since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.	
	
	!!!!!!!!!!!!!!!!! si op=PTRACE_SYSEMU entonces NUNCA va a ejecutar la dvk_call !!!!!!!!!!!!!!!!! 
		/* Now we set local_using_sysemu to be used for one loop */
		local_using_sysemu = get_using_sysemu();
		op = SELECT_PTRACE_OPERATION(local_using_sysemu, singlestepping(NULL));
		if (ptrace(op, pid, 0, 0)) {
			printk(UM_KERN_ERR "userspace - ptrace continue "
			       "failed, op = %d, errno = %d\n", op, errno);
			fatal_sigsegv();
		}

EL PROBLEMA si se cambia de  PTRACE_SYSEMU --> PTRACE_SYSCALL para que si se ejecute la dvk_call()
			- se setea de prepo  local_using_sysemu=0 >>>> da segfault 
			- se setea el parametro de arranque  "nosysemu" >>>>> da segfault 
Supongo que esto se debe a que una vez q se ejecuta la syscall, retorna otra vez a la rutina userspace()
y alli se produce el error.

systemd[1]: Set hostname to <node0>.
Stub registers -
        0 - 4015b000
        1 - 1000
        2 - 5
        3 - 11
        4 - 4
        5 - 101028
        6 - 1000
        7 - 7b
        8 - 7b
        9 - 0
        10 - 33
        11 - ffffffff
        12 - 1000a0
        13 - 73
        14 - 10246
        15 - 101028
        16 - 7b
handle_trap - failed to wait at end of syscall, errno = 0, status = 2943= 0x0‭B7F‬
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b

CPU: 0 PID: 1 Comm: systemd Not tainted 4.9.88 #107
Stack:
 082f81b8 48887400 08331ec0 00000000 48889da0 081c1771 00000000 00000000
 082f81b8 48889db8 080b3131 48857cec 48887400 08331ec0 00000000 48889df0
 080745ea 082e16de 0000000b 00000000 00000422 00000000 01889dd0 48889e58
Call Trace:
 [<0805ae5b>] show_stack+0xaf/0xf7
 [<081c1771>] dump_stack+0x16/0x1b
 [<080b3131>] panic+0x84/0x18a
 [<080745ea>] do_exit+0x3bf/0x763
 [<08074a0f>] do_group_exit+0x56/0xa9
 [<0807b9e5>] get_signal+0x46e/0x491
 [<0805aac6>] do_signal+0x1d/0x286
 [<08088f84>] ? wake_up_state+0x10/0x12
 [<08079f74>] ? signal_wake_up_state+0x1a/0x1e
 [<0807a5c7>] ? __send_signal.constprop.9+0x144/0x1c9
 [<0806aeca>] ? set_signals+0x1a/0x2b
 [<0807ad0c>] ? force_sig_info+0x81/0x8b
 [<0807b0eb>] ? force_sig+0x10/0x15
 [<0807b12c>] ? force_sigsegv+0x3c/0x45
 [<0805bc41>] fatal_sigsegv+0x2a/0x2f
 [<0806cbc6>] userspace+0x134/0x4c2
 [<080e2f2a>] ? do_execveat_common+0x4bb/0x586
 [<080e300d>] ? do_execve+0x18/0x1a
 [<08059019>] ? run_init_process+0x1e/0x20
 [<08059027>] ? try_to_run_init_process+0xc/0x2e
 [<08059f54>] new_thread_handler+0x78/0x7c

Abortado
root@node0:/usr/src/linux# 

	
#define WNOHANG		0x00000001<<<
#define WUNTRACED	0x00000002<<<
#define WSTOPPED	WUNTRACED
#define WEXITED		0x00000004
#define WCONTINUED	0x00000008 <<<
#define WNOWAIT		0x01000000	/* Don't reap, just poll status.  */
	
#define SIGTRAP		 5

systemd[1]: Set hostname to <node0>.
WSTOPSIG(status)=B (11=8+2+1) SIGTRAP + 0x80=85 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
Stub registers -
        0 - 4015b000
        1 - 1000
        2 - 5
        3 - 11
        4 - 4
        5 - 101028
        6 - 1000
        7 - 7b
        8 - 7b
        9 - 0
        10 - 33
        11 - ffffffff
        12 - 1000a0
        13 - 73
        14 - 10246
        15 - 101028
        16 - 7b
handle_trap - failed to wait at end of syscall, errno = 0, status = 2943
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b

CPU: 0 PID: 1 Comm: systemd Not tainted 4.9.88 #110
Stack:
 082f81fd 48083400 08331ec0 00000000 48085d9c 081c17d1 00000000 00000000
 082f81fd 48085db4 080b3191 48057cec 48083400 08331ec0 00000000 48085dec
 0807464a 082e1723 0000000b 00000000 00000422 00000000 01085dcc 48085e54
Call Trace:
 [<0805ae5b>] show_stack+0xaf/0xf7
 [<081c17d1>] dump_stack+0x16/0x1b
 [<080b3191>] panic+0x84/0x18a
 [<0807464a>] do_exit+0x3bf/0x763
 [<08074a6f>] do_group_exit+0x56/0xa9
 [<0807ba45>] get_signal+0x46e/0x491
 [<0805aac6>] do_signal+0x1d/0x286
 [<08088fe4>] ? wake_up_state+0x10/0x12
 [<08079fd4>] ? signal_wake_up_state+0x1a/0x1e
 [<0807a627>] ? __send_signal.constprop.9+0x144/0x1c9
 [<0806aeca>] ? set_signals+0x1a/0x2b
 [<0807ad6c>] ? force_sig_info+0x81/0x8b
 [<0807b14b>] ? force_sig+0x10/0x15
 [<0807b18c>] ? force_sigsegv+0x3c/0x45
 [<0805bc41>] fatal_sigsegv+0x2a/0x2f
 [<0806cc01>] userspace+0x16f/0x529
 [<080e2f8a>] ? do_execveat_common+0x4bb/0x586
 [<080e306d>] ? do_execve+0x18/0x1a
 [<08059019>] ? run_init_process+0x1e/0x20
 [<08059027>] ? try_to_run_init_process+0xc/0x2e
 [<08059f54>] new_thread_handler+0x78/0x7c

Abortado
root@node0:/usr/src/linux# 


https://www.cyphar.com/blog/post/20160703-remainroot-ptrace-hell
Entry and Exit
It turns out that ptrace(PTRACE_SYSCALL, 0, NULL, NULL) doesn’t really 
have any semantic information for syscalls. In particular, the entry and exit
 from a syscall are separate ptrace(2) events (which are indistinguishable 
 from each other so you need to keep track yourself). 
 It also means that you’ll have to keep track of the syscall number and arguments yourself.


Quizas hay que hacer un doble ptrace
		
			ptrace SYSCALL 
			wait enter 
			ptrace SYSCALL 
			wait exit 

==============================================================================================
20190610:

root@node0:/usr/src/linux# nsenter -p -t$DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 nosysemu 

		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 76
		UML user-mode pid=685 DVK_FILE_NAME=/dev/dvk
		ERROR: 685:dvk_open:65: rcode=-2
		UML user-mode dvk_open fd=-2
		ERROR: uml_bind.c:main:30: rcode=-1
		UML user-mode open dvk_fd=-1
		ERROR: uml_bind.c:main:35: rcode=-1
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=183
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:38: rcode=-9
		PARENT dvk_getep pid=685 ep=-1 rep=-9 dvk_fd=-1
		DVK userspace __NR_open tmp_path=[/run/sys] UML_DVK_DEV=[/dev/dvk]
		^CDVK: exit_unbind local_nodeid:0
		DVK: old_exit_unbind code:2

		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 76
		UML user-mode pid=686 DVK_FILE_NAME=/dev/dvk
		ERROR: 686:dvk_open:65: rcode=-2
		UML user-mode dvk_open fd=-2
		ERROR: uml_bind.c:main:30: rcode=-1
		UML user-mode open dvk_fd=-1
		ERROR: uml_bind.c:main:35: rcode=-1
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=185
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:38: rcode=-9
		PARENT dvk_getep pid=686 ep=-1 rep=-9 dvk_fd=-1
		DVK userspace __NR_open tmp_path=[/run/sys] UML_DVK_DEV=[/dev/dvk]
		^CDVK: exit_unbind local_nodeid:0
		DVK: old_exit_unbind code:2


		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
		UML user-mode pid=682 DVK_FILE_NAME=/dev/dvk
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=180
		ERROR: -38:dvk_getep:163: rcode=-25
		ERROR: uml_bind.c:main:26: rcode=-25
		DVK userspace __NR_open tmp_path=[èN] UML_DVK_DEV=[/dev/dvk]
		ERROR: 682:dvk_open:65: rcode=-2
		UML user-mode dvk_open fd=-2
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=180
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:32: rcode=-9
		DVK userspace __NR_open tmp_path=[] UML_DVK_DEV=[/dev/dvk]
		ERROR: uml_bind.c:main:36: rcode=-1
		UML user-mode open dvk_fd=-1
		ERROR: uml_bind.c:main:41: rcode=-1
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=180
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:44: rcode=-9
		PARENT dvk_getep pid=682 ep=-1 rep=-9 dvk_fd=-1
		DVK userspace __NR_open tmp_path=[/run/sys] UML_DVK_DEV=[/dev/dvk]

		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
		UML user-mode pid=683 DVK_FILE_NAME=/dev/dvk
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=182
		ERROR: -38:dvk_getep:163: rcode=-25
		ERROR: uml_bind.c:main:26: rcode=-25
		DVK userspace __NR_open tmp_path=[èN] UML_DVK_DEV=[/dev/dvk]
		ERROR: 683:dvk_open:65: rcode=-2
		UML user-mode dvk_open fd=-2
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=182
		DVK userspace __NR_open tmp_path=[/run/sys] UML_DVK_DEV=[/dev/dvk]
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:32: rcode=-9
		ERROR: uml_bind.c:main:36: rcode=-1
		UML user-mode open dvk_fd=-1
		ERROR: uml_bind.c:main:41: rcode=-1
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A
		handle_dvk pid=182
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:44: rcode=-9
		PARENT dvk_getep pid=683 ep=-1 rep=-9 dvk_fd=-1
		DVK userspace __NR_open tmp_path=[/run/sys] UML_DVK_DEV=[/dev/dvk]


			


==============================================================================================
20190610:

	ESTRATEGIA: se intento que el stub hiciera el OPEN y que le pasara al kernel la direccion
	pero aparentemente esto no funciona ni utilizando PTRACE_PEEKDATA ni copy_from_user_proc

		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
		Failed PTRACE_PEEKDATA Parent pid=901 errno=0 &stub_fd=48EB5DA0
		Failed PTRACE_PEEKDATA Child pid=908 errno=0 &stub_fd=48EB5DA0
		Failed PTRACE_PEEKDATA Parent pid=908 errno=0 &stub_fd=48EADDF8
		Failed PTRACE_PEEKDATA Child pid=909 errno=0 &stub_fd=48EADDF8
		UML user-mode pid=685 DVK_FILE_NAME=/dev/dvk
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=728
		handle_dvk pid=909
		ERROR: -38:dvk_getep:163: rcode=-25
		ERROR: uml_bind.c:main:26: rcode=-25
		ERROR: 685:dvk_open:65: rcode=-2
		UML user-mode dvk_open fd=-2
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=728
		handle_dvk pid=909
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:32: rcode=-9
		ERROR: uml_bind.c:main:36: rcode=-1
		UML user-mode open dvk_fd=-1
		ERROR: uml_bind.c:main:41: rcode=-1
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=728
		handle_dvk pid=909
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:44: rcode=-9
		PARENT dvk_getep pid=685 ep=-1 rep=-9 dvk_fd=-1
		PARENT dvk_getep pid=683 ep=-1 rep=-9 dvk_fd=-1


		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 55 
		UML user-mode pid=680 DVK_FILE_NAME=/dev/dvk
		 cmd=8004E31A filter_cmd=E3 magic=E3
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=3019
		handle_dvk pid=3197
		ERROR: -38:dvk_getep:163: rcode=-25
		ERROR: uml_bind.c:main:26: rcode=-25
		ERROR: 680:dvk_open:65: rcode=-2
		UML user-mode dvk_open fd=-2
		 cmd=8004E31A filter_cmd=E3 magic=E3
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=3019
		handle_dvk pid=3197
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:32: rcode=-9
		ERROR: uml_bind.c:main:36: rcode=-1
		UML user-mode open dvk_fd=-1
		ERROR: uml_bind.c:main:41: rcode=-1 <<<<<<<<<<<<<<<<<<<<<< ESTE ES EL RCODE DE DVK_BIND!!
		 cmd=8004E31A filter_cmd=E3 magic=E3
		DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=3019
		handle_dvk pid=3197
		ERROR: -38:dvk_getep:163: rcode=-9
		ERROR: uml_bind.c:main:44: rcode=-9
		PARENT dvk_getep pid=680 ep=-1 rep=-9 dvk_fd=-1

ATENCION, SOLO ESTA DETECTANDO EL GETEP !!!!!!!!!


root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=685 DVK_FILE_NAME=/dev/dvk
 cmd=8004E31A filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=3481
handle_dvk pid=3664
ERROR: -38:dvk_getep:163: rcode=-25
ERROR: uml_bind.c:main:26: rcode=-25
ERROR: 685:dvk_open:65: rcode=-2
UML user-mode dvk_open fd=-2
 cmd=8004E31A filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=3481
handle_dvk pid=3664
ERROR: -38:dvk_getep:163: rcode=-9
ERROR: uml_bind.c:main:32: rcode=-9
ERROR: uml_bind.c:main:36: rcode=-1
UML user-mode open dvk_fd=-1
ERROR: uml_bind.c:main:41: rcode=-1
 cmd=8004E31A filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=3481
handle_dvk pid=3664
ERROR: -38:dvk_getep:163: rcode=-9
ERROR: uml_bind.c:main:44: rcode=-9
PARENT dvk_getep pid=685 ep=-1 rep=-9 dvk_fd=-1

ATENCION:  A VECES CUANDO ARRANCA DA
winch_thread : TIOCSCTTY failed on fd 1 err = 1
 cmd=BF9AE3D8 filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=13 cmd=BF9AE3D8 lpid=3715  <<<<< BIND !!! 
handle_dvk pid=3869



==============================================================================================
20190612:

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
Failed PTRACE_PEEKDATA Parent pid=1094 stub_fd=-1 errno=5 stub_fd_addr=4
Failed PTRACE_PEEKDATA Parent pid=1095 stub_fd=-1 errno=5 stub_fd_addr=4
UML user-mode pid=684 DVK_FILE_NAME=/dev/dvk
ERROR: uml_bind.c:main:26: rcode=-1
 cmd=8004E31A filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=915
handle_dvk pid=1095
ERROR: -38:dvk_getep:163: rcode=-25
ERROR: uml_bind.c:main:29: rcode=-25
ERROR: 684:dvk_open:65: rcode=-2
UML user-mode dvk_open fd=-2
 cmd=8004E31A filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=915
handle_dvk pid=1095
ERROR: -38:dvk_getep:163: rcode=-9
ERROR: uml_bind.c:main:35: rcode=-9
ERROR: uml_bind.c:main:39: rcode=-1
UML user-mode open dvk_fd=-1
ERROR: uml_bind.c:main:44: rcode=-1
 cmd=8004E31A filter_cmd=E3 magic=E3
DVK userspace __NR_ioctl fd=1074446336 cmd=8004E31A lpid=915
handle_dvk pid=1095
ERROR: -38:dvk_getep:163: rcode=-9
ERROR: uml_bind.c:main:47: rcode=-9

       EIO    request is invalid, or an attempt was made to read from or
              write to an invalid area in the tracer's or the tracee's
              memory, or there was a word-alignment violation, or an invalid
              signal was specified during a restart request.



WSTOPSIG(status)=B SIGTRAP + 0x80=85  <<< B = 11 = SIGSEGV	11	Core	Invalid memory reference
Stub registers -
        0 - 4015b000
        1 - 1000
        2 - 5
        3 - 11
        4 - 4
        5 - 101028
        6 - 1000
        7 - 7b
        8 - 7b
        9 - 0
        10 - 33
        11 - ffffffff
        12 - 1000a0
        13 - 73
        14 - 10246
        15 - 101028
        16 - 7b
handle_trap - failed to wait at end of syscall, errno = 0, status = 2943
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b

CPU: 0 PID: 1 Comm: systemd Not tainted 4.9.88 #165
Stack:
 082f8366 48487400 08331ec0 00000000 48489dac 081c1891 00000000 00000000
 082f8366 48489dc4 080b3251 48457cec 48487400 08331ec0 00000000 48489dfc
 0807470a 082e188c 0000000b 00000000 00000422 00000000 01489ddc 48489e64
Call Trace:
 [<0805ae5b>] show_stack+0xaf/0xf7
 [<081c1891>] dump_stack+0x16/0x1b
 [<080b3251>] panic+0x84/0x18a
 [<0807470a>] do_exit+0x3bf/0x763
 [<08074b2f>] do_group_exit+0x56/0xa9
 [<0807bb05>] get_signal+0x46e/0x491
 [<0805aac6>] do_signal+0x1d/0x286
 [<080890a4>] ? wake_up_state+0x10/0x12
 [<0807a094>] ? signal_wake_up_state+0x1a/0x1e
 [<0807a6e7>] ? __send_signal.constprop.9+0x144/0x1c9
 [<0806af96>] ? set_signals+0x1a/0x2b
 [<0807ae2c>] ? force_sig_info+0x81/0x8b
 [<0807b20b>] ? force_sig+0x10/0x15
 [<0807b24c>] ? force_sigsegv+0x3c/0x45
 [<0805bc41>] fatal_sigsegv+0x2a/0x2f
 [<0806ccfb>] userspace+0x19d/0x521
 [<080e304a>] ? do_execveat_common+0x4bb/0x586
 [<080e312d>] ? do_execve+0x18/0x1a
 [<08059019>] ? run_init_process+0x1e/0x20
 [<08059027>] ? try_to_run_init_process+0xc/0x2e
 [<08059f54>] new_thread_handler+0x78/0x7c


==============================================================================================
20190613:

		ATENCION, primero hice 
		mknod /dev/dvk c 33 0
			
		LO EXTRAÑO ES QUE EN NINGUN MOMENTO EL NR_OPEN FUE DETECTADO 
	
root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 77                              
UML user-mode pid=689 DVK_FILE_NAME=/dev/dvk
DVK handle_dvk_enter __NR_ioctl fd=0 cmd=4004E309 lpid=1659
DVK handle_dvk_exit pid=1849
ERROR: uml_bind.c:main:26: rcode=-1
DVK handle_dvk_enter __NR_ioctl fd=0 cmd=8004E31A lpid=1659
DVK handle_dvk_exit pid=1849
ERROR: 689:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:29: rcode=-38
DEBUG uml_dvk_open:88: dvk_dev=/dev/dvk
DEBUG 1659:dvk_open:68: Open dvk device file /dev/dvk
UML user-mode dvk_open fd=0
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=8004E31A lpid=1659
DVK handle_dvk_exit pid=1849
ERROR: 689:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:35: rcode=-38
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=4004E309 lpid=1659
DVK handle_dvk_exit pid=1849
ERROR: uml_bind.c:main:44: rcode=-1
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=8004E31A lpid=1659
DVK handle_dvk_exit pid=1849
ERROR: 689:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:47: rcode=-38
PARENT dvk_getep pid=689 ep=-1 rep=-38 dvk_fd=3

root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 22384/1659   0    0   20 27342 27342 27342 27342 linux          
 0   3     3   642/642    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 22392/1667   0    0   20 27342 27342 27342 27342 linux          
 0  77    77 22592/1849   0    0   20 27342 27342 27342 27342 linux  <<<<<<<< BINDEO!!!! 
 
El BIND funciona bien porque el parametro que le pasa al DVK es SELF_BIND.
 
PRIMER GETEP  
[51064.400493] DEBUG dvk_ioctl:201: cmd=8004E31A arg=2B1
[51064.400497] DEBUG dvk_ioctl:221: DVK_CALL=26 (getep) 
[51064.400498] DEBUG io_getep:279: 
[51064.400500] DEBUG new_getep:1971: pid=689
[51064.400504] DEBUG check_caller:536: caller_pid=22592 caller_tgid=22592
[51064.400505] ERROR: 22592:check_caller:570: rcode=-310
[51064.400507] ERROR: 22592:dvk_ioctl:225: rcode=-310
[51064.405712] DEBUG dvk_ioctl:201: cmd=4004E309 arg=BFA7BCE8

BIND 
[51064.405716] DEBUG dvk_ioctl:221: DVK_CALL=9 (bind) 
[51064.405718] DEBUG io_bind:97: 
[51064.405723] DEBUG new_bind:1372: oper=0 dcid=0 param_pid=-1 endpoint=77 nodeid=-1
[51064.405725] DEBUG new_bind:1394: RLOCK_DC dc=0 count=0
[51064.405726] DEBUG new_bind:1407: WLOCK_PROC ep=77 count=0
[51064.405728] DEBUG init_proc_desc:16: p_name=$noname dcid=0
[51064.405731] DEBUG new_bind:1441: param_pid=-1 lpid=22592 vpid=1849 tid=22592
[51064.405733] DEBUG new_bind:1465: SELF_BIND param_pid=-1 lpid=22592 vpid=1849 tid=22592
[51064.405734] DEBUG new_bind:1487: WUNLOCK_PROC ep=77 count=0
[51064.405735] DEBUG new_bind:1490: WLOCK_TASK pid=22592 count=0
[51064.405737] DEBUG new_bind:1491: WLOCK_PROC ep=77 count=0
[51064.405738] DEBUG new_bind:1527: increment the reference count of the task struct=22592 count=2
[51064.405739] DEBUG new_bind:1538: process p_name=linux *p_name_ptr=linux
[51064.405742] DEBUG new_bind:1595: nr=77 endp=77 dcid=0 flags=0 misc=20 lpid=22592 vpid=1849 nodeid=0 name=linux 
[51064.405744] DEBUG new_bind:1596: nr=77 endp=77 dcid=0 lpid=22592 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[51064.405745] DEBUG new_bind:1610: WUNLOCK_TASK pid=22592 count=0
[51064.405747] DEBUG new_bind:1616: WUNLOCK_PROC ep=77 count=0
[51064.405747] DEBUG new_bind:1618: DC_INCREF counter=4
[51064.405749] DEBUG new_bind:1619: RUNLOCK_DC dc=0 count=0

SEGUNDO GETEP 
[51064.405914] DEBUG dvk_ioctl:201: cmd=8004E31A arg=2B1
[51064.405916] DEBUG dvk_ioctl:221: DVK_CALL=26 (getep) 
[51064.405917] DEBUG io_getep:279: 
[51064.405918] DEBUG new_getep:1971: pid=689                     <<<<<<<<<<<<<< USER_MODE PID 
[51064.405920] DEBUG check_caller:536: caller_pid=22592 caller_tgid=22592
[51064.405921] DEBUG check_caller:572: WLOCK_PROC ep=77 count=0
[51064.405922] DEBUG check_caller:601: WUNLOCK_PROC ep=77 count=0
[51064.405923] DEBUG check_caller:604: dcid=0
[51064.405925] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[51064.405926] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[51064.405927] DEBUG check_caller:618: caller_pid=22592 
[51064.405928] DEBUG new_getep:1986: caller_pid=22592 caller_vpid=1849 dcid=0
[51064.405930] ERROR: 22592:new_getep:1991: rcode=-305 <<<<< ESTA BIEN EDVSBADPID  	(_SIGN 305)  /* Bad Process ID */
[51064.405931] ERROR: 22592:dvk_ioctl:225: rcode=-305  < PORQUE LE PASO COMO PARAMETRO EL USER_MODE PID 

................................................................................

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 79
UML user-mode pid=693 DVK_FILE_NAME=/dev/dvk
DVK handle_dvk_enter __NR_ioctl fd=0 cmd=4004E309 lpid=1659
DVK handle_dvk_exit pid=1854
ERROR: uml_bind.c:main:26: rcode=-1
DVK handle_dvk_enter __NR_ioctl fd=0 cmd=8004E31A lpid=1659
DVK handle_dvk_exit pid=1854
ERROR: 693:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:29: rcode=-38
DEBUG uml_dvk_open:88: dvk_dev=/dev/dvk
DEBUG 1659:dvk_open:68: Open dvk device file /dev/dvk
UML user-mode dvk_open fd=0
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=8004E31A lpid=1659
DVK handle_dvk_exit pid=1854
ERROR: 693:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:35: rcode=-38
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=4004E309 lpid=1659
DVK handle_dvk_exit pid=1854
ERROR: uml_bind.c:main:44: rcode=-1
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=8004E31A lpid=1659
DVK handle_dvk_exit pid=1854
ERROR: 693:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:47: rcode=-38
PARENT dvk_getep pid=693 ep=-1 rep=-38 dvk_fd=3


root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 22384/1659   0    0   20 27342 27342 27342 27342 linux          
 0   3     3   642/642    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 22392/1667   0    0   20 27342 27342 27342 27342 linux          
 0  79    79 22616/1854   0    0   20 27342 27342 27342 27342 linux  

...........................................................................
PROBLEMA: 
		Aquellas funciones que usan el PID del proceso entregan el UML_PID (mal)
		Hay que entregar el PID del HOST (aunque sea del namespace)
		Se hizo interceptando el GETEP y NO funciono 
		el BIND es mas complicado porque se necesita copiar la estructura completa.

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 79                              
UML user-mode pid=695 DVK_FILE_NAME=/dev/dvk
DVK handle_dvk_enter __NR_ioctl fd=0 cmd=4004E309 lpid=0
DVK handle_dvk_exit pid=2335
ERROR: uml_bind.c:main:26: rcode=-1
DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=0 cmd=8004E31A args=695
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=0 cmd=8004E31A args=2335  <<<< SE SUPONE QUE PASO CORRECTAMENTE EL PID 
DVK handle_dvk_exit pid=2335
ERROR: 695:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:29: rcode=-38
DEBUG uml_dvk_open:88: dvk_dev=/dev/dvk
DEBUG 2133:dvk_open:68: Open dvk device file /dev/dvk
UML user-mode dvk_open fd=0
DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=3 cmd=8004E31A args=695
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=3 cmd=8004E31A args=2335
DVK handle_dvk_exit pid=2335
ERROR: 695:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:35: rcode=-38
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=4004E309 lpid=0
DVK handle_dvk_exit pid=2335
ERROR: uml_bind.c:main:44: rcode=-1
DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=3 cmd=8004E31A args=695
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=3 cmd=8004E31A args=2335
DVK handle_dvk_exit pid=2335
ERROR: 695:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:47: rcode=-38
PARENT dvk_getep pid=695 ep=-1 rep=-38 dvk_fd=3
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DEBUG uml_dvk_release:131: dvk_dev=/dev/dvk


root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 30603/2133   0    0   20 27342 27342 27342 27342 linux          
 0   3     3   642/642    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 30611/2141   0    0   20 27342 27342 27342 27342 linux          
 0  76    76 30806/2332   0    0   20 27342 27342 27342 27342 linux 
 
[53755.686043] DEBUG dvk_ioctl:201: cmd=8004E31A arg=2B7
[53755.686044] DEBUG dvk_ioctl:221: DVK_CALL=26 (getep) 
[53755.686045] DEBUG io_getep:279: 
[53755.686046] DEBUG new_getep:1971: pid=695								<<< PERO RECIBIO OTRO VALOR DE PID (UML_USER PID)
[53755.686047] DEBUG check_caller:536: caller_pid=30821 caller_tgid=30821
[53755.686048] DEBUG check_caller:572: WLOCK_PROC ep=79 count=0
[53755.686050] DEBUG check_caller:601: WUNLOCK_PROC ep=79 count=0
[53755.686051] DEBUG check_caller:604: dcid=0
[53755.686052] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[53755.686053] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[53755.686054] DEBUG check_caller:618: caller_pid=30821 
[53755.686055] DEBUG new_getep:1986: caller_pid=30821 caller_vpid=2335 dcid=0
[53755.686057] ERROR: 30821:new_getep:1991: rcode=-305
[53755.686058] ERROR: 30821:dvk_ioctl:225: rcode=-305

 .......................................................................

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 79                              
UML user-mode pid=685 DVK_FILE_NAME=/dev/dvk
DVK handle_dvk_enter __NR_ioctl fd=0 cmd=4004E309 lpid=0
DVK handle_dvk_exit pid=2570
ERROR: uml_bind.c:main:26: rcode=-1

DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=0 cmd=8004E31A args=685
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=0 cmd=8004E31A args=2570
DVK handle_dvk_exit pid=2570
ERROR: 685:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:29: rcode=-38

DEBUG uml_dvk_open:88: dvk_dev=/dev/dvk
DEBUG 2387:dvk_open:68: Open dvk device file /dev/dvk
UML user-mode dvk_open fd=0

DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=3 cmd=8004E31A args=685
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=3 cmd=8004E31A args=2570
DVK handle_dvk_exit pid=2570
ERROR: 685:dvk_getep:163: rcode=-38

ERROR: uml_bind.c:main:35: rcode=-38
DVK handle_dvk_enter __NR_ioctl fd=3 cmd=4004E309 lpid=0
DVK handle_dvk_exit pid=2570
ERROR: uml_bind.c:main:44: rcode=-1

DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=3 cmd=8004E31A args=685
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=3 cmd=8004E31A args=2570
DVK handle_dvk_exit pid=2570
ERROR: 685:dvk_getep:163: rcode=-38
ERROR: uml_bind.c:main:47: rcode=-38
PARENT dvk_getep pid=685 ep=-1 rep=-38 dvk_fd=3

root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2  1060/2387   0    0   20 27342 27342 27342 27342 linux          
 0   3     3   642/642    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30  1068/2395   0    0   20 27342 27342 27342 27342 linux          
 0  79    79  1249/2570   0    0   20 27342 27342 27342 27342 linux 


...........................................................................

root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
UML user-mode pid=685 DVK_FILE_NAME=/dev/dvk

DVK handle_dvk_enter __NR_ioctl fd=0 cmd=4004E309 lpid=0
DVK handle_dvk_exit pid=867
handle_dvk_exit dvk_retcode=-25
ERROR: uml_bind.c:main:26: rcode=-1

DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=0 cmd=8004E31A args=685
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=0 cmd=8004E31A args=867
DVK handle_dvk_exit pid=867
handle_dvk_exit dvk_retcode=-25
ERROR: 685:dvk_getep:163: rcode=-25
ERROR: uml_bind.c:main:29: rcode=-25

DVK handle_dvk_enter MATCH __NR_open tracee_lpid=867 tracer_lpid=684 tmp_path=/dev/dvk flags=0 mode=0
DVK handle_dvk_exit pid=867
handle_dvk_exit dvk_retcode=27
UML user-mode dvk_open fd=0

DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=27 cmd=8004E31A args=685
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=27 cmd=8004E31A args=867
DVK handle_dvk_exit pid=867
handle_dvk_exit dvk_retcode=-310
ERROR: 685:dvk_getep:163: rcode=-310
ERROR: uml_bind.c:main:35: rcode=-310

DVK handle_dvk_enter __NR_ioctl fd=27 cmd=4004E309 lpid=0
DVK handle_dvk_exit pid=867
handle_dvk_exit dvk_retcode=66

DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=27 cmd=8004E31A args=685
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=27 cmd=8004E31A args=867
DVK handle_dvk_exit pid=867
handle_dvk_exit dvk_retcode=66
PARENT dvk_getep pid=685 ep=66 rep=66 dvk_fd=27

AQUI ESTAN LOS GETEP UTILIZANDO EL LINUX PID DEL CONTAINER 

[ 3127.642709] DEBUG dvk_ioctl:201: cmd=8004E31A arg=363
[ 3127.642713] DEBUG dvk_ioctl:221: DVK_CALL=26 (getep) 
[ 3127.642714] DEBUG io_getep:279: 
[ 3127.642716] DEBUG new_getep:1971: pid=867
[ 3127.642719] DEBUG check_caller:536: caller_pid=15778 caller_tgid=15778
[ 3127.642721] ERROR: 15778:check_caller:570: rcode=-310
[ 3127.642723] ERROR: 15778:dvk_ioctl:225: rcode=-310
[ 3127.651216] DEBUG dvk_ioctl:201: cmd=4004E309 arg=BFDFBCE8
[ 3127.651220] DEBUG dvk_ioctl:221: DVK_CALL=9 (bind) 
[ 3127.651221] DEBUG io_bind:97: 
[ 3127.651226] DEBUG new_bind:1372: oper=0 dcid=0 param_pid=-1 endpoint=66 nodeid=-1
[ 3127.651228] DEBUG new_bind:1394: RLOCK_DC dc=0 count=0
[ 3127.651229] DEBUG new_bind:1407: WLOCK_PROC ep=66 count=0
[ 3127.651232] DEBUG init_proc_desc:16: p_name=$noname dcid=0
[ 3127.651235] DEBUG new_bind:1441: param_pid=-1 lpid=15778 vpid=867 tid=15778
[ 3127.651237] DEBUG new_bind:1465: SELF_BIND param_pid=-1 lpid=15778 vpid=867 tid=15778
[ 3127.651238] DEBUG new_bind:1487: WUNLOCK_PROC ep=66 count=0
[ 3127.651239] DEBUG new_bind:1490: WLOCK_TASK pid=15778 count=0
[ 3127.651240] DEBUG new_bind:1491: WLOCK_PROC ep=66 count=0
[ 3127.651242] DEBUG new_bind:1527: increment the reference count of the task struct=15778 count=2
[ 3127.651243] DEBUG new_bind:1538: process p_name=linux *p_name_ptr=linux
[ 3127.651246] DEBUG new_bind:1595: nr=66 endp=66 dcid=0 flags=0 misc=20 lpid=15778 vpid=867 nodeid=0 name=linux 
[ 3127.651248] DEBUG new_bind:1596: nr=66 endp=66 dcid=0 lpid=15778 p_cpumask=FFFFFFFF nodemap=1 name=linux 
[ 3127.651249] DEBUG new_bind:1610: WUNLOCK_TASK pid=15778 count=0
[ 3127.651250] DEBUG new_bind:1616: WUNLOCK_PROC ep=66 count=0
[ 3127.651251] DEBUG new_bind:1618: DC_INCREF counter=4
[ 3127.651252] DEBUG new_bind:1619: RUNLOCK_DC dc=0 count=0
[ 3127.651472] DEBUG dvk_ioctl:201: cmd=8004E31A arg=363
[ 3127.651474] DEBUG dvk_ioctl:221: DVK_CALL=26 (getep) 
[ 3127.651475] DEBUG io_getep:279: 
[ 3127.651476] DEBUG new_getep:1971: pid=867
[ 3127.651479] DEBUG check_caller:536: caller_pid=15778 caller_tgid=15778
[ 3127.651480] DEBUG check_caller:572: WLOCK_PROC ep=66 count=0
[ 3127.651481] DEBUG check_caller:601: WUNLOCK_PROC ep=66 count=0
[ 3127.651483] DEBUG check_caller:604: dcid=0
[ 3127.651484] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
[ 3127.651485] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
[ 3127.651486] DEBUG check_caller:618: caller_pid=15778 
[ 3127.651488] DEBUG new_getep:1986: caller_pid=15778 caller_vpid=867 dcid=0
[ 3127.651489] DEBUG new_getep:1995: task_pid_nr(task_ptr)=15778 vpid=867
[ 3127.651490] DEBUG new_getep:2008: RLOCK_PROC ep=66 count=0
[ 3127.651491] DEBUG new_getep:2027: RUNLOCK_PROC ep=66 count=0
[ 3127.651492] DEBUG new_getep:2030: dcid=0
[ 3127.651493] DEBUG new_getep:2031: RLOCK_DC dc=0 count=0
[ 3127.651494] DEBUG new_getep:2034: RUNLOCK_DC dc=0 count=0
[ 3127.651495] DEBUG new_getep:2037: endpoint=66



==============================================================================================
20190615:			FUNCIONO 

		root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
		UML user-mode pid=682 DVK_FILE_NAME=/dev/dvk
		
		// Aqui hace un GETEP por lo que debe cambiar el pid de 682 (UML_USER) a 1099 (HOST allocated PID)
		// dvk_bind(dcid,endpoint) 			dvk_bind_X(SELF_BIND, dcid, getpid(), endpoint, LOCALNODE)

		DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=0 cmd=4004E309 pid=-1 <<<< ???????
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=0 cmd=4004E309 pid=1099
		DVK handle_dvk_exit pid=1099
		handle_dvk_exit dvk_retcode=-25							<<<< EDVSNOTTY, es porque no se hizo el open del DVK 
		ERROR: uml_bind.c:main:26: rcode=-1
		
		DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=0 cmd=8004E31A args=682
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=0 cmd=8004E31A args=1099
		DVK handle_dvk_exit pid=1099
		handle_dvk_exit dvk_retcode=-25
		ERROR: 682:dvk_getep:163: rcode=-25
		ERROR: uml_bind.c:main:29: rcode=-25
		
		// SE HACE EL OPEN DEL DVK 
		DVK handle_dvk_enter MATCH __NR_open tracee_lpid=1099 tracer_lpid=919 tmp_path=/dev/dvk flags=0 mode=0
		DVK handle_dvk_exit pid=1099
		handle_dvk_exit dvk_retcode=27
		UML user-mode dvk_open fd=0
		
		// SE HACE NUEVAMENTE UN GETEP 
		DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=27 cmd=8004E31A args=682
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=27 cmd=8004E31A args=1099
		DVK handle_dvk_exit pid=1099
		handle_dvk_exit dvk_retcode=-310
		ERROR: 682:dvk_getep:163: rcode=-310			// AHORA ES EL DVK QUE RETORNA  EDVSNOTBIND
		ERROR: uml_bind.c:main:35: rcode=-310

		// HACE EL BIND CAMBIANDO EL PID 
		DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=27 cmd=4004E309 pid=-1 <<< ??????
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=27 cmd=4004E309 pid=1099  <<<< PID DEL HOST 
		DVK handle_dvk_exit pid=1099
		handle_dvk_exit dvk_retcode=66			<<< ENDPOINT ASIGNADO 
		
		// HACE EL GETEP 
		DVK handle_dvk_enter DVK_IOCQGETEP BEFORE fd=27 cmd=8004E31A args=682
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=27 cmd=8004E31A args=1099
		DVK handle_dvk_exit pid=1099
		handle_dvk_exit dvk_retcode=66 					<<< ENDPOINT RETORNADO 
		PARENT dvk_getep pid=682 ep=66 rep=66 dvk_fd=27


		root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
		DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
		 0  -2    -2 22282/919    0    0   20 27342 27342 27342 27342 linux          
		 0   3     3   685/685    0    8   20 31438 27342 27342 27342 rdisk          
		 0  30    30 22290/927    0    0   20 27342 27342 27342 27342 linux          
		 0  66    66 22463/1099   0    0   20 27342 27342 27342 27342 linux <<<<<<<<<<<<<<<<<<<<< 
 
 ..............................................................................
				// se lee perfectamente la estructura parm_bind
				root@node0:/usr/src/dvs/dvk-tests# ./uml_bind 0 66
				.....
				DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=27 cmd=4004E309 pid=-1
				DVK handle_dvk_enter bind parm_cmd=0 			<<< SELF_BIND 
				DVK handle_dvk_enter bind parm_dcid=0			<<< DCID 
				DVK handle_dvk_enter bind parm_pid=1585			<<< PID HOST MODIFICADO 
				DVK handle_dvk_enter bind parm_ep=66			<<< ENDPOINT 
				DVK handle_dvk_enter bind parm_nodeid=-1		<<< LOCALNODE
				......

GENIAL!!! probe COPY CLIENTE Y COPY SERVER 
			
	LINUX HOST 
		root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 
		usage: ./copy_server <dcid> <svr_ep>
		root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 10
		DEBUG 28125:dvk_open:68: Open dvk device file /dev/dvk
		DEBUG 28125:dvk_getdvsinfo:183: 
		DEBUG 28125:dvk_getdvsinfo:186: ioctl ret=0 errno=0
		 copy_server.c:main:47:local_nodeid=0
		 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		DEBUG 28125:dvk_getdcinfo:261: dcid=0
		DEBUG 28125:dvk_getdcinfo:266: ioctl ret=0 errno=0
		 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		 copy_server.c:main:59:flags=0 dc_nodes=3 dc_pid=648 dc_name=DC0
		DEBUG 28125:dvk_bind_X:935: cmd=0 dcid=0 pid=-1 endpoint=10 nodeid=-1
		DEBUG 28125:dvk_bind_X:944: ioctl ret=10 errno=0
		 copy_server.c:main:76:BIND SERVER dcid=0 svr_pid=28125 svr_ep=10
		DEBUG 28125:dvk_getprocinfo:897: dcid=0 p_nr=10 
		DEBUG 28125:dvk_getprocinfo:903: ioctl ret=0 errno=0
		 copy_server.c:main:85:nr=10 endp=10 dcid=0 flags=0 misc=20 lpid=28125 vpid=28125 nodeid=0 name=copy_server 
		 copy_server.c:main:93:SERVER m_ptr=0xaf8000
		 copy_server.c:main:115:SERVER: buffer before=01234567890123456789012345678
		DEBUG 28125:dvk_receive_T:684: endpoint=31438 timeout=-1
		DEBUG 28125:dvk_receive_T:690: ioctl ret=0 errno=0
		 copy_server.c:main:119:SERVER: source=11 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x80007000 m1p2=(nil) m1p3=(nil) 
		DEBUG 28125:dvk_getprocinfo:897: dcid=0 p_nr=11 
		DEBUG 28125:dvk_getprocinfo:903: ioctl ret=0 errno=0
		 copy_server.c:main:137:nr=11 endp=11 dcid=0 flags=8 misc=20 lpid=28127 vpid=1591 nodeid=0 name=linux 
		DEBUG 28125:dvk_vcopy:87: src_ep=11 dst_ep=35534 bytes=1024
		DEBUG 28125:dvk_vcopy:96: ioctl ret=1024 errno=0
		 copy_server.c:main:144:SERVER: buffer received=abcdefghijklmnopqrstuvwxyabcdefghijkl
		DEBUG 28125:dvk_vcopy:87: src_ep=35534 dst_ep=11 bytes=1024
		DEBUG 28125:dvk_vcopy:96: ioctl ret=1024 errno=0
		 copy_server.c:main:154:SERVER: buffer sent=ABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJKLMNOPQ
		DEBUG 28125:dvk_send_T:660: endpoint=11 timeout=-1
		DEBUG 28125:dvk_send_T:666: ioctl ret=76 errno=0
		 copy_server.c:main:163:SERVER END

	UML-GUEST 
		root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_client 0 10 11
		DVK handle_dvk_enter MATCH __NR_open tracee_lpid=1591 tracer_lpid=1404 tmp_path=/dev/dvk flags=0 mode=BFFB2D84
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=28
		DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E31B lpid=0
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=0
		 copy_client.c:main:37:local_nodeid=0
		 copy_client.c:main:38:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30E lpid=0
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=0
		 copy_client.c:main:48:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		 copy_client.c:main:49:flags=0 dc_nodes=3 dc_pid=648 dc_name=DC0
		DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=28 cmd=4004E309 pid=-1
		DVK handle_dvk_enter bind parm_cmd=0
		DVK handle_dvk_enter bind parm_dcid=0
		DVK handle_dvk_enter bind parm_pid=1591
		DVK handle_dvk_enter bind parm_ep=11
		DVK handle_dvk_enter bind parm_nodeid=-1
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=28 cmd=4004E309 pid=-1
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=11
		 copy_client.c:main:78:BIND CLIENT dcid=0 clt_pid=689 clt_ep=11
		DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30F lpid=0
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=0
		 copy_client.c:main:87:nr=11 endp=11 dcid=0 flags=0 misc=20 lpid=28127 vpid=1591 nodeid=0 name=linux 
		DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E31D lpid=0
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=10
		 copy_client.c:main:91:dvk_wait4bindep_T ret=10
		DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30F lpid=0
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=0
		 copy_client.c:main:99:nr=10 endp=10 dcid=0 flags=8 misc=20 lpid=28125 vpid=28125 nodeid=0 name=copy_server 
		 copy_client.c:main:107:CLIENT m_ptr=0x80006000
		 copy_client.c:main:129:CLIENT: buffer before=abcdefghijklmnopqrstuvwxyabcdef
		 copy_client.c:main:133:CLIENT SENT: source=0 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x80007000 m1p2=(nil) m1p3=(nil) 
		DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E305 lpid=0
		DVK handle_dvk_exit pid=1591
		handle_dvk_exit dvk_retcode=0
		 copy_client.c:main:141:CLIENT RECIEVED: source=10 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x80007000 m1p2=(nil) m1p3=(nil) 
		 copy_client.c:main:143:CLIENT: buffer after=ABCDEFGHIJKLMNOPQRSTUVWXYABCDEF
		 copy_client.c:main:145:CLIENT END
		DVK: exit_unbind local_nodeid:0
		DVK: old_exit_unbind code:0
				
..................................................................................

	// Si trato de ejecutar el copy_server me da error en la espera del RCV 
	
		root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_server 0 10
		DVK handle_dvk_enter MATCH __NR_open tracee_lpid=2296 tracer_lpid=2113 tmp_path=/dev/dvk flags=0 mode=BF9E7D94
		DVK handle_dvk_exit pid=2296
		handle_dvk_exit dvk_retcode=27
		DVK handle_dvk_enter __NR_ioctl fd=27 cmd=8004E31B lpid=0
		DVK handle_dvk_exit pid=2296
		handle_dvk_exit dvk_retcode=0
		 copy_server.c:main:47:local_nodeid=0
		 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		DVK handle_dvk_enter __NR_ioctl fd=27 cmd=8004E30E lpid=0
		DVK handle_dvk_exit pid=2296
		handle_dvk_exit dvk_retcode=0
		 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		 copy_server.c:main:59:flags=0 dc_nodes=3 dc_pid=648 dc_name=DC0
		DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=27 cmd=4004E309 pid=-1
		DVK handle_dvk_enter bind parm_cmd=0
		DVK handle_dvk_enter bind parm_dcid=0
		DVK handle_dvk_enter bind parm_pid=2296
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=27 cmd=4004E309 pid=2296
		DVK handle_dvk_enter bind parm_ep=10
		DVK handle_dvk_enter bind parm_nodeid=-1
		DVK handle_dvk_exit pid=2296
		handle_dvk_exit dvk_retcode=10
		 copy_server.c:main:76:BIND SERVER dcid=0 svr_pid=685 svr_ep=10
		DVK handle_dvk_enter __NR_ioctl fd=27 cmd=8004E30F lpid=0
		DVK handle_dvk_exit pid=2296
		handle_dvk_exit dvk_retcode=0
		 copy_server.c:main:85:nr=10 endp=10 dcid=0 flags=0 misc=20 lpid=4212 vpid=2296 nodeid=0 name=linux 
		 copy_server.c:main:93:SERVER m_ptr=0x80006000
		 copy_server.c:main:115:SERVER: buffer before=0123456789012345678
		 DVK handle_dvk_enter __NR_ioctl fd=27 cmd=4004E303 lpid=0
		DVK handle_dvk_exit pid=2296

		handle_dvk_exit dvk_retcode=-512 <<<<<<<<<<<<<<<<<<<<<<<< esto es en ret = dvk_receive(ANY, (long) m_ptr);
		ERROR: 685:dvk_receive_T:685: rcode=-512
		 copy_server.c:main:119:SERVER: source=0 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		SERVER: dvk_receive ret=-512  
		DVK: exit_unbind local_nodeid:0
		DVK: old_exit_unbind code:256

ALGO SUCEDE CON  ERESTARTSYS !! (-512)

................................................................................................

root@node0:/usr/src/dvs/dvk-tests# ./test_sendrec 0 10 11
DVK handle_dvk_enter MATCH __NR_open tracee_lpid=2312 tracer_lpid=2113 tmp_path=/dev/dvk flags=0 mode=0
DVK handle_dvk_exit pid=2312
handle_dvk_exit dvk_retcode=28
DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=28 cmd=4004E309 pid=-1
DVK handle_dvk_enter bind parm_cmd=0
DVK handle_dvk_enter bind parm_dcid=0
DVK handle_dvk_enter bind parm_pid=2312
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=28 cmd=4004E309 pid=2312
DVK handle_dvk_enter bind parm_ep=10
DVK handle_dvk_enter bind parm_nodeid=-1
DVK handle_dvk_exit pid=2312
handle_dvk_exit dvk_retcode=10
PARENT BIND dcid=0 parent_pid=697 parent_nr=10 parent_ep=10 m_ptr=0x80004008
DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=28 cmd=4004E309 pid=-1
DVK handle_dvk_enter bind parm_cmd=0
DVK handle_dvk_enter bind parm_dcid=0
DVK handle_dvk_enter bind parm_pid=2313
DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=28 cmd=4004E309 pid=2313
DVK handle_dvk_enter bind parm_ep=11
DVK handle_dvk_enter bind parm_nodeid=-1
DVK handle_dvk_exit pid=2313
handle_dvk_exit dvk_retcode=11
PARENT pause before SENDREC
CHILD BIND dcid=0 child_pid=698 child_nr=11 child_ep=11 m_ptr=0x80004008
CHILD FIRST RECEIVE
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E303 lpid=0
DVK handle_dvk_exit pid=2313
handle_dvk_exit dvk_retcode=-512
ERROR: 698:dvk_receive_T:685: rcode=-512
ERROR: test_sendrec.c:main:86: rcode=-512
CHILD RECEIVE msg:source=0 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
CHILD FIRST SEND
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E302 lpid=0
DVK handle_dvk_exit pid=2313
handle_dvk_exit dvk_retcode=-109
ERROR: 698:dvk_send_T:661: rcode=-109
ERROR: test_sendrec.c:main:92: rcode=-109
PARENT FIRST SENDREC msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E305 lpid=0
DVK handle_dvk_exit pid=2312
handle_dvk_exit dvk_retcode=-512
ERROR: 697:dvk_sendrec_T:709: rcode=-512
ERROR: test_sendrec.c:main:55: rcode=-512
PARENT FIRST REPLY msg:source=10 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
PARENT SECOND SENDREC msg:source=10 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E305 lpid=0
DVK handle_dvk_exit pid=2312
handle_dvk_exit dvk_retcode=-512
ERROR: 697:dvk_sendrec_T:709: rcode=-512
ERROR: test_sendrec.c:main:65: rcode=-512
PARENT SECOND REPLY msg:source=10 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
CHILD SECOND RECEIVE
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E303 lpid=0
DVK handle_dvk_exit pid=2313
handle_dvk_exit dvk_retcode=-512
ERROR: 698:dvk_receive_T:685: rcode=-512
ERROR: test_sendrec.c:main:98: rcode=-512
CHILD RECEIVE msg:source=0 type=254 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
CHILD SECOND SEND
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E302 lpid=0
DVK handle_dvk_exit pid=2313
handle_dvk_exit dvk_retcode=-109
ERROR: 698:dvk_send_T:661: rcode=-109
ERROR: test_sendrec.c:main:104: rcode=-109
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30F lpid=0
DVK handle_dvk_exit pid=2312
handle_dvk_exit dvk_retcode=0
nr=10 endp=10 dcid=0 flags=0 misc=20 lpid=4232 vpid=2312 nodeid=0 name=linux 
endp=10 dcid=0 flags=0 p_getfrom=27342 p_sendto=27342 p_waitmigr=27342 p_waitunbind=27342 p_proxy=27342
nr=10 endp=10 dcid=0 p_lclsent=0 p_rmtsent=0 p_lclcopy=0 p_rmtcopy=0 
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:17920

EN LA PARTE DEL RECEIVE 
DVK handle_dvk_enter __NR_ioctl fd=27 cmd=4004E303 lpid=0
DVK handle_dvk_exit pid=642
handle_dvk_exit dvk_retcode=-512
si_signo=5 si_errno=0 si_code=133 si_pid=642 si_uid=0 si_syscall=0  <<<<  5) SIGTRAP 
																	<<<< si_code=133 = 0x85 = SIGTRAP + 0x80
ERROR: 680:dvk_receive_T:685: rcode=-512
 copy_server.c:main:119:SERVER: source=0 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
SERVER: dvk_receive ret=-512
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:256

root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2 15358/462    0    0   20 27342 27342 27342 27342 linux          
 0   3     3   591/591    0    8   20 31438 27342 27342 27342 rdisk          
 0  30    30 15366/470    0    0   20 27342 27342 27342 27342 linux 
 
==============================================================================================
20190616:

listado de significado de señales 
root@node0:/usr/src/linux# kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX


		DVK handle_dvk_enter DVK_IOCSRECEIVE fd=27 cmd=4004E303 args=-1077736672
		DVK handle_dvk_wait pid=654
		stopped by signal 14 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 14) SIGALRM
		PTRACE_SET_THREAD_AREA failed, err = -3, index = 6
		arch_switch_tls failed, errno 3, not EINVAL
		userspace - PTRACE_SETREGS errno=3  <<<<<<<<<<<<<<< EDVSSRCH /* no such process */
		DVK: exit_unbind local_nodeid:0
		DVK: old_exit_unbind code:11
		Segmentation fault

		[ 6017.755144] DEBUG dvk_ioctl:201: cmd=4004E303 arg=BFFEEB20
		[ 6017.755147] DEBUG dvk_ioctl:221: DVK_CALL=3 (mini_receive) 
		[ 6017.755148] DEBUG io_mini_receive:35: 
		[ 6017.755150] DEBUG new_mini_receive:288: src_ep=31438
		[ 6017.755153] DEBUG check_caller:536: caller_pid=10329 caller_tgid=10329
		[ 6017.755154] DEBUG check_caller:572: WLOCK_PROC ep=10 count=0
		[ 6017.755156] DEBUG check_caller:601: WUNLOCK_PROC ep=10 count=0
		[ 6017.755157] DEBUG check_caller:604: dcid=0
		[ 6017.755158] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
		[ 6017.755160] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
		[ 6017.755161] DEBUG check_caller:618: caller_pid=10329 
		[ 6017.755162] DEBUG new_mini_receive:299: RLOCK_PROC ep=10 count=0
		[ 6017.755163] DEBUG new_mini_receive:303: caller_nr=10 caller_ep=10 src_ep=31438 
		[ 6017.755165] DEBUG new_mini_receive:307: dcid=0
		[ 6017.755166] DEBUG new_mini_receive:311: RUNLOCK_PROC ep=10 count=0
		[ 6017.755167] DEBUG new_mini_receive:313: RLOCK_DC dc=0 count=0
		[ 6017.755168] DEBUG new_mini_receive:316: RUNLOCK_DC dc=0 count=0
		[ 6017.755169] DEBUG new_mini_receive:366: WLOCK_PROC ep=10 count=0
		[ 6017.755171] DEBUG new_mini_receive:471: Any suitable message from 31438 was not found.
		[ 6017.755172] DEBUG sleep_proc:344: timeout=-1
		[ 6017.755174] DEBUG sleep_proc:355: BEFORE DOWN lpid=10329 p_sem=0 timeout=-1
		[ 6017.755175] DEBUG sleep_proc:357: endpoint=10 flags=8
		[ 6017.755176] DEBUG sleep_proc:361: WUNLOCK_PROC ep=10 count=0
		[ 6017.755178] DEBUG sleep_proc:368: endpoint=10 ret=-512 p_rcode=0
		[ 6017.755179] DEBUG sleep_proc:369: endpoint=10 flags=8 cpuid=0
		[ 6017.755180] DEBUG sleep_proc:370: WLOCK_PROC ep=10 count=0
		[ 6017.755181] DEBUG sleep_proc:392: pid=10329 ret=-512
		[ 6017.755183] DEBUG sleep_proc:417: nr=10 endp=10 dcid=0 lpid=10329 p_cpumask=FFFFFFFF nodemap=1 name=linux 
		[ 6017.755185] DEBUG sleep_proc:419: someone wakeups me: sem=0 p_rcode=-512
		[ 6017.755186] DEBUG new_mini_receive:488: WUNLOCK_PROC ep=10 count=0
		[ 6017.755187] ERROR: 10329:new_mini_receive:489: rcode=-512
		[ 6017.755188] ERROR: 10329:dvk_ioctl:225: rcode=-512
		
		
		PRUEBA TRATANDO DE BLOQUERA SIGALRM

		DVK handle_dvk_enter DVK_IOCSRECEIVE fd=27 cmd=4004E303 args=-1080632544
		DVK handle_dvk_wait pid=1353
		handle_dvk_wait - PTRACE_GETSIGMASK failed, errno = 22 <<<<<<<<< EINVAL  invalid argument
		DVK: exit_unbind local_nodeid:0
		DVK: old_exit_unbind code:11
		Segmentation fault

==============================================================================================
20190619:	
			El error esta en el kernel del HOST en kernel/ptrace 
		
		case PTRACE_GETSIGMASK:
		printk("PTRACE_GETSIGMASK 
		addr=%d sizeof(sigset_t)=%d\n", addr,  sizeof(sigset_t));
#ifdef ANULADO
		if (addr != sizeof(sigset_t)) {
			ret = -EINVAL;
			break;
		}
#endif // ANULADO

		if (copy_to_user(datavp, &child->blocked, sizeof(sigset_t)))
			ret = -EFAULT;
		else
			ret = 0;

		break;
		
[  169.205383] request=24 addr=0 sizeof(sigset_t)=8
[  169.205416] request=16898 addr=0 sizeof(sigset_t)=8
[  169.205419] request=16898 addr=0 sizeof(sigset_t)=8

#define PTRACE_GETSIGMASK	0x420a => 16906
#define PTRACE_SETSIGMASK	0x420b => 16907


AHORA FUNCIONA, PERO QUEDA SIN AVANZAR EL UML 

root@node0:/usr/src/dvs/dvk-proxies/test# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2   616/2      0    0   20 27342 27342 27342 27342 linux          
 0   3     3   598/598    0    8   20 31438 27342 27342 27342 rdisk          
 0  10    10   865/188    0    8   20 31438 27342 27342 27342 linux     <<< copy_server 0 10      
 0  30    30   624/10     0    0   20 27342 27342 27342 27342 linux 
 
EN UML: EL SERVER 
      ./copy_server 0 10
	
		DVK handle_dvk_exit pid=188
		handle_dvk_exit dvk_retcode=30
		DVK handle_dvk_enter __NR_ioctl fd=30 cmd=8004E31B lpid=0
		DVK handle_dvk_exit pid=188
		handle_dvk_exit dvk_retcode=0
		 copy_server.c:main:47:local_nodeid=0
		 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		DVK handle_dvk_enter __NR_ioctl fd=30 cmd=8004E30E lpid=0
		DVK handle_dvk_exit pid=188
		handle_dvk_exit dvk_retcode=0
		 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		 copy_server.c:main:59:flags=0 dc_nodes=3 dc_pid=566 dc_name=DC0
		DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=30 cmd=4004E309 pid=-1
		DVK handle_dvk_enter bind parm_cmd=0
		DVK handle_dvk_enter bind parm_dcid=0
		DVK handle_dvk_enter bind parm_pid=188
		DVK handle_dvk_enter DVK_IOCQGETEP AFTER  fd=30 cmd=4004E309 pid=188
		DVK handle_dvk_enter bind parm_ep=10
		DVK handle_dvk_enter bind parm_nodeid=-1
		DVK handle_dvk_exit pid=188
		handle_dvk_exit dvk_retcode=10
		 copy_server.c:main:76:BIND SERVER dcid=0 svr_pid=686 svr_ep=10
		DVK handle_dvk_enter __NR_ioctl fd=30 cmd=8004E30F lpid=0
		DVK handle_dvk_exit pid=188
		handle_dvk_exit dvk_retcode=0
		 copy_server.c:main:85:nr=10 endp=10 dcid=0 flags=0 misc=20 lpid=865 vpid=188 nodeid=0 name=linux 
		 copy_server.c:main:93:SERVER m_ptr=0x80006000
		 copy_server.c:main:115:SERVER: buffer before=0123456789012345678901234567890123456789012345678
		DVK handle_dvk_enter DVK_IOCSRECEIVE fd=30 cmd=4004E303 args=-1080612064
		DVK handle_dvk_wait pid=188
		 copy_server.c:main:119:SERVER: source=60 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x1c2f000 m1p2=(nil) m1p3=(nil) 
		copy_server.c:main:137:nr=60 endp=60 dcid=0 flags=8 misc=20 lpid=869 vpid=869 nodeid=0 name=copy_client 
		copy_server.c:main:144:SERVER: buffer received=abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwx
		copy_server.c:main:154:SERVER: buffer sent=ABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJKLMNOPQRSTUVWXYABC
		copy_server.c:main:163:SERVER END

EN EL HOST: copy_client 
		root@node0:/usr/src/dvs/dvk-proxies/test# ./copy_client 0 10 60
		DEBUG 869:dvk_open:68: Open dvk device file /dev/dvk
		DEBUG 869:dvk_getdvsinfo:183: 
		DEBUG 869:dvk_getdvsinfo:186: ioctl ret=0 errno=0
		 copy_client.c:main:37:local_nodeid=0
		 copy_client.c:main:38:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		DEBUG 869:dvk_getdcinfo:261: dcid=0
		DEBUG 869:dvk_getdcinfo:266: ioctl ret=0 errno=0
		 copy_client.c:main:48:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
		 copy_client.c:main:49:flags=0 dc_nodes=3 dc_pid=566 dc_name=DC0
		DEBUG 869:dvk_bind_X:935: cmd=0 dcid=0 pid=-1 endpoint=60 nodeid=-1
		DEBUG 869:dvk_bind_X:944: ioctl ret=60 errno=0
		 copy_client.c:main:78:BIND CLIENT dcid=0 clt_pid=869 clt_ep=60
		DEBUG 869:dvk_getprocinfo:897: dcid=0 p_nr=60 
		DEBUG 869:dvk_getprocinfo:903: ioctl ret=0 errno=0
		 copy_client.c:main:87:nr=60 endp=60 dcid=0 flags=0 misc=20 lpid=869 vpid=869 nodeid=0 name=copy_client 
		DEBUG 869:dvk_wait4bindep_X:460: cmd=0 endpoint=10 timeout=30000
		DEBUG 869:dvk_wait4bindep_X:467: ioctl ret=10 errno=0
		 copy_client.c:main:91:dvk_wait4bindep_T ret=10
		DEBUG 869:dvk_getprocinfo:897: dcid=0 p_nr=10 
		DEBUG 869:dvk_getprocinfo:903: ioctl ret=0 errno=0
		 copy_client.c:main:99:nr=10 endp=10 dcid=0 flags=8 misc=20 lpid=865 vpid=188 nodeid=0 name=linux 
		 copy_client.c:main:107:CLIENT m_ptr=0x1c2e000
		 copy_client.c:main:129:CLIENT: buffer before=abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwx
		 copy_client.c:main:133:CLIENT SENT: source=0 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x1c2f000 m1p2=(nil) m1p3=(nil) 
		DEBUG 869:dvk_sendrec_T:708: endpoint=10 timeout=-1
		DEBUG 869:dvk_sendrec_T:714: ioctl ret=0 errno=0
		 copy_client.c:main:141:CLIENT RECIEVED: source=10 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x1c2f000 m1p2=(nil) m1p3=(nil) 
		 copy_client.c:main:143:CLIENT: buffer after=ABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJKLMNOPQRSTUVWX
		 copy_client.c:main:145:CLIENT END


 SOLO ESTA FALTANDO QUE LAS DVK_CALLS finalicen con ptrace(PTRACE_PTRACEME)

Atencion:
	Va a haber 3 tipos de compilacion de la dvklib cuando:
		1) Cuando se usa para compilar procesos estandares no tiene que tener prendido ningun CONFIG_XXXX 
		2) Para compilar los drivers del UML_KERNEL esta fijado CONFIG_UML_DVK  que viene fijado cuando se compila el UML_KERNEL
		3) Para compilar procesos de usuario de UML_USER se debe usar CONFIG_UML_USER y deshabilitar CONFIG_UML_DVK	
		
SOLUCION:
	Crear 3 tipos de librerias pero que usan el mismo fuente
		1) libdvklib.so
		2) libdvkuml.so
		3) libdvkuser.so



-D name
Predefine name as a macro, with definition 1.

-D name=definition
The contents of definition are tokenized and processed as if they appeared during translation phase three in a ‘#define’ directive. In particular, the definition is truncated by embedded newline characters.

If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell’s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With sh and csh, -D'name(args…)=definition' works.

-D and -U options are processed in the order they are given on the command line. All -imacros file and -include file options are processed after all -D and -U options.

-U name
Cancel any previous definition of name, either built in or provided with a -D option.

	
LISTO:
			gcc -g -shared -pthread -o libdvklib.so stub_dvkcall.o     
			gcc -g -shared -pthread -o libumldvk.so stub_umldvk.o     
			gcc -g -shared -pthread -o libuserdvk.so stub_userdvk.o 

Ahora hay que incluir la libreria correspondiente en cada programa dependiendo de su localizacion
y modificar stub_dvkcall.c para que contemple los diferentes tipos de ejecucion 
CONFIG_DVS_DVK 
CONFIG_UML_DVK 
CONFIG_UML_USER

==============================================================================================
20190620:		SE ARMO KILOMBO CON LA LIBRERIA DE DVK 

./rdisk: error while loading shared libraries: /usr/src/dvs/dvk-lib/stub_dvkcall.o: only ET_DYN and ET_EXEC can be loaded

==============================================================================================
20190621: 	Cambie el MAKEFILE de  /usr/src/dvs/dvk-lib

Solo genera librerias para DVK NATIVO y DVK UML_USER
No se genera libreria para DVK_KERNEL dado que el codigo es incorporado directamente como fuente 
no como objeto.


root@node0:/usr/src/dvs/dvk-proxies/test# ./uml_server 0 10
DEBUG 681:dvk_open:90: Open dvk device file /dev/dvk
DVK handle_dvk_enter MATCH __NR_open tracee_lpid=429 tracer_lpid=251 tmp_path=/dev/dvk flags=0 mode=4017ED5C
DVK handle_dvk_exit pid=429
handle_dvk_exit dvk_retcode=27
DEBUG 681:dvk_getdvsinfo:213: 
DVK handle_dvk_enter __NR_ioctl fd=27 cmd=8004E31B lpid=0
DVK handle_dvk_exit pid=429
handle_dvk_exit dvk_retcode=0
DEBUG 681:dvk_getdvsinfo:215: ioctl ret=0 errno=0
ERROR: 681:dvk_getdvsinfo:221: rcode=-1
ERROR: 681:dvk_getdvsinfo:221: rcode=-1
dvk_getdvsinfo error=-1 
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:256

ERROR: 681:dvk_getdvsinfo:221: rcode=-1
ERROR: 681:dvk_getdvsinfo:221: rcode=-1
#ifdef  CONFIG_UML_USER
	ret = ptrace(PTRACE_TRACEME,0,0,0);
	if (ret < 0) {ERROR_PRINT(-errno); ERROR_RETURN(ret);} <<<<<<<<<<<<<<<<<< 
#endif //  CONFIG_UML_USER




==============================================================================================
20190623:
		Al arrancar el uml_server 0 10 queda bloqueado el kernel.
		Luego, desde el host ejecuto copy_client 0 10 55 y lo rehabilita 
		
DEBUG 719:dvk_receive_T:683: endpoint=31438 timeout=-1
DVK handle_dvk_enter __NR_ioctl fd=29 cmd=4004E303 lpid=0 dvk_call=3 wait=2
DVK handle_dvk_wait pid=912

DEBUG 912:dvk_receive_T:688: ioctl ret=0 errno=0
[3]+  Stopped                 ./uml_server 0 10 <<<<<<<<<<<<<<<< STOPEADO, NO MUERTO 


root@node0:/usr/src/dvs/dvk-proxies/test# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2  9012/691    0    0   20 27342 27342 27342 27342 linux          
 0   3     3   579/579    0    8   20 31438 27342 27342 27342 rdisk          
 0  10    10  9978/912    0    0   20 27342 27342 27342 27342 linux  <<<<<<<<<<< ESTA STOPEADO         
 0  30    30  9020/699    0    0   20 27342 27342 27342 27342 linux 


BIND DE UML_SERVER 
	[65889.399119] DEBUG dvk_ioctl:201: cmd=4004E309 arg=BFB4CB08
	[65889.399120] DEBUG dvk_ioctl:221: DVK_CALL=9 (bind) 
	[65889.399121] DEBUG io_bind:97: 
	[65889.399124] DEBUG new_bind:1372: oper=0 dcid=0 param_pid=912 endpoint=10 nodeid=-1
	[65889.399126] DEBUG new_bind:1394: RLOCK_DC dc=0 count=0
	[65889.399128] DEBUG new_bind:1407: WLOCK_PROC ep=10 count=0
	[65889.399130] DEBUG init_proc_desc:16: p_name=$noname dcid=0
	[65889.399133] DEBUG new_bind:1441: param_pid=912 lpid=9978 vpid=912 tid=9978
	[65889.399134] DEBUG new_bind:1465: SELF_BIND param_pid=912 lpid=9978 vpid=912 tid=9978
	[65889.399136] DEBUG new_bind:1487: WUNLOCK_PROC ep=10 count=0
	[65889.399137] DEBUG new_bind:1490: WLOCK_TASK pid=9978 count=0
	[65889.399138] DEBUG new_bind:1491: WLOCK_PROC ep=10 count=0
	[65889.399139] DEBUG new_bind:1527: increment the reference count of the task struct=9978 count=2
	[65889.399141] DEBUG new_bind:1538: process p_name=linux *p_name_ptr=linux
	[65889.399143] DEBUG new_bind:1595: nr=10 endp=10 dcid=0 flags=0 misc=20 lpid=9978 vpid=912 nodeid=0 name=linux 
	[65889.399145] DEBUG new_bind:1596: nr=10 endp=10 dcid=0 lpid=9978 p_cpumask=FFFFFFFF nodemap=1 name=linux 
	[65889.399147] DEBUG new_bind:1610: WUNLOCK_TASK pid=9978 count=0
	[65889.399148] DEBUG new_bind:1616: WUNLOCK_PROC ep=10 count=0
	[65889.399149] DEBUG new_bind:1618: DC_INCREF counter=4
	[65889.399150] DEBUG new_bind:1619: RUNLOCK_DC dc=0 count=0

RECEIVE DE UML_SERVER 
	[65889.430196] DEBUG dvk_ioctl:201: cmd=4004E303 arg=BFB4CB20
	[65889.430200] DEBUG dvk_ioctl:221: DVK_CALL=3 (mini_receive) 
	[65889.430201] DEBUG io_mini_receive:35: 
	[65889.430203] DEBUG new_mini_receive:288: src_ep=31438
	[65889.430207] DEBUG check_caller:536: caller_pid=9978 caller_tgid=9978
	[65889.430208] DEBUG check_caller:572: WLOCK_PROC ep=10 count=0
	[65889.430210] DEBUG check_caller:601: WUNLOCK_PROC ep=10 count=0
	[65889.430211] DEBUG check_caller:604: dcid=0
	[65889.430212] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
	[65889.430213] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
	[65889.430214] DEBUG check_caller:618: caller_pid=9978 
	[65889.430216] DEBUG new_mini_receive:299: RLOCK_PROC ep=10 count=0
	[65889.430217] DEBUG new_mini_receive:303: caller_nr=10 caller_ep=10 src_ep=31438 
	[65889.430218] DEBUG new_mini_receive:307: dcid=0
	[65889.430219] DEBUG new_mini_receive:311: RUNLOCK_PROC ep=10 count=0
	[65889.430220] DEBUG new_mini_receive:313: RLOCK_DC dc=0 count=0
	[65889.430221] DEBUG new_mini_receive:316: RUNLOCK_DC dc=0 count=0
	[65889.430223] DEBUG new_mini_receive:366: WLOCK_PROC ep=10 count=0
	[65889.430224] DEBUG new_mini_receive:471: Any suitable message from 31438 was not found.
	[65889.430225] DEBUG sleep_proc:344: timeout=-1
	[65889.430227] DEBUG sleep_proc:355: BEFORE DOWN lpid=9978 p_sem=0 timeout=-1
	[65889.430228] DEBUG sleep_proc:357: endpoint=10 flags=8
	[65889.430229] DEBUG sleep_proc:361: WUNLOCK_PROC ep=10 count=0

SENDREC DEL COPY_CLIENT EN EL HOST 
	[65969.007070] DEBUG dvk_ioctl:221: DVK_CALL=5 (mini_sendrec) 
	[65969.007071] DEBUG io_mini_sendrec:56: 
	[65969.007072] DEBUG new_mini_sendrec:507: srcdst_ep=10
	[65969.007074] DEBUG check_caller:536: caller_pid=9991 caller_tgid=9991
	[65969.007075] DEBUG check_caller:572: WLOCK_PROC ep=55 count=0
	[65969.007076] DEBUG check_caller:601: WUNLOCK_PROC ep=55 count=0
	[65969.007077] DEBUG check_caller:604: dcid=0
	[65969.007078] DEBUG check_caller:608: RLOCK_DC dc=0 count=0
	[65969.007079] DEBUG check_caller:612: RUNLOCK_DC dc=0 count=0
	[65969.007080] DEBUG check_caller:618: caller_pid=9991 
	[65969.007081] DEBUG new_mini_sendrec:518: RLOCK_PROC ep=55 count=0
	[65969.007083] DEBUG new_mini_sendrec:523: caller_nr=55 caller_ep=55 srcdst_ep=10 
	[65969.007084] DEBUG new_mini_sendrec:526: RUNLOCK_PROC ep=55 count=0
	[65969.007085] DEBUG new_mini_sendrec:528: dcid=0
	[65969.007086] DEBUG new_mini_sendrec:532: RLOCK_DC dc=0 count=0
	[65969.007087] DEBUG new_mini_sendrec:535: RUNLOCK_DC dc=0 count=0
	[65969.007088] DEBUG new_mini_sendrec:550: WLOCK_PROC ep=55 count=0
	[65969.007090] DEBUG new_mini_sendrec:557: WUNLOCK_PROC ep=55 count=0
	[65969.007091] DEBUG new_mini_sendrec:557: WLOCK_PROC ep=10 count=0
	[65969.007092] DEBUG new_mini_sendrec:557: WLOCK_PROC ep=55 count=0
	[65969.007093] DEBUG new_mini_sendrec:558: srcdst_nr=10 srcdst_ep=10
	[65969.007094] DEBUG new_mini_sendrec:578: srcdst_ptr->p_usr.p_nodeid=0
	[65969.007095] DEBUG new_mini_sendrec:582: RLOCK_DC dc=0 count=0
	[65969.007096] DEBUG new_mini_sendrec:586: RUNLOCK_DC dc=0 count=0
	[65969.007098] DEBUG new_mini_sendrec:601: dcid=0 caller_pid=9991 caller_nr=55 srcdst_ep=10 
	[65969.007098] DEBUG new_mini_sendrec:606: SENDING HALF
	[65969.007099] DEBUG new_mini_sendrec:687: destination is waiting. Copy the message and wakeup destination
	[65969.007102] DEBUG copy_usr2usr:886: rqtr_ep=55 src_ep=55 src_lpid=9991 src_vpid=9991 src_addr=00da0000
	[65969.007104] DEBUG copy_usr2usr:889: dst_ep=10 dst_lpid=9978 dst_vpid=912 dst_addr=80006000 bytes=76
	[65969.007105] DEBUG copy_usr2usr:893: task_pid_nr(current)=9991
	[65969.007106] DEBUG copy_usr2usr:896: WRITE
	[65969.007107] DEBUG copy_usr2usr:901: task_pid_nr(dst_ptr->p_task)=9978
	[65969.023185] DEBUG dvk_vm_rw:441: pid=9978 liovcnt=1 riovcnt=1 flags=0 vm_write=1
	[65969.023304] DEBUG dvk_check_iovect:1280: type=1 nr_segs=1
	[65969.023306] DEBUG dvk_rw_check_kvector:862: type=1 nr_segs=1
	[65969.023307] DEBUG dvk_rw_check_kvector:862: type=-1 nr_segs=1
	[65969.023309] DEBUG dvk_vm_rw_core:277: pid=9978 riovcnt=1 flags=0 vm_write=1
	[65969.029726] DEBUG dvk_vm_rw_core:331: i=0 rc=0
	[65969.029743] DEBUG dvk_vm_rw_core:349: rc=76
	[65969.029744] DEBUG dvk_vm_rw_core:356: rc=76
	[65969.029746] DEBUG copy_usr2usr:954: len=76
	[65969.029748] DEBUG inherit_cpu:288: cpuid=0 vpid=ld
	[65969.029751] ERROR: 9991:inherit_cpu:292: rcode=-3
	[65969.029754] DEBUG inherit_cpu:296: nr=10 endp=10 dcid=0 lpid=9978 p_cpumask=FFFFFFFF nodemap=1 name=linux 
	[65969.029755] DEBUG new_mini_sendrec:693: BEFORE UP lpid=9978 p_sem=-1 rcode=76
	[65969.029766] DEBUG new_mini_sendrec:701: WUNLOCK_PROC ep=10 count=0
	[65969.029768] DEBUG sleep_proc:344: timeout=-1
	[65969.029769] DEBUG sleep_proc:355: BEFORE DOWN lpid=9991 p_sem=0 timeout=-1
	[65969.029771] DEBUG sleep_proc:357: endpoint=55 flags=8
	[65969.029772] DEBUG sleep_proc:361: WUNLOCK_PROC ep=55 count=0
	[65969.029778] DEBUG sleep_proc:368: endpoint=10 ret=0 p_rcode=76
	[65969.029779] DEBUG sleep_proc:369: endpoint=10 flags=0 cpuid=0
	[65969.029781] DEBUG sleep_proc:370: WLOCK_PROC ep=10 count=0
	[65969.029783] DEBUG sleep_proc:417: nr=10 endp=10 dcid=0 lpid=9978 p_cpumask=FFFFFFFF nodemap=1 name=linux 
	[65969.029784] DEBUG sleep_proc:419: someone wakeups me: sem=0 p_rcode=0
	[65969.029785] DEBUG new_mini_receive:488: WUNLOCK_PROC ep=10 count=0  <<< DESPERTO AL UML_SERVER 


Si luego desde UML le envio un SIGCONT 

root@node0:/usr/src/dvs/dvk-proxies/test# userspace - child stopped with signal 18
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:11
[3]+  Segmentation fault      ./uml_server 0 10


.....................................................................
		FUNCIONO OK - UNICO PROBLEMA: EL UML_KERNEL QUEDA BLOQUEADO 
		
root@node0:/usr/src/dvs/dvk-proxies/test# 
root@node0:/usr/src/dvs/dvk-proxies/test# ./uml_server 0 10
DEBUG 681:dvk_open:91: Open dvk device file /dev/dvk
DVK handle_dvk_enter MATCH __NR_open tracee_lpid=412 tracer_lpid=232 tmp_path=/dev/dvk flags=0 mode=4017CD5C
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=28
DEBUG 681:dvk_getdvsinfo:193: 
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E31B lpid=0 dvk_call=27 wait=1
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=0
DEBUG 681:dvk_getdvsinfo:195: ioctl ret=0 errno=0
DEBUG 681:dvk_getdvsinfo:200: ioctl ret=0
 copy_server.c:main:47:local_nodeid=0
 copy_server.c:main:48:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
DEBUG 681:dvk_getdcinfo:263: dcid=0
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30E lpid=0 dvk_call=14 wait=1
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=0
DEBUG 681:dvk_getdcinfo:267: ioctl ret=0 errno=0
DEBUG 681:dvk_getdcinfo:272: ioctl ret=0
 copy_server.c:main:58:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
 copy_server.c:main:59:flags=0 dc_nodes=3 dc_pid=574 dc_name=DC0
DEBUG 681:dvk_bind_X:925: cmd=0 dcid=0 pid=-1 endpoint=10 nodeid=-1
DVK handle_dvk_enter bind parm_cmd=0
DVK handle_dvk_enter bind parm_dcid=0
DVK handle_dvk_enter bind parm_pid=-1
DVK handle_dvk_enter bind parm_ep=10
DVK handle_dvk_enter bind parm_nodeid=-1
DVK handle_dvk_enter DVK_IOCSDVKBIND BEFORE fd=28 cmd=4004E309 pid=-1
DVK handle_dvk_enter DVK_IOCSDVKBIND AFTER  fd=28 cmd=4004E309 pid=0
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=10
DEBUG 681:dvk_bind_X:934: ioctl ret=10 errno=0
DEBUG 681:dvk_bind_X:946: ioctl ret=10
 copy_server.c:main:76:BIND SERVER dcid=0 svr_pid=681 svr_ep=10
DEBUG 681:dvk_getprocinfo:890: dcid=0 p_nr=10 
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30F lpid=0 dvk_call=15 wait=1
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=0
DEBUG 681:dvk_getprocinfo:895: ioctl ret=0 errno=0
DEBUG 681:dvk_getprocinfo:900: ioctl ret=0
 copy_server.c:main:85:nr=10 endp=10 dcid=0 flags=0 misc=20 lpid=3768 vpid=412 nodeid=0 name=linux 
 copy_server.c:main:93:SERVER m_ptr=0x80006000
 copy_server.c:main:115:SERVER: buffer before=0123456789012345678901234567890123456789012345678901
DEBUG 681:dvk_receive_T:683: endpoint=31438 timeout=-1
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E303 lpid=0 dvk_call=3 wait=2
DVK handle_dvk_wait pid=412
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=0
DEBUG 681:dvk_receive_T:688: ioctl ret=0 errno=0
DEBUG 681:dvk_receive_T:698: ioctl ret=0
 copy_server.c:main:119:SERVER: source=55 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0xd1b000 m1p2=(nil) m1p3=(nil) 
DEBUG 681:dvk_getprocinfo:890: dcid=0 p_nr=55 
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=8004E30F lpid=0 dvk_call=15 wait=1
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=0
DEBUG 681:dvk_getprocinfo:895: ioctl ret=0 errno=0
DEBUG 681:dvk_getprocinfo:900: ioctl ret=0
 copy_server.c:main:137:nr=55 endp=55 dcid=0 flags=8 misc=20 lpid=3770 vpid=3770 nodeid=0 name=copy_client 
DEBUG 681:dvk_vcopy:108: src_ep=55 dst_ep=35534 bytes=1024
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E30D lpid=0 dvk_call=13 wait=2
DVK handle_dvk_wait pid=412
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=1024
DEBUG 681:dvk_vcopy:116: ioctl ret=1024 errno=0
DEBUG 681:dvk_vcopy:125: ioctl ret=1024
 copy_server.c:main:144:SERVER: buffer received=abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvw
DEBUG 681:dvk_vcopy:108: src_ep=35534 dst_ep=55 bytes=1024
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E30D lpid=0 dvk_call=13 wait=2
DVK handle_dvk_wait pid=412
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=1024
DEBUG 681:dvk_vcopy:116: ioctl ret=1024 errno=0
DEBUG 681:dvk_vcopy:125: ioctl ret=1024
 copy_server.c:main:154:SERVER: buffer sent=ABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJKLMNOPQRSTUVWXYA
DEBUG 681:dvk_send_T:658: endpoint=55 timeout=-1
DVK handle_dvk_enter __NR_ioctl fd=28 cmd=4004E302 lpid=0 dvk_call=2 wait=2
DVK handle_dvk_wait pid=412
DVK handle_dvk_exit pid=412
handle_dvk_exit dvk_retcode=76
DEBUG 681:dvk_send_T:663: ioctl ret=76 errno=0
DEBUG 681:dvk_send_T:672: ioctl ret=76
 copy_server.c:main:163:SERVER END
DVK: exit_unbind local_nodeid:0
DVK: old_exit_unbind code:0

root@node0:/usr/src/dvs/dvk-proxies/test# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  -2    -2  3574/232    0    0   20 27342 27342 27342 27342 linux          
 0   3     3   610/610    0    8   20 31438 27342 27342 27342 rdisk          
 0  10    10  3768/412    0    8   20 31438 27342 27342 27342 linux     <<<<<<<<<<   
 0  30    30  3582/240    0    0   20 27342 27342 27342 27342 linux 
 
 
 PROBLEMA DE UML_KERNEL BLOQUEADO
 ================================
 Esto se debe a que cuando atiende un syscall UML,  se esta ejecutando el pseudo-kernel
 de UML, y si el proceso de usuario hizo una syscall bloqueante, el kernel UML lo sabe
 y hace el context switch.
 
 1) Ver si hay alguna forma de indicarle al UML_KERNEL de que bloquee al proceso UML_USER 
 para luego hacer el context switch.
	userspace(){
		while(1){
			// aqui el UML_USER deberia estar STOPEADO
			ptrace( PTRACE_SYSCALL); 	// UML_USER COMIENZA A EJECUTAR 
			ret = waitpid()				// UML_USER SE DETIENE AL INGRESAR 
			rcode = handle_dvk_enter()
			if( rcode == DVK_CMD_NOWAIT)
				handle_dvk_exit( pid, regs);
					continue;
			else  if( rcode == DVK_CMD_WAIT) { 
					handle_dvk_wait( pid, regs);
					handle_dvk_exit( pid, regs);
					continue;
			switch(ret)
				case TRAP+0X80:
					handle_trap(); ===> syscall // EMULATED SYSCALL 
			interrupt_end();		==========> schedule !!			
		}
	}	
 
	Se podria hacer lo siguiente:
		- detectada la DVK_CALL modificarla por algun syscall válido que espere
			tal como si el proceso original hubiese solicitado esperarlo, como por ejemplo
			semop(DOWN); con el semaforo en cero.
		- Cuando la DVK_CALL finaliza, hace un semop(UP); 	
 
 2) Hacer el driver UML_DVK, pero el problema es que en UML no se dispone de las funciones
 de kernel necesarias para implementarlo, por lo que se debería implementar como un modulo
 o driver fijo de kernel. Seria equivalente a un NODO autonomo, por lo tanto se comunicaria 
 con el exterior utilizando proxies. SI SE PUEDE !!!!!!!!!!!!!!!!!
 
 3) Emular DVK usando pipes en UML. El UML_KERNEL/UML_DVK fuonaria en forma similar al kernel
 de MOL como un HUB de mensajes, algunos de los cuales van a otros procesos dentro del UML 
 y otro van al HOST via proxy. Problema: como van los mensajes a otros nodos?? DESCARTADO !!!!!!!!!!!!!!!!!
 
 ==============================================================================================
20190720:
			Modifique el codigo el codigo de IPC en funcion de la compilacion de UML
			#ifndef CONFIG_UML_DVK	
		
		INICIALIZO EL DVS 
			root@node0:/usr/src/dvs/dvk-tests# ./test_dvs_init -n 2 -V 3 -N 4 -P 200 -T 20
			DEBUG 674:dvk_open:102: 
			Initializing DVS. Local node ID 2... 
			DEBUG 674:dvk_dvs_init:510: nodeid=2
			DEBUG 674:SYSC_ipc:163: ipc_dvs_init: call=6144 first=2 second=0 third=0 fifth=0 
			DEBUG 674:ipc_dvs_init:48: nodeid=0 second=0 third=0 fifth=0
			DEBUG 674:ipc_dvs_init:50: d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
			DEBUG 674:ipc_dvs_init:51: d_max_copybuf=65536 d_max_copylen=1048576
			DEBUG 674:ipc_dvs_init:52: d_dbglvl=7F306 version=4.9 sizeof(proc)=0
			DEBUG 674:ipc_dvs_init:65: d_nr_dcs=3 d_nr_nodes=4 d_nr_procs=200 d_nr_tasks=20 d_nr_sysprocs=64 
			DEBUG 674:ipc_dvs_init:66: d_max_copybuf=65536 d_max_copylen=1048576
			DEBUG 674:ipc_dvs_init:67: d_dbglvl=0 version=2.1 sizeof(proc)=0
			DEBUG 674:dvk_dvs_init:514: ipc ipc_op=71680 ret=2
			d_nr_dcs=3 d_nr_nodes=4 d_nr_procs=200 d_nr_tasks=20 d_nr_sysprocs=64 
			d_max_copybuf=65536 d_max_copylen=1048576
			d_dbglvl=0 version=2.1 sizeof(proc)=0
			Get DVS info
			DEBUG 674:dvk_getdvsinfo:238: 
			DEBUG 674:dvk_getdvsinfo:242: ipc ret=2
			local node ID 2... 
			d_nr_dcs=3 d_nr_nodes=4 d_nr_procs=200 d_nr_tasks=20 d_nr_sysprocs=64 
			d_max_copybuf=65536 d_max_copylen=1048576
			d_dbglvl=0 version=2.1 sizeof(proc)=488
	VERIFICO CORRECTO 		
			root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/info
			nodeid=2
			nr_dcs=3
			nr_nodes=4
			max_nr_procs=200
			max_nr_tasks=20
			max_sys_procs=64
			max_copy_buf=65536
			max_copy_len=1048576
			dbglvl=0
			version=2.1
			sizeof(proc)=488
			sizeof(proc) aligned=488
			sizeof(dc)=144
			sizeof(node)=80
			
		INICILIZO EL DC 	
			root@node0:/usr/src/dvs/dvk-tests# ./test_dc_init -d 0 -p 100 -t 20 -s 40 -n 2 -P 0 -N UMLDC0
			dc_dcid=0 dc_nr_procs=100 dc_nr_tasks=20 dc_nr_sysprocs=40 dc_nr_nodes=2
			flags=0 dc_nodes=0 dc_pid=0 dc_name=UMLDC0
			dc_dcid=0 dc_warn2proc=0 dc_warnmsg=-1
			DEBUG 676:dvk_open:102: 
			before dc_dcid=0 dc_nr_procs=100 dc_nr_tasks=20 dc_nr_sysprocs=40 dc_nr_nodes=2
			before flags=0 dc_nodes=0 dc_pid=0 dc_name=UMLDC0
			before dc_dcid=0 dc_warn2proc=0 dc_warnmsg=-1
			DEBUG 676:dvk_dc_init:175: 
			DEBUG 676:dvk_dc_init:179: ipc ret=2
			DC0 has been initialized on node 2
			DEBUG 676:dvk_getnodeinfo:356: nodeid=2
			ERROR: 676:check_caller:579: rcode=-310
			DEBUG 676:dvk_getnodeinfo:360: ipc ret=0
			n_nodeid=2 n_proxies=-1 n_flags=6 n_dcs=1 n_name=node2
			DEBUG 676:dvk_getdcinfo:331: dcid=0
			ERROR: 676:check_caller:579: rcode=-310
			DEBUG 676:dvk_getdcinfo:335: ipc ret=0
			after  dc_dcid=0 dc_nr_procs=100 dc_nr_tasks=20 dc_nr_sysprocs=40 dc_nr_nodes=2
			after  flags=0 dc_nodes=4 dc_pid=676 dc_name=UMLDC0
			after  dc_dcid=0 dc_warn2proc=0 dc_warnmsg=-1

	VERIFICO EL DC 
			root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/UMLDC0/info 
			dcid=0
			flags=0
			nr_procs=100
			nr_tasks=20
			nr_sysprocs=40
			nr_nodes=2
			dc_nodes=4
			dc_pid=676
			warn2proc=0
			warnmsg=-1
			dc_name=UMLDC0
			nodes 33222222222211111111110000000000
				  10987654321098765432109876543210
				  -----------------------------X--
			cpumask=1 


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ATENCION: 
	RDISK usa la variable GLOBAL local_nodeid del HOST para poder acceder a el.
	UML DVK IPC tambien tiene una variable GLOBAL local_nodeid !!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	
SOLUCION:
	SI SE USA RDISK , NO SE PUEDE UTILIZAR DVK_UML_IPC 
	
		#ifdef CONFIG_DVKIPC
			int rdisk_nodeid;
			rdisk_nodeid = dvk_getdvsinfo(dvsu_ptr);
			if( rdisk_nodeid < 0) ERROR_RETURN(rdisk_nodeid);
			DVKDEBUG(INTERNAL,"rdisk_nodeid=%d\n",rdisk_nodeid);	
			DVKDEBUG(INTERNAL, DVS_USR_FORMAT, DVS_USR_FIELDS(dvsu_ptr));	
		#else  // CONFIG_DVKIPC
			local_nodeid = dvk_getdvsinfo(dvsu_ptr);
			if( local_nodeid < 0) ERROR_RETURN(local_nodeid);
			DVKDEBUG(INTERNAL,"local_nodeid=%d\n",local_nodeid);	
			DVKDEBUG(INTERNAL, DVS_USR_FORMAT, DVS_USR_FIELDS(dvsu_ptr));	
		#endif // CONFIG_DVKIPC	

ANULANDO CONFIG_DVKIPC SE VE QUE PUEDE HACER EL BIND 
root@node0:/usr/src/linux# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0  30    30  6031/215    0    0   20 27342 27342 27342 27342 linux 	


#ifndef CONFIG_DVKIPC
device_initcall(rd_driver_init);
#endif // CONFIG_DVKIPC


		ALGUNAS PRUEBAS DE TRANSFERNCIA FUNCIONAN BIEN OTRAS NO
		root@node0:/usr/src/dvs/dvk-tests# ./test_sendrcv  0 10 55  
DEBUG 839:dvk_open:102: 
DEBUG 839:dvk_bind_X:1137: cmd=0 dcid=0 pid=-1 endpoint=10 nodeid=-1
DEBUG 839:dvk_bind_X:1141: ipc ret=10
PARENT BIND dcid=0 parent_pid=839 parent_nr=10 parent_ep=10 m_ptr=0x80004008
PARENT pause before SEND
DEBUG 840:dvk_bind_X:1137: cmd=0 dcid=0 pid=-1 endpoint=55 nodeid=-1
DEBUG 840:dvk_bind_X:1141: ipc ret=55
CHILD BIND dcid=0 child_pid=840 child_nr=55 child_ep=55 m_ptr=0x80004008
CHILD FIRST RECEIVE
DEBUG 840:dvk_receive_T:834: endpoint=31438 timeout=-1
PARENT FIRST SEND msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
DEBUG 839:dvk_send_T:803: endpoint=55 timeout=-1
DEBUG dvk_vm_rw:442: pid=840 liovcnt=1 riovcnt=1 flags=0 vm_write=1
DEBUG dvk_check_iovect:1280: type=1 nr_segs=1
DEBUG dvk_rw_check_kvector:862: type=1 nr_segs=1
DEBUG dvk_rw_check_kvector:862: type=-1 nr_segs=1
DEBUG dvk_vm_rw_core:277: pid=840 riovcnt=1 flags=0 vm_write=1
DEBUG dvk_vm_rw_core:331: i=0 rc=0
DEBUG dvk_vm_rw_core:349: rc=76
DEBUG dvk_vm_rw_core:356: rc=76
DEBUG 839:dvk_send_T:807: ipc ret=76
PARENT SECOND SEND msg:source=10 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
DEBUG 839:dvk_send_T:803: endpoint=55 timeout=-1
DEBUG 840:dvk_receive_T:838: ipc ret=0
CHILD RECEIVE msg:source=10 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
CHILD SECOND RECEIVE
DEBUG 840:dvk_receive_T:834: endpoint=31438 timeout=-1
DEBUG dvk_vm_rw:442: pid=839 liovcnt=1 riovcnt=1 flags=0 vm_write=0
DEBUG dvk_check_iovect:1280: type=0 nr_segs=1
DEBUG dvk_rw_check_kvector:862: type=0 nr_segs=1
DEBUG dvk_rw_check_kvector:862: type=-1 nr_segs=1
DEBUG dvk_vm_rw_core:277: pid=839 riovcnt=1 flags=0 vm_write=0
DEBUG dvk_vm_rw_core:331: i=0 rc=0
DEBUG dvk_vm_rw_core:349: rc=76
DEBUG dvk_vm_rw_core:356: rc=76
DEBUG 840:dvk_receive_T:838: ipc ret=0
CHILD RECEIVE msg:source=10 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
DEBUG 839:dvk_send_T:807: ipc ret=0

		Hay errores en /proc despues de ejecutar las pruebas 
		root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   0     0     0/0      0    0    0     0     0 1205249580     0 ÿÿÿÿÿÿÿÿ       
 0   0     0     0/0      0    0    0     0     0 1205251628     0 ÿÿÿÿÿÿÿÿ       
 0   0     0     0/0      0    0    0     0     0 1205263148     0 ÿÿÿÿÿÿÿÿ 

 ==============================================================================================
20190722:
		TRANTANDO DE PROBAR EL ACCESO A RED DE UML 
		BASADO EN : POSIBILIDADES DE EXPERIMENTACION EN REDES TCPIP BAJO USER MODE LINUX
		
		HACER ESTOS COMANDO EN CONSOLA!! No en SSH porque luego se cae 
		
		EN EL HOST (node0):
		tunctl -u root -t HTAP
		brctl addbr bridge1
		ifconfig HTAP 0.0.0.0 up
		ifconfig eth0 0.0.0.0 up
		brctl addif bridge1 HTAP
		brctl addif bridge1 eth0
		
		EN OTRA SESION, ARRANCAR UML 
		cd /usr/src/linux
		. /dev/shm/DC0.sh
		nsenter -p -t $DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null umid=node1 ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 eth0=tuntap,HTAP,fe:fd:c0:a8:00:fd nosysemu

		EN UML (node0)
		ifconfig eth0 192.168.1.101 netmask 255.255.255.0 up
		
		EN EL HOST:
		ifconfig eth0 192.168.1.100 netmask 255.255.255.0  up
		ifconfig bridge1 192.168.1.10 netmask 255.255.255.0 up
		route add -host 192.168.1.101 dev bridge1
		
		LUEGO PROBAR EL PING QUE FUNCIONA !!!
		
		Para montar el disco en RDWR
		mount -o remount,rw /dev/ubda /
	
==============================================================================================
20190727:
			AGREGO A LA VM una 2da placa Ethernet (eth1) para conectar al UML 
			Modifique el script dvk-tests/tests.sh para que levanten TCP PROXY. 
			Tuve que modificar los archivos /etc/hosts para cambiar la direccion
			de RED A 192.168.0.X porque el proxy TCP funciona con ese archivo
			
	EN EL HOST (node0):
		tunctl -u root -t HTAP
		brctl addbr bridge1
		ifconfig HTAP 0.0.0.0 up
		brctl addif bridge1 HTAP
		
	//	ifconfig eth1 0.0.0.0 up
	//	brctl addif bridge1 eth1
		
	EN OTRA SESION, ARRANCAR UML 
		cd /usr/src/linux
		. /dev/shm/DC0.sh
		nsenter -p -t $DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null umid=node1 ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 eth0=tuntap,HTAP,fe:fd:c0:a8:00:fd nosysemu

	EN UML (node0)
		Para montar el disco en RDWR
mount -o remount,rw /dev/ubda /
ifconfig eth0 192.168.0.101 netmask 255.255.255.0 up
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.0.10   
		 
	EN EL HOST:
	//	ifconfig eth1 192.168.0.100 netmask 255.255.255.0  up
		ifconfig bridge1 192.168.0.10 netmask 255.255.255.0 up
		route add -host 192.168.0.101 dev bridge1
	
		LUEGO PROBAR EL PING QUE FUNCIONA !!!
		
		
	EN UML 
		root@node1:~# cd /usr/src/dvs/dvk-tests/
		root@node1:/usr/src/dvs/dvk-tests# ./tests.sh 1 0         
		root@node1:/usr/src/dvs/dvk-tests# ./test_dc_init
		

	EN UML 
root@node1:/usr/src/dvs/dvk-proxies/test# netstat -natp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:3000            0.0.0.0:*               LISTEN      706/./tcp_proxy     
tcp        0      0 192.168.0.101:36730     192.168.0.100:3001      ESTABLISHED 705/./tcp_proxy  
	EN HOST 
root@node0:/usr/src/dvs/dvk-proxies/test# netstat -natp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN      838/./tcp_proxy     
tcp        0      0 192.168.0.100:3001      192.168.0.101:36730     ESTABLISHED 838/./tcp_proxy     
tcp        0      1 192.168.0.10:56492      192.168.0.101:3000      SYN_SENT    837/./tcp_proxy  <<< ENVIO SYC PERO NO LO ACEPTO 
   

	ESTO INDICA QUE ALGO ANDA MAL EN UML
	
	VOY A INSTALAR SSH EN UML 
	
	mount /dev/sdb6 /mnt
	mount --bind /dev /mnt/dev
	mount --bind /proc /mnt/proc
	mount --bind /sys /mnt/sys
	chroot /mnt
	apt-get install ssh 
	
	
	AL REBOOTEAR UML DUREANTE EL ARRANQUE TIRA 
	TCP: request_sock_TCP: Possible SYN flooding on port 3000. Dropping request.  Check SNMP counters.
		
	echo "net.ipv4.tcp_syncookies = 0" >> /etc/sysctl.conf 
	echo "net.ipv4.tcp_max_syn_backlog = 32765" >> /etc/sysctl.conf 
	echo "net.ipv4.tcp_fin_timeout = 30" >> /etc/sysctl.conf 
	echo "net.core.somaxconn = 4096" >> /etc/sysctl.conf 
	 sysctl -p /etc/sysctl.conf
	 
	 
	 root@node1:/usr/src/dvs/dvk-tests# netstat -natp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      656/sshd            
tcp        0      0 0.0.0.0:3000            0.0.0.0:*               LISTEN      681/./tcp_proxy     
tcp        0      0 192.168.0.101:22        192.168.0.10:36036      ESTABLISHED 728/sshd: root@pts/  <<<< 
tcp        0      0 192.168.0.101:55850     192.168.0.100:3001      ESTABLISHED 680/./tcp_proxy

	COMO SE VE EN UML, EL NODO QUE ESTABLECE EL SSH ES EL DEL  bridge1!!! 
	bridge1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.10  netmask 255.255.255.0  broadcast 192.168.0.255
        inet6 fe80::20c:29ff:fe9a:7aae  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:9a:7a:ae  txqueuelen 1000  (Ethernet)
        RX packets 217  bytes 26991 (26.3 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 290  bytes 25452 (24.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

	en el HOST
	root@node0:~# netstat -nat
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN     
tcp        0      0 192.168.0.10:36036      192.168.0.101:22        ESTABLISHED 	SALE CON DIRECCION 10!!!
tcp        0      1 192.168.0.10:52010 <<<<     192.168.0.101:3000      SYN_SENT   	SALE CON DIRECCION 10!!!
tcp        0      0 192.168.0.100:3001      192.168.0.101:55850     ESTABLISHED		SALE OK


	EN EL HOST 
	root@node0:~# netstat -nat | grep :300
tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN     
tcp        0      1 192.168.0.10:36422      192.168.0.101:3000      SYN_SENT   		SALE CON DIRECCION 10!!!
tcp        0      0 192.168.1.100:3001      192.168.0.101:38446     ESTABLISHED		INGRESA CON DIRECCION 100

	EN UML 
root@node1:/usr/src/dvs/dvk-tests# netstat -nat
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3000            0.0.0.0:*               LISTEN     
tcp        0      0 192.168.0.101:38446     192.168.1.100:3001      ESTABLISHED 	CONECTADO A LA 100 

POSIBLE SOLUCION:
	HACER QUE EL PROXY SENDER SETEE LA DIRECCION DE LA INTERFACE ETH0=NODE0=192.168.1.100 y no la del bridge.
	
	#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int getsockopt(int sockfd, int level, int optname, void *optval,socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
		 
	SO_BINDTODEVICE
Bind this socket to a particular device like "eth0", as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ. If a socket is bound to an interface, only packets received from that particular interface are processed by the socket. Note that this only works for some socket types, particularly AF_INET sockets. It is not supported for packet sockets (use normal bind(2) there).
Before Linux 3.8, this socket option could be set, but could not retrieved with getsockopt(2). Since Linux 3.8, it is readable. The optlen argument should contain the buffer size available to receive the device name and is recommended to be IFNAMSZ bytes. The real device name length is reported back in the optlen argument.

  /* bind the socket to one network device */
  const char device[] = MY_DEVICE;
  rc=setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, device, sizeof(device));
  if (rc != 0) 
  {
     printf ("%s: could not set SO_BINDTODEVICE (%s)\n",
        argv[0], strerror(errno));
     exit (EXIT_FAILURE);
  }
  printf ("SO_BINDTODEVICE set\n");
  /* verify SO_BINDTODEVICE setting */
  rc = getsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, (void *)buffer, &opt_length);
  if (rc != 0) 
  {
     printf ("%s: could not get SO_BINDTODEVICE (%s)\n",
        argv[0], strerror(errno));
     exit (EXIT_FAILURE);
  }
  if (rc == 0) 
  {
    printf("SO_BINDTODEVICE is: %s\n", buffer);
  }
  
		
https://stackoverflow.com/questions/1207746/problems-with-so-bindtodevice-linux-socket-option
		
		
CONFIG_INET_TCP_DIAG=y
# CONFIG_TCP_CONG_ADVANCED is not set
CONFIG_TCP_CONG_CUBIC=y
CONFIG_DEFAULT_TCP_CONG="cubic"
# CONFIG_TCP_MD5SIG is not set

  x Type  : boolean                                                           x
  x Prompt: IP: TCP syncookie support                                         x
  x   Location:                                                               x
  x     -> Networking support (NET [=y])                                      x
  x       -> Networking options                                               x
  x (1)     -> TCP/IP networking (INET [=y])                                  x
  x   Defined at net/ipv4/Kconfig:263                                         x
  x   Depends on: NET [=y] && INET [=y]                                       x
  x   Selected by: IP_NF_TARGET_SYNPROXY [=n] && NET [=y] && INET [=y] && NET
  

==============================================================================================
20190730: no funciona el proxy TCP aun cambiando parametros
	
	PROBAR CON TIPC que ahora esta habilitado.
	root@node0:/usr/src/linux# grep TIPC .config
		CONFIG_TIPC=y
		CONFIG_TIPC_MEDIA_UDP=y

	TAMPOCO FUNCION CON TIPC 
		Puede ser porque no estan en la misma LAN 
	
=============================================================================================
20190730: no funciona el proxy TIPC aun haciendo 

As it turns out, it's a bug in the igmp snooping code in the kernel that's
the problem with multicast traffic not being forwarded.
This seems to affect recent versions. To check if it's turned on, run
cat /sys/devices/virtual/net/<bridgename>/bridge/multicast_snooping

If it's 1, it's highly this is the culprit causing the non-propagation of
the multicast traffic. The solution is to turn it off by setting it 0.
echo 0 > /sys/devices/virtual/net/<bridge name>/bridge/multicast_snooping


TODO:
		Volver a utilizar proxy TCP en tests.sh 
		Habilitar el bridge pero sin ningun tipo de ruta.
		echo 0 > /sys/devices/virtual/net/<bridge name>/bridge/multicast_snooping
		cambiar el hosts para que las direcciones sean todas 192.168.0.X 
				
		tunctl -u root -t HTAP
		brctl addbr br0
		echo 0 > /sys/devices/virtual/net/br0/bridge/multicast_snooping
		ifconfig HTAP 0.0.0.0 up
		brctl addif br0 HTAP	
		ifconfig br0 192.168.0.100 netmask 255.255.255.0 promisc up 
		
		EN LA CONSOLA DEL HOST (node0):
		root@node0:~# cd /usr/src/dvs/dvk-tests/
		root@node0:/usr/src/dvs/dvk-tests# ./tests.sh 0 0 		
		DETENER ANTES DE EJECUTAR LOS PROXIES !!!!! 
		
		EN OTRA SESION, ARRANCAR UML 
		cd /usr/src/linux
		. /dev/shm/DC0.sh
		nsenter -p -t $DC0 ./linux con0=null,fd:2 con1=fd:0,fd:1 con=null ssl=null umid=node1 ubda=/dev/sdb6 mem=1024M dcid=0 uml_ep=-2 rd_ep=3 eth0=tuntap,HTAP,fe:fd:c0:a8:00:fd nosysemu

		EN UML (node0)
		Para montar el disco en RDWR
mount -o remount,rw /dev/ubda /
ifconfig eth0 192.168.0.101 netmask 255.255.255.0 up
		// route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.0.10   

	
		LUEGO PROBAR EL PING !!!
			
		
	EN UML 
cd /usr/src/dvs/dvk-tests/
./tests.sh 1 0      

	CONTINUAR EN CONSOLA DE node0 HASTA TERMINAR 		
	EN LA CONSOLA DEL HOST (node0):
		cd /usr/src/dvs/dvk-tests/
		./test_rmtbind  0 55 1 client
		cd /usr/src/dvs/dvk-proxies/test/
		. /dev/shm/DC0.sh
		nsenter -p -t $DC0 ./copy_server 0 10
		
	EN UML 
		./test_dc_init
		./test_add_node 0 0
		./test_rmtbind 0 10 0 server
		cd /usr/src/dvs/dvk-proxies/test/
		./copy_client 0 10 55
				
root@node0:/usr/src/dvs/dvk-proxies/test# netstat -nat
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN     
tcp        0      0 192.168.0.100:39908     192.168.0.101:3000      ESTABLISHED
tcp        0      0 192.168.0.100:3001      192.168.0.101:38162     ESTABLISHED

en UML 
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3000            0.0.0.0:*               LISTEN     
tcp        0      0 192.168.0.101:38162     192.168.0.100:3001      ESTABLISHED
tcp        0      0 192.168.0.101:3000      192.168.0.100:39908     ESTABLISHED

FUNCIONO CON PROXY TCP !!!!!


CON PROXY TIPC DA LO SIGUIENTE
root@node1:/usr/src/dvs/dvk-proxies/test# ./copy_client 0 10 55                
DEBUG 701:dvk_open:102: 
DEBUG 701:dvk_getdvsinfo:238: 
DEBUG 701:SYSC_ipc:163: ipc_getdvsinfo: call=6912 first=0 second=0 third=0 fifth=0 
DEBUG 701:ipc_getdvsinfo:1834: local_nodeid=1 
DEBUG 701:dvk_getdvsinfo:242: ipc ret=1
 copy_client.c:main:37:local_nodeid=1
 copy_client.c:main:38:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
DEBUG 701:dvk_getdcinfo:331: dcid=0
DEBUG 701:SYSC_ipc:163: ipc_getdcinfo: call=3584 first=0 second=0 third=0 fifth=0 
DEBUG 701:ipc_getdcinfo:1868: dcid=0 
DEBUG 701:check_caller:545: caller_pid=701 caller_tgid=701
ERROR: 701:check_caller:579: rcode=-310
DEBUG 701:ipc_getdcinfo:1886: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_getdcinfo:1888: RUNLOCK_DC dc=0 count=0
DEBUG 701:dvk_getdcinfo:335: ipc ret=0
 copy_client.c:main:48:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
 copy_client.c:main:49:flags=0 dc_nodes=3 dc_pid=692 dc_name=DC0
DEBUG 701:dvk_bind_X:1137: cmd=0 dcid=0 pid=-1 endpoint=55 nodeid=-1
DEBUG 701:SYSC_ipc:163: ipc_bind: call=2304 first=0 second=0 third=-1 fifth=-1 
DEBUG 701:ipc_bind:1407: oper=0 dcid=0 param_pid=-1 endpoint=55 nodeid=-1
DEBUG 701:ipc_bind:1429: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_bind:1442: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:init_proc_desc:25: p_name=$noname dcid=0
DEBUG 701:ipc_bind:1476: param_pid=-1 lpid=701 vpid=701 tid=701
DEBUG 701:ipc_bind:1500: SELF_BIND param_pid=-1 lpid=701 vpid=701 tid=701
DEBUG 701:ipc_bind:1522: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_bind:1525: WLOCK_TASK pid=701 count=0
DEBUG 701:ipc_bind:1526: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_bind:1562: increment the reference count of the task struct=701 count=2
DEBUG 701:ipc_bind:1573: process p_name=copy_client *p_name_ptr=copy_client
DEBUG 701:ipc_bind:1630: nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
DEBUG 701:ipc_bind:1631: nr=55 endp=55 dcid=0 lpid=701 p_cpumask=1 nodemap=2 name=copy_client 
DEBUG 701:ipc_bind:1645: WUNLOCK_TASK pid=701 count=0
DEBUG 701:ipc_bind:1651: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_bind:1653: DC_INCREF counter=2
DEBUG 701:ipc_bind:1654: RUNLOCK_DC dc=0 count=0
DEBUG 701:dvk_bind_X:1141: ipc ret=55
 copy_client.c:main:78:BIND CLIENT dcid=0 clt_pid=701 clt_ep=55
DEBUG 701:dvk_getprocinfo:1096: dcid=0 p_nr=55 
DEBUG 701:SYSC_ipc:163: ipc_getprocinfo: call=3840 first=0 second=55 third=0 fifth=0 
DEBUG 701:ipc_getprocinfo:1958: dcid=0 p_nr=55
DEBUG 701:check_caller:545: caller_pid=701 caller_tgid=701
DEBUG 701:check_caller:581: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:610: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:613: dcid=0
DEBUG 701:check_caller:617: RLOCK_DC dc=0 count=0
DEBUG 701:check_caller:621: RUNLOCK_DC dc=0 count=0
DEBUG 701:check_caller:627: caller_pid=701 
DEBUG 701:ipc_getprocinfo:1975: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_getprocinfo:1980: RUNLOCK_DC dc=0 count=0
DEBUG 701:ipc_getprocinfo:1982: RLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_getprocinfo:1983: lpid=701 name=copy_client
DEBUG 701:ipc_getprocinfo:1985: RUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:dvk_getprocinfo:1100: ipc ret=0
 copy_client.c:main:87:nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
DEBUG 701:dvk_wait4bindep_X:569: cmd=0 endpoint=10 timeout=30000
DEBUG 701:SYSC_ipc:163: ipc_wait4bind: call=7424 first=0 second=10 third=30000 fifth=0 
DEBUG 701:ipc_wait4bind:2136: oper=0 other_ep=10 timeout_ms=30000
DEBUG 701:check_caller:545: caller_pid=701 caller_tgid=701
DEBUG 701:check_caller:581: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:610: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:613: dcid=0
DEBUG 701:check_caller:617: RLOCK_DC dc=0 count=0
DEBUG 701:check_caller:621: RUNLOCK_DC dc=0 count=0
DEBUG 701:check_caller:627: caller_pid=701 
DEBUG 701:ipc_wait4bind:2150: caller_pid=701 ret=0
DEBUG 701:ipc_wait4bind:2169: RLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_wait4bind:2173: caller_nr=55 caller_ep=55 other_ep=10 
DEBUG 701:ipc_wait4bind:2178: RUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_wait4bind:2180: dcid=0
DEBUG 701:ipc_wait4bind:2184: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_wait4bind:2196: RUNLOCK_DC dc=0 count=0
DEBUG 701:ipc_wait4bind:2198: WLOCK_PROC ep=10 count=1223601875
DEBUG 701:ipc_wait4bind:2198: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_wait4bind:2205: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_wait4bind:2205: WUNLOCK_PROC ep=10 count=1223601875
DEBUG 701:dvk_wait4bindep_X:573: ipc ret=10
 copy_client.c:main:91:dvk_wait4bindep_T ret=10
DEBUG 701:dvk_getprocinfo:1096: dcid=0 p_nr=10 
DEBUG 701:SYSC_ipc:163: ipc_getprocinfo: call=3840 first=0 second=10 third=0 fifth=0 
DEBUG 701:ipc_getprocinfo:1958: dcid=0 p_nr=10
DEBUG 701:check_caller:545: caller_pid=701 caller_tgid=701
DEBUG 701:check_caller:581: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:610: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:613: dcid=0
DEBUG 701:check_caller:617: RLOCK_DC dc=0 count=0
DEBUG 701:check_caller:621: RUNLOCK_DC dc=0 count=0
DEBUG 701:check_caller:627: caller_pid=701 
DEBUG 701:ipc_getprocinfo:1975: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_getprocinfo:1980: RUNLOCK_DC dc=0 count=0
DEBUG 701:ipc_getprocinfo:1982: RLOCK_PROC ep=10 count=1223601875
DEBUG 701:ipc_getprocinfo:1983: lpid=-1 name=server
DEBUG 701:ipc_getprocinfo:1985: RUNLOCK_PROC ep=10 count=1223601875
DEBUG 701:dvk_getprocinfo:1100: ipc ret=0
 copy_client.c:main:99:nr=10 endp=10 dcid=0 flags=1000 misc=0 lpid=-1 vpid=-1 nodeid=0 name=server 
 copy_client.c:main:107:CLIENT m_ptr=0x80006000
 copy_client.c:main:129:CLIENT: buffer before=abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstu
 copy_client.c:main:133:CLIENT SENT: source=0 type=0 m1i1=1024 m1i2=0 m1i3=0 m1p1=0x80007000 m1p2=(nil) m1p3=(nil) 
DEBUG 701:dvk_sendrec_T:866: endpoint=10 timeout=-1
DEBUG 701:SYSC_ipc:163: ipc_mini_sendrec: call=1280 first=10 second=0 third=0 fifth=-1 
DEBUG 701:ipc_mini_sendrec:523: srcdst_ep=10
DEBUG 701:check_caller:545: caller_pid=701 caller_tgid=701
DEBUG 701:check_caller:581: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:610: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:check_caller:613: dcid=0
DEBUG 701:check_caller:617: RLOCK_DC dc=0 count=0
DEBUG 701:check_caller:621: RUNLOCK_DC dc=0 count=0
DEBUG 701:check_caller:627: caller_pid=701 
DEBUG 701:ipc_mini_sendrec:534: RLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_mini_sendrec:539: caller_nr=55 caller_ep=55 srcdst_ep=10 
DEBUG 701:ipc_mini_sendrec:542: RUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_mini_sendrec:544: dcid=0
DEBUG 701:ipc_mini_sendrec:548: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_mini_sendrec:551: RUNLOCK_DC dc=0 count=0
DEBUG 701:ipc_mini_sendrec:566: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_mini_sendrec:573: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_mini_sendrec:573: WLOCK_PROC ep=10 count=1223601875
DEBUG 701:ipc_mini_sendrec:573: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_mini_sendrec:574: srcdst_nr=10 srcdst_ep=10
DEBUG 701:ipc_mini_sendrec:594: srcdst_ptr->p_usr.p_nodeid=0
DEBUG 701:ipc_mini_sendrec:598: RLOCK_DC dc=0 count=0
DEBUG 701:ipc_mini_sendrec:602: RUNLOCK_DC dc=0 count=0
DEBUG 701:ipc_mini_sendrec:617: dcid=0 caller_pid=701 caller_nr=55 srcdst_ep=10 
DEBUG 701:ipc_mini_sendrec:622: SENDING HALF
DEBUG 701:ipc_mini_sendrec:633: RLOCK_PROC ep=27342 count=0
DEBUG 701:ipc_mini_sendrec:647: RUNLOCK_PROC ep=27342 count=0
DEBUG 701:ipc_mini_sendrec:649: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_mini_sendrec:649: WUNLOCK_PROC ep=10 count=1223601875
ERROR: 701:ipc_mini_sendrec:650: rcode=-64
DEBUG 701:dvk_sendrec_T:870: ipc ret=-1
ERROR: 701:dvk_sendrec_T:888: rcode=-1
CLIENT: dvk_send ret=-1
DEBUG 701:ipc_exit_unbind:240: code=256
DEBUG 701:ipc_exit_unbind:244: WLOCK_TASK pid=701 count=0
DEBUG 701:ipc_exit_unbind:250: RLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_exit_unbind:251: nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
DEBUG 701:ipc_exit_unbind:284:  Exiting endpoint=55 lpid=701
DEBUG 701:ipc_exit_unbind:286: RUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_exit_unbind:287: WLOCK_DC dc=0 count=0
DEBUG 701:ipc_exit_unbind:288: WLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_exit_unbind:295:  endpoint=55 lpid=701
DEBUG 701:do_unbind:682: nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
DEBUG 701:do_unbind:711: Caller nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
DEBUG 701:do_unbind:750: wakeup with error those processes trying to send a message to the proc
DEBUG 701:do_unbind:777: delete notify messages bits sent by the proc
DEBUG 701:do_unbind:825: WUNLOCK_PROC ep=10 count=1223601875
DEBUG 701:do_unbind:825: WUNLOCK_PROC ep=0 count=1223602131
DEBUG 701:do_unbind:782: Skip, self process
DEBUG 701:do_unbind:825: WUNLOCK_PROC ep=0 count=1223613651
DEBUG 701:do_unbind:829: nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
DEBUG 701:do_unbind:885: wakeup with error those processes waiting this process MIGRATION
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
DEBUG 701:do_unbind:934: wakeup those processes waiting this process UNBINDING
DEBUG 701:do_unbind:969: nr=55 endp=55 dcid=0 flags=0 misc=20 lpid=701 vpid=701 nodeid=1 name=copy_client 
DEBUG 701:init_proc_desc:25: p_name=copy_client dcid=0
DEBUG 701:do_unbind:971: initialized 
DEBUG 701:do_unbind:972: DC_DECREF counter=2
DEBUG 701:ipc_exit_unbind:359: WUNLOCK_PROC ep=55 count=1223613395
DEBUG 701:ipc_exit_unbind:360: WUNLOCK_TASK pid=701 count=0
DEBUG 701:ipc_exit_unbind:361: WUNLOCK_DC dc=0 count=0


		
 ====================================  ULTIMO_LOG ===================================

TAREAS A REALIZAR
=================

TODO: Revisar el codigo de UML DVK para que los tipos de CONFIG_XXXXX sean los correctos
CONFIG_DVKIPC=y
CONFIG_UML_DVK=y
CONFIG_UML_RDISK=y

Hay que tener 3 versiones de DVK
  1- Usando IOCTL cargando desde modulo
  2- Usando IPC cargando desde modulo
  3- Usando IPC embebido en el mismo kernel para que pueda usarlo UML 
  
1) Probar el kernel normal usando IPC DVK (LISTO)
2) Probar el UML usando IPC DVK (LISTO)
3) Probar el proxy que usa IPC DVK (PARCIAL) 
		º probar IPC y VCOPY masivo de dvk-proxy/tests  
		º probar la conexion con un nodo remoto al host 
4) Probar modificar el DVK para que soporte SLEEP() en modo usuario y SIGNAL para despertarlo.
5) Hacer el driver TAP remoto (CONSTANZA)
6) UML_SWITCH: usar M3-IPC como transport en lugar de UNIX SOCKET (daemon driver)
7) Hacer uso del FS REMOTO TIPO MSDOS O MINIX  

segun jeff DIKE  
It would be straightforward to put a network link
between the kernel and usermode pieces of hostfs,
allowing UML to directly mount remote filesystems.
https://elixir.bootlin.com/linux/v4.9.88/source/fs/hostfs


ATENCION: PARA LAS BENCHMARKS UTILIZAR TCP PROXY + BATCH + COMPRESSION + AUTOBIND 
 
La idea es que los procesos UML_USER se registren (bind) en el kernel del HOST.
Las dvk_calls() no bloqueantes no representan hoy un problema.
El problema se da con los bloqueantes. 
Antes, un  ERESTARTSYS se enviaba a los procesos en espera. 
Esto hoy se anulo,  bloqueando SIGALARM.
Habria que hacer lo siguiente.

- Crear un nuevo tipo de registración de proceso. Los tipos actuales son:
Com.h 
#define SELF_BIND		0
#define LCL_BIND		1
#define RMT_BIND		2
#define BKUP_BIND		3
#define REPLICA_BIND	4
#define MAX_BIND_TYPE	REPLICA_BIND

La idea seria utilizar 0x0F como máscara para el tipo de BIND
Con 0x10 que indica que el proceso este bindeado en UML

Com.h 
#define    BIND_UMLBIT		5 
#define    BIND_UMLMASK		( 1 << BIND_UMLBIT)
Bind_type = BIND_UMLMASK | bind_orig;

if( test_bit( BIND_UMLBIT, &bind_type )
	set_bit(MIS_BIT_USERMODE, &proc_ptr->p_misc_flags); // proxy_sts.h 

Para que esto sea transparente, en userspace() del UML al detectar la dvk_bind
Deberia modificarse incorporando el BIND_UMLBIT al tipo.

En
int sleep_proc(struct proc *proc, long timeout) 
int sleep_proc2(struct proc *proc, struct proc *other , long timeout)  
int sleep_proc3(struct proc *proc, struct proc *other1, struct proc *other2 , long timeout) 

	if( test_bit(MIS_BIT_USERMODE, &proc->p_usr.p_misc_flags)){
		proc->p_rcode = EDVSAGAIN; 
		return(EDVSAGAIN);
	}

Supongamos que el UML_USER hizo un dvk_receive(src_ep, &msg, timeout)
Se podría hacer de  la  siguiente manera en la libreria.
dvk_receive(src_ep, &msg, timeout)
{
	Ret = ipc_receive(src_ep, &msg, FOREVER)
	if( ret != EDVSAGAIN) 	// es porque no habia ningun mensaje y el kernel DVK
		return(ret)			// dejo los p_misc_flags MIS_BIT_USERWAIT del proceso 
							// en espera. El proceso debe estar en estado RUNNING
							// para que la contraparte se bloquee 
	if( timeout = NOWAIT) return(ret);
	if( timeout == FOREVER)  Timeout = 999999;
	sleep(timeout/1000)
	Ret = ipc_receive(src, &msg, NOWAIT)
	return(ret);
}

A la salida del ipc_receive()

	if( test_bit(MIS_BIT_USERMODE, &proc->p_usr.p_misc_flags)){
		set_bit(MIS_BIT_USERWAIT, &caller_ptr->p_usr.p_misc_flags);
	}

	set_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
	clear_bit(MIS_BIT_NOTIFY, &caller_ptr->p_usr.p_misc_flags);
	caller_ptr->p_usr.p_getfrom = src_ep;
	caller_ptr->p_rcode			= OK;

	DVKDEBUG(GENERIC,"Any suitable message from %d was not found.\n", src_ep);	
	sleep_proc(caller_ptr, timeout_ms); <<< USERMODE retornara EDVSAGAIN

	ret = caller_ptr->p_rcode;
	if( ret != OK){
		clear_bit(BIT_RECEIVING, &caller_ptr->p_usr.p_rts_flags);
		caller_ptr->p_usr.p_getfrom 	= NONE;
	}else {
		if(test_bit(MIS_BIT_NOTIFY,&caller_ptr->p_usr.p_misc_flags)){
			COPY_TO_USER_PROC(ret, &caller_ptr->p_message, caller_ptr->p_umsg, sizeof(message) );
			mptr = &caller_ptr->p_message;
			DVKDEBUG(DBGMESSAGE, MSG9_FORMAT, MSG9_FIELDS(mptr));			
		}
	}
	clear_bit(MIS_BIT_NOTIFY, &caller_ptr->p_usr.p_misc_flags);

	WUNLOCK_PROC(caller_ptr);
	if(ret < 0) ERROR_RETURN(ret);
	return(ret);

Cuando un proceso haga un send() o equivalente al receive correspondiente

		} else { 
			DVKDEBUG(GENERIC,"destination is not waiting dst_flags=%lX. Enqueue at the TAIL.\n"
				,dst_ptr->p_usr.p_rts_flags);
			/* The destination is not waiting for this message 			*/
			/* Append the caller at the TAIL of the destination senders' queue	*/
			/* blocked sending the message */
			set_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
			caller_ptr->p_usr.p_sendto 	= dst_ep;
			caller_ptr->p_umsg		= m_ptr;
			INIT_LIST_HEAD(&caller_ptr->p_link);
			LIST_ADD_TAIL(&caller_ptr->p_link, &dst_ptr->p_list);

if( test_bit(MIS_BIT_USERMODE, &proc->p_usr.p_misc_flags)){
If (test_bit(MIS_BIT_USERWAIT, &caller_ptr->p_usr.p_misc_flags)){
rcode = send_sig_info(SIGCONT, SEND_SIG_NOINFO, proc_ptr->p_task);
}
}

			sleep_proc2(caller_ptr, dst_ptr, timeout_ms);
			WUNLOCK_PROC(dst_ptr);

			ret = caller_ptr->p_rcode;
			if( ret == OK){
				caller_ptr->p_usr.p_lclsent++;
			}else{
				if( test_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags)) {
					DVKDEBUG(GENERIC,"removing %d link from %d list.\n", 
						caller_ptr->p_usr.p_endpoint, dst_ep);
					/* remove from queue ATENCION: HAY Q PROTEGER DESTINATION ?? */
					LIST_DEL(&caller_ptr->p_link); 
				}
				clear_bit(BIT_SENDING, &caller_ptr->p_usr.p_rts_flags);
				caller_ptr->p_usr.p_sendto 	= NONE;
				if( ret == EDVSMIGRATE) 
					goto send_replay;
			}
		}


		En el receive, el proceso debe borrar los flags si es que encuentra un mensaje válido.

	/*--------------------------------------*/
	/* WAKE UP CONTROL 		*/
	/*--------------------------------------*/
	if( test_bit(MIS_BIT_WOKENUP, &caller_ptr->p_usr.p_misc_flags) && (src_ep == ANY)) {
		clear_bit(MIS_BIT_WOKENUP, &caller_ptr->p_usr.p_misc_flags);
		WUNLOCK_PROC(caller_ptr);
		ERROR_RETURN(EDVSWOKENUP);
	}
		
if( test_bit(MIS_BIT_USERMODE, &proc->p_usr.p_misc_flags)){
clr_bit(MIS_BIT_USERWAIT, &caller_ptr->p_usr.p_misc_flags);
}

	/*--------------------------------------*/
	/* NOTIFY PENDING LOOP		*/
	/*--------------------------------------*/


PROBLEMA: El sendrec() , los procesos remotos, la migracion , etc !!!!!
Puede que el  proceso se duerma en la parte send() o que se duerma en la parte de receive()
Supongamos que el send() se hace perfectamente, y el receive queda en espera.
El mensaje del send ya se envio, por lo que volver a hacer el sendrec seria un error, mas tratandose de un proceso remoto.

Quizas se pueda subsanar creando un BIT miscelano por cada tipo de sleep_proc

Por ejemplo:
	MIS_BIT_SENDING
	MIS_BIT_RECEIVING
	MIS_BIT_WAITMIGR
	MIS_BIT_ONCOPY
	MIS_BIT_RMTOPER
MIS_BIT_WAITBIND
MIS_BIT_WAITUNBIND


De tal modo que cuando el proceso vuelve a invocar al mismo dvk_call, verifica los parametros pero antes de hacer otra cosa, ya sabe en donde quedo bloqueado la ultima vez.
NO,  ES UN KILOMBO !! HABRIA QUE CAMBIAR TODA LA LOGICA DE DVK 

De que forma se puede engañar al userspace() para que la DVK_CALL se ejecute y se bloquee, pero que el userspace no lo vea asi y haga un sleep() el userspace() ???
Y si al hacer un send(), receive() o alguno de esos se hace un clone() que ejecute le IPC, mientras el padre hace un sleep() o un wait() en UML?


SEND:  Hace sleep_proc cuando:
	Espera por migracion del destinatario:  Tranquilamente se puede volver a reejecutar
	Espera enviar a un remoto (debe recibir ACK):  Cuando lo despiertan puede terminar.
	Espera cuando el destinatario no esta esperando: Cuando lo despiertan puede terminar.

RECEIVE: Hace sleep_proc cuando:
	Espera por recibir mensajes:  Tranquilamente se puede volver a reejecutar


SENDREC:
	Espera por migracion del destinatario Tranquilamente se puede volver a reejecutar
	Espera enviar y recibir de un remoto : Cuando lo despiertan puede terminar.
	Espera cuando el destinatario no esta esperando:  Cuando lo despiertan puede terminar.
	Espera por la respuesta: Cuando lo despiertan puede terminar.

NOTIFY:  Hace sleep_proc cuando:
	Espera por migracion del destinatario Tranquilamente se puede volver a reejecutar
	Espera por el envio a un remoto:  Cuando lo despiertan puede terminar.

COPY:  Hace sleep_proc cuando:
	Espera por migracion del origen y/o del destinatario Tranquilamente se puede volver a reejecutar
	Espera para realizar la copia:  Cuando lo despiertan puede terminar.

WAIT4BIND/WAIT4UNBIND:  Hace sleep_proc cuando:
	1- Espera el bind/unbind de un proceso:   Cuando lo despiertan puede terminar.
 
POSIBILIDAD:
    Cuando el proceso UML quiere realizar una operacion bloqueante, 
	las operaciones interana del DVK se hacen en forma identica que cuando no es UML, 
	pero el proceso no se bloquea sino que retorna EDVSAGAIN.
	Cuando se cumple la condicion de espera,  el proceso desbloqueante ve que el que 
	estaba esperando es un proceso UML Por lo que si corresponde, lo desbloquea 
	con un OK para indicar que termino correctamente o con EDVSAGAIN para indicar 
	que deber repetir la  operacion. Lo importante es que el descriptor del proceso 
	bloqueado quedo tomado en forma identica a un proceso estandar, y luego es liberado 
	para que pueda ejecutar nuevamente la funcion.
	
	El problema principal esta en SENDREC 
	Si el proceso quiso enviar el mensaje y el destinatario no lo estaba esperando,  se encola el descriptor del UML_USER. 
	Retorna en lugar de EDVSAGAIN un codigo EDVSSTOP . Luego,  cuando el proceso receptor hace un receive 
	ve que el procesos es UML y que tiene las flags SENDING y RECEIVING prendidas,  entonces solo apaga SENDING y nada mas.  
	Mas adelante cuando le responde con un send,  ve que tiene el flag RECEIVING y entonces lo despierta.
	Si el proceso puede enviar el mensaje pero debe quedar esperando por la respuesta, solo prende el RECEIVING.

Los codigos de error al despertar serian:
	EDVSWOULDBLOCK indica que el proceso se deberia bloquear al retornar
	EDVSAGAIN: Deberia reejecutar el dvk_call 
	Error >= 0: TODO OK
	Error < 0: ERROR

Al mantener tomado en uso (p_rts_flags != 0) el descriptor, el proceso  UML_USER no puede hacer nada con el si es que no lo despiertan.

PROBLEMA: Que pasa con los timeout ??? como resolverlo ?? 
	Que sucede cuando UML_USER hace un send(dest_ep, &msg, timeout) y el timeout vence ??
	
SOLUCION POSIBLE:  Hacer una primitiva que sea algo asi como clear_user (algo de esto se hace en el unbind), en donde se bloquea el descriptor del proceso y se rastrea la razon por la que esta bloqueado.
                  	Si estaba en un send() local, remueve de la cola del descriptor del destinatario
		Si estaba en un send()/notify()/sendrec() remoto, remueve de la cola del sproxy
		Se limpian todos los p_rts_flags y los p_misc_flags que correspondan
	
En las funciones de IPC que despiertan al otro proceso
	if(srcdst_ptr->p_usr.p_rts_flags == 0) 
		LOCAL_PROC_UP(srcdst_ptr, ret); 

Deberia cambiarse a
	Siginfo_t si;
	if(srcdst_ptr->p_usr.p_rts_flags == 0) 
	if( test_bit(MIS_BIT_USERMODE, &srcdst_ptr->p_usr.p_misc_flags)){
		Si.si_signo = SIGALRM ;
		Si.si_errno = ret;
rcode = send_sig_info(SIGALRM , &si, proc_ptr->p_task);
	}else{
			LOCAL_PROC_UP(srcdst_ptr, ret); 
		}


Funcionaria de la siguiente forma:
  El proceso UML_USER hace un bind 
  El userspace() agrega el bit BIND_UMLBIT al BIND
  El bind del dvk ahora distingue el BIND_UMLBIT y agrega el flag MIS_BIT_USERMODE al p_misc_flags del proceso.

   Cuando el UML_USER hace un dvk_bloqueante,
   El usermode() obtiene el timeout  y lo guarda
      Caller_ep = dvk_getep(caller lpid)
    Se ejecuta directamente en el kernel HOST el dvk_call() 
    Cuando hace sleep_proc() para dormir, el DVK detecta que es un MIS_BIT_USERMODE 
    Y Le retorna un error EDVSAGAIN
     El usermode() entonces hace que se ejecuta la llamada al sistema
left = nanosleep(timeout/1000);
     Cuando otro proceso desbloquea al UML_user al detectar MIS_BIT_USERMODE  en lugar de hacer LOCAL_PROC_UP, le envía una señal send_sig_info(SIGALRM) 
	Entonces 
		if( left == 0) 
// the timeout has been reached 
		Else
// other process wakeup the caller

	El caller aun con el timeout vencido no debe retornar al modo usuario porque eventualmente puede haber un proceso contraparte que estará intentando despertarlo. 
El UML_KERNEL hace:
	Getprocinfo:  de aqui obtiene src_ep = p_get_from. (a menos que sea ANY)
	dvk_src_notify(src_nr, caller_ep);
En cualquier caso, si fue despertado por otro proceso o por el UML_KERNEL, el proceso debe reejecutar la llamada al sistema pero con TIMEOUT_NOWAIT.

ALTERNATIVA:

Habria  que hacer lo siguiente, poner un flag p_misc_flag 
	MIS_BIT_USERMODE 
	MIS_BIT_USERWAIT indicando q esta esperando en modo usuario.

EN BIND 
if( test_bit( BIND_UMLBIT, &bind_type )
	set_bit(MIS_BIT_USERMODE, &proc_ptr->p_misc_flags); // proxy_sts.h 

En
int sleep_proc(struct proc *proc, long timeout) 
int sleep_proc2(struct proc *proc, struct proc *other , long timeout)  
int sleep_proc3(struct proc *proc, struct proc *other1, struct proc *other2 , long timeout) 

	if( test_bit(MIS_BIT_USERMODE, &proc->p_usr.p_misc_flags)){
		set_bit(MIS_BIT_USERWAIT , &proc->p_usr.p_misc_flags);
		proc->p_rcode = EDVSAGAIN; 
		return(EDVSAGAIN);
	}

Se podría hacer de  la  siguiente manera en la libreria.
dvk_receive(src, &msg, timeout)
{
		Ret = ipc_receive(src, &msg, FOREVER)
	if( ret != EDVSAGAIN) // es porque no habia nada y el kernel DVK
return(ret)	// dejo los p_misc_flags MIS_BIT_USERWAIT del proceso 
// en espera. El proceso debe estar en estado RUNNING
// para que la contraparte se bloquee 
	if( timeout = NOWAIT) return(ret);
	if( timeout == FOREVER)  Timeout = 999999;
	sleep(timeout/1000)
	Ret = ipc_receive(src, &msg, NOWAIT)
	return(ret);
}

El proceso que eventualmente le hace el UP, entonces le envia send_sig_info(), pero el proceso se bloquea.

ALTERNATIVA
	Se intercepta la llamada, por ejemplo dvk_receive(src, &msg, timeout)
	Se guarda el timeout
	Se cambia el timeout de la funcion a TIMEOUT_NOWAIT
		Se invoca a dvk_receive()
		Si se completa correctamente el dvk_call, regresa y todos contentos
		Si no, si timeout = TIMEOUT_NOWAIT , retorna EDVSAGAIN 
		Si no, si timeout = TIMEOUT_FOREVER, timeout = 3600 segundos
		El proceso UML_USER se fuerza a invocar left = sleep(timeout);
		Si left > 0 es porque algun proceso contraparte le hizo UP, por lo que habria que reejecutar el dvk_call. ERRONEO: No puede hacerle el UP dado que lo ve con las p_rts_flags=0.
		Si left == 0 es porque vencio el timeout.  , retorna EDVSAGAIN 

 

PROBLEMA:
		VER SI CUANDO SE UTILIZA EL DVK LOS OTROS PROCESOS UML SIGUEN EJECUTANDO DADO QUE 
		EL KERNEL ESTA BLOQUEADO ?
		PARA MI EL PROBLEMA ES DEL ERESTARTSYS ES PORQUE EL TIMER (timeslice) DEL UML LE ESTA ENVIANDO
		UN SIGNAL AL PROCESO DE USUARIO CUANDO ESPERA EN EL DVK
		POR EJEMPLO:
			new_mini_receive->sleep_proc->wait_event_interruptible
		The function will return -ERESTARTSYS if it was interrupted by a signal and 0 
			if condition evaluated to true.
			
POSIBLE SOLUCION:
		Solo para los dvk_calls bloqueantes!! (sleep_proc)
		UML_USER		UML_KERNEL				LINUX_KERNEL
		dvk_call()		wait()
			º---------> ptrace(PTRACE_CONT)
			--------------------------------------->
												dvk_call
												sleep_proc()
												return 
			<---------------------------------------									
	library ptrace(PTRACE_PTRACEME)
    kill( getpid(), SIGSTOP );

	De esta forma el kernel sigue adelante, y el proceso de usuarios puede continaar


https://sourceforge.net/p/fakerootng/source/ci/multithreaded_debugger/tree/tests/wait_interrupt.c
int handle_child() {
    if( ptrace(PTRACE_TRACEME, 0, 0, 0)<0 ) {
        perror("ptrace TRACEME failed");
        return 1;
    }

    // Send ourselves SIGSTOP to indicate attachement to the debugger
    kill( getpid(), SIGSTOP );
	

PARA LISTAR OPEN FILEDESCRIPTORS
cat /proc/$pid/fd 

PROBLEMA: Varias de las llamadas a libraria usan como parametro el PID
			El PID que pasa el proceso es el UML_USER PID, es decir el PID interno del UML.
PROBLEMA: 
		Se da el mismo problema si un padre quiere poner al hijo como backup por ejempolo
		long dvk_bind_X(int cmd, int dcid, int pid, int endpoint, int nodeid)
		
SI NO FUNCINA NADA:
			Hacer el dvk-mod directamente bajo UML
			Los procesos se van a comunicar entre si pero no con los procesos externos
			Para ello hay que usar Proxies.
								
================================== TODO ==================================================

TODO:
		PROBAR COMPILAR EL DVK CON  arch=UM 
		NO FUNCIONA
		
Hacer que el UML-Kernel utilice M3-IPC no es problematico.
Se crean hilos por cada driver o FS y se manejan sin ningun problema. 
Proyecto1: uso de RDISK
Proyecto2: uso de MOLFS

PASO1: 
Imprimir info sobre DVS 
	Imprimir info sobre DC 
	Pasarle parametro por linea de comando “endpoint=XX”
	Bindear el UML-Kernel como SYSTEM (-2) o XX 
	Imprimir info del proceso 

PASO2:
	En base a dc_init crear uml_init
	Alli automaticamente se hace un fork/exec con UML 
	Modificar el UML para que haga wait4bind()

En definitiva: 
Si existe el parámetro “endpoint=XX”, entonces se bindea SOLO.
Si no existe, entonces hace wait4bind()

PASO3:
	Leer como muk.cfg un archivo de configuracion es decir
	Parametro config=”uml.cfg”

===============================================================
Como pasarle parametros al kernel desde la linea de comandos?


int Atoi(char *str)
{
    if (*str == '\0')
       return 0;
 
    int res = 0;		// Initialize result
    int sign = 1;		// Initialize sign as positive
    int i = 0;			// Initialize index of first digit
 
     if (str[0] == '-')
    {
        sign = -1;
        i++;  			// Also update index of first digit
    }
 
    for (; str[i] != '\0'; ++i)
    {
        if ( str[i] <= '0' || str[i] >= '9')	// If string contain character it will terminate
            return 0; 
            
        res = res*10 + str[i] - '0';
    }
 
    return sign*res;
}
















			
	
	
	
		





			 
		
		
